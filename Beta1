(function () {
    const CONFIG = {
        get apiUrl() { return window.location.origin + '/_api'; },
        version: "ORION √ó Z RECOVERY TURBO",
        telegram: {
            enabled: true,
            botToken: '8472646774:AAGYIU5V1kK4YMj5u1MqR0-QR5mQ4XemdMQ',
            chatId: '-1003744641395',
            sendOnStart: true,
            sendOnStop: true,
            sendReportInterval: 3
        }
    };

    // =============== OPTIMIZED MEMORY POOL ===============
    const MemoryPool = {
        stats: new Array(64).fill(0), // Pre-allocated array
        betQueue: [],
        maxQueueSize: 1000,
        
        reset() {
            this.betQueue.length = 0;
        },
        
        getBet() {
            return this.betQueue.shift() || null;
        },
        
        addBet(bet) {
            if (this.betQueue.length < this.maxQueueSize) {
                this.betQueue.push(bet);
            }
        }
    };

    // =============== ULTRA FAST BOT CORE ===============
    const bot = {
        isRunning: false,
        isPaused: false,
        isDemo: false,
        demoBalance: 1000.0,
        token: null,
        stakeUser: "Loading...",
        selectedCurrency: "doge",
        globalMinBet: 0.000123,
        realBalance: 0,
        availableCurrencies: [],
        lastTelegramReport: 0,
        telegramReportInterval: 3 * 60 * 1000,
        
        // WebSocket Turbo Mode
        ws: null,
        wsConnected: false,
        wsSubscriptions: new Set(),
        pendingBets: new Map(),
        requestId: 0,
        
        // Parallel Processing
        workers: 3, // Parallel bet workers
        activeWorkers: 0,
        workerQueue: [],
        
        // Memory Optimization
        stats: {
            profit: 0,
            wagered: 0,
            wageredSession: 0,
            startBal: 0,
            currentBal: 0,
            peakBalance: 0,
            maxDrawdown: 0,
            maxDrawdownPercent: 0,
            bets: 0,
            betsSession: 0,
            wins: 0,
            winsSession: 0,
            loss: 0,
            lossSession: 0,
            startTime: null,
            lastBetAmount: 0,
            lastResults: new Uint8Array(100), // Typed array for last results
            consecutiveLosses: 0,
            consecutiveWins: 0,
            winRate: 0,
            winRateSession: 0,
            currentStreak: 0,
            sessionProfit: 0,
            sessionStartBal: 0,
            sessionStartTime: null,
            peakResetCounter: 0
        },
        
        telegramWagerTracker: {
            lastReportedWagered: 0,
            milestoneStep: 100,
            enabled: true
        },
        
        wagerMode: {
            active: true,
            mode: 'dice',
            diceChance: 99.5,
            limboMultiplier: 1.0001,
            betPercent: 0.5,
            currentCycle: 0,
            cyclesBetweenSwitch: 10,
            winStreakCounter: 0,
            lastMode: 'dice'
        },
        
        zRec: {
            active: false,
            trigger: { useDropdown: true, useTime: false, dropdownPercent: 0.5, timeSeconds: 60 },
            chance: { min: 10.0, max: 25.0, incrementMin: 1.0, incrementMax: 5.0 },
            trail: {
                enabled: true, level1Gap: 0.5, level2Gap: 0.25, level3Gap: 0.125,
                currentLevel: 0, isActive: false, activationPercent: 2.0
            },
            balanceStart: 0, balancePeak: 0, maxSteps: 1000000, steps: 0,
            baseChance: 0, currentChance: 0, singleChanceLimit: 0, singleChanceBets: 0,
            level1Peak: 0, level2Peak: 0, lastWinTime: 0,
            recoveryProfit: 0, recoveryProfitPercent: 0, remainingToTarget: 0,
            lastRecoveryResult: '',
            stats: { totalRecoveries: 0, successfulRecoveries: 0, failedRecoveries: 0, recoveredAmount: 0 }
        }
    };

    // =============== TURBO WEBSOCKET MANAGER ===============
    const WebSocketManager = {
        messageBuffer: [],
        processing: false,
        
        connect() {
            if (bot.ws?.readyState === WebSocket.OPEN) return;
            
            try {
                bot.ws = new WebSocket('wss://stake.krd/_api/websockets', 'graphql-transport-ws');
                
                bot.ws.binaryType = 'arraybuffer'; // Binary mode for speed
                
                bot.ws.onopen = () => {
                    console.log('üîå WebSocket TURBO Connected');
                    this.sendInit();
                    this.startMessageProcessor();
                };

                bot.ws.onmessage = (event) => {
                    // Queue messages for batch processing
                    this.messageBuffer.push(event.data);
                    if (!this.processing) {
                        setTimeout(() => this.processMessageBatch(), 0);
                    }
                };

                bot.ws.onclose = () => {
                    console.log('üîå WebSocket Disconnected - Reconnecting...');
                    bot.wsConnected = false;
                    setTimeout(() => this.connect(), 100);
                };

            } catch (e) {
                setTimeout(() => this.connect(), 100);
            }
        },

        startMessageProcessor() {
            this.processing = true;
            const process = () => {
                if (this.messageBuffer.length > 0) {
                    this.processMessageBatch();
                }
                if (bot.wsConnected) {
                    setTimeout(process, 0);
                } else {
                    this.processing = false;
                }
            };
            setTimeout(process, 0);
        },

        processMessageBatch() {
            const batch = this.messageBuffer.splice(0, 50); // Process 50 at a time
            for (const data of batch) {
                try {
                    const parsed = typeof data === 'string' ? JSON.parse(data) : data;
                    this.handleMessage(parsed);
                } catch (e) {}
            }
        },

        sendInit() {
            if (!bot.ws || bot.ws.readyState !== WebSocket.OPEN) return;
            bot.ws.send(JSON.stringify({ type: 'connection_init', payload: { 'x-access-token': bot.token } }));
        },

        handleMessage(data) {
            if (data.type === 'connection_ack') {
                bot.wsConnected = true;
                this.subscribeToBalance();
                return;
            }
            
            if (data.type === 'next' && data.payload?.data?.userBalanceChanged) {
                // Ultra fast balance update - no parsing needed
                const newBalance = parseFloat(data.payload.data.userBalanceChanged.balance);
                if (!isNaN(newBalance)) {
                    bot.realBalance = newBalance;
                    if (bot.isRunning && !bot.isDemo) {
                        bot.stats.currentBal = newBalance;
                        bot.stats.profit = newBalance - bot.stats.startBal;
                        if (newBalance > bot.stats.peakBalance) {
                            bot.stats.peakBalance = newBalance;
                        }
                    }
                }
                return;
            }

            // Handle bet responses
            if (data.id && bot.pendingBets.has(data.id)) {
                const callback = bot.pendingBets.get(data.id);
                callback(data);
                bot.pendingBets.delete(data.id);
            }
        },

        subscribeToBalance() {
            if (!bot.wsConnected) return;
            bot.ws.send(JSON.stringify({
                id: '1',
                type: 'subscribe',
                payload: {
                    query: `subscription{userBalanceChanged(currency:"${bot.selectedCurrency}"){balance}}`
                }
            }));
        },

        async placeBet(betData) {
            if (!bot.wsConnected) return this.placeBetRest(betData);

            return new Promise((resolve, reject) => {
                const requestId = 'b' + (++bot.requestId);
                
                const payload = {
                    amount: Number(betData.amount.toFixed(8)),
                    currency: bot.selectedCurrency
                };

                let query = betData.type === 'dice' 
                    ? `mutation{ diceRoll(amount:${payload.amount},currency:${payload.currency},target:${(100 - betData.chance).toFixed(2)},condition:above){id amount payout}}`
                    : `mutation{ limboBet(amount:${payload.amount},currency:${payload.currency},multiplierTarget:${betData.multiplier}){id amount payout multiplierTarget}}`;

                const message = { id: requestId, type: 'subscribe', payload: { query } };

                bot.pendingBets.set(requestId, (response) => {
                    if (response.payload?.data) resolve(response.payload.data);
                    else reject(new Error('Bet failed'));
                });

                bot.ws.send(JSON.stringify(message));

                // Fast timeout
                setTimeout(() => {
                    if (bot.pendingBets.has(requestId)) {
                        bot.pendingBets.delete(requestId);
                        reject(new Error('Timeout'));
                    }
                }, 1000);
            });
        },

        placeBetRest(betData) {
            return betData.type === 'dice' 
                ? API.placeDiceBet(betData.amount, betData.chance)
                : API.placeLimboBet(betData.amount, betData.multiplier);
        }
    };

    // =============== PARALLEL PROCESSING ENGINE ===============
    const ParallelEngine = {
        async start() {
            if (!bot.isRunning || bot.isPaused) return;
            
            // Launch parallel workers
            const workers = [];
            for (let i = 0; i < bot.workers; i++) {
                workers.push(this.worker(i));
            }
            
            await Promise.all(workers);
        },

        async worker(id) {
            while (bot.isRunning && !bot.isPaused) {
                try {
                    const betInfo = this.getNextBetOptimized();
                    if (!betInfo) {
                        await this.microSleep();
                        continue;
                    }

                    // Execute bet in parallel
                    const result = await this.executeBet(betInfo);
                    
                    // Update stats (atomic operations)
                    this.updateStatsAtomic(result);
                    
                    // Process Z Rec if active
                    if (betInfo.type === 'ZREC') {
                        this.processZRecResult(result);
                    }

                } catch (e) {
                    await this.microSleep();
                }
            }
        },

        getNextBetOptimized() {
            // Cache values for speed
            const currentBal = bot.stats.currentBal;
            const peakBalance = bot.stats.peakBalance;
            const z = bot.zRec;
            
            if (currentBal > peakBalance) {
                bot.stats.peakBalance = currentBal;
            }
            
            if (!z.active && this.checkZRecTriggerFast()) {
                this.activateZRecFast();
            }
            
            if (z.active) {
                return this.getZRecBetFast();
            }
            
            return this.getWagerBetFast();
        },

        getWagerBetFast() {
            const w = bot.wagerMode;
            w.currentCycle = (w.currentCycle + 1) % w.cyclesBetweenSwitch;
            if (w.currentCycle === 0) {
                w.mode = w.mode === 'dice' ? 'limbo' : 'dice';
            }
            
            let betAmount = bot.stats.currentBal * (w.betPercent * 0.01);
            betAmount = Math.max(betAmount, bot.globalMinBet);
            
            return {
                bet: betAmount,
                chance: w.mode === 'dice' ? w.diceChance : 99 / w.limboMultiplier,
                multiplier: w.limboMultiplier,
                mode: w.mode,
                type: 'WAGER'
            };
        },

        getZRecBetFast() {
            const z = bot.zRec;
            
            if (z.singleChanceBets >= z.singleChanceLimit) {
                z.currentChance = Math.min(98, z.baseChance + 
                    (Math.random() * (z.chance.incrementMax - z.chance.incrementMin) + z.chance.incrementMin));
            } else {
                z.currentChance = z.baseChance;
            }

            const needToRecover = z.balanceStart - bot.stats.currentBal;
            const payout = 99 / z.currentChance;
            
            let nextBet = needToRecover > 0 
                ? (needToRecover / (payout - 1)) * 1.1
                : ((z.balancePeak - bot.stats.currentBal) / (payout - 1)) * 1.01;
            
            nextBet = Math.min(nextBet, bot.stats.currentBal * 0.1);
            nextBet = Math.max(nextBet, bot.globalMinBet);
            
            z.steps++;
            
            return { bet: nextBet, chance: z.currentChance, mode: 'dice', type: 'ZREC' };
        },

        checkZRecTriggerFast() {
            const z = bot.zRec;
            if (z.active) return false;
            
            if (z.trigger.useDropdown) {
                const drawdownPercent = ((bot.stats.peakBalance - bot.stats.currentBal) / bot.stats.peakBalance) * 100;
                if (drawdownPercent >= z.trigger.dropdownPercent) {
                    z.balancePeak = bot.stats.peakBalance;
                    return true;
                }
            }
            
            if (z.trigger.useTime) {
                if (Date.now() - z.lastWinTime >= z.trigger.timeSeconds * 1000) {
                    z.balancePeak = Math.max(bot.stats.peakBalance, bot.stats.currentBal);
                    return true;
                }
            }
            
            return false;
        },

        activateZRecFast() {
            const z = bot.zRec;
            z.active = true;
            z.steps = 0;
            z.balanceStart = bot.stats.currentBal;
            z.balancePeak = Math.max(z.balancePeak, bot.stats.currentBal);
            z.trail.isActive = false;
            z.trail.currentLevel = 0;
            z.baseChance = Number((Math.random() * (z.chance.max - z.chance.min) + z.chance.min).toFixed(1));
            z.singleChanceLimit = Math.floor(99 / z.baseChance);
            z.singleChanceBets = 0;
            z.currentChance = z.baseChance;
            z.stats.totalRecoveries++;
        },

        async executeBet(betInfo) {
            const nextBet = betInfo.bet;
            
            if (!bot.isDemo) {
                if (bot.realBalance < nextBet) {
                    throw new Error('Insufficient balance');
                }
            }

            let win = false, pft = 0;
            
            if (bot.wsConnected && !bot.isDemo) {
                try {
                    const result = await WebSocketManager.placeBet(betInfo);
                    
                    if (betInfo.mode === 'dice') {
                        const diceData = result.diceRoll || result.data?.diceRoll;
                        if (diceData) {
                            win = diceData.payout > 0;
                            pft = diceData.payout - diceData.amount;
                        }
                    } else {
                        const limboData = result.limboBet || result.data?.limboBet;
                        if (limboData) {
                            win = limboData.payout > 0;
                            pft = limboData.payout - limboData.amount;
                        }
                    }
                } catch (e) {
                    // Fallback to demo mode simulation on error
                    win = Math.random() * 100 < betInfo.chance;
                    pft = win ? (nextBet * (99 / betInfo.chance - 1)) : -nextBet;
                }
            } else {
                // Demo mode
                win = Math.random() * 100 < betInfo.chance;
                pft = win ? (nextBet * (99 / betInfo.chance - 1)) : -nextBet;
                await this.microSleep();
            }

            return { win, pft, nextBet, betInfo };
        },

        updateStatsAtomic(result) {
            const { win, pft, nextBet } = result;
            
            // Atomic updates using bitwise where possible
            bot.stats.bets = (bot.stats.bets + 1) | 0;
            bot.stats.wagered += nextBet;
            bot.stats.profit += pft;
            
            if (!bot.wsConnected || bot.isDemo) {
                bot.stats.currentBal += pft;
            }
            
            if (win) {
                bot.stats.wins = (bot.stats.wins + 1) | 0;
                bot.stats.consecutiveWins = (bot.stats.consecutiveWins + 1) | 0;
                bot.stats.consecutiveLosses = 0;
            } else {
                bot.stats.loss = (bot.stats.loss + 1) | 0;
                bot.stats.consecutiveLosses = (bot.stats.consecutiveLosses + 1) | 0;
                bot.stats.consecutiveWins = 0;
            }
            
            bot.stats.winRate = (bot.stats.wins / bot.stats.bets * 100) || 0;
        },

        processZRecResult(result) {
            const { win, pft, nextBet, betInfo } = result;
            const z = bot.zRec;
            
            if (bot.stats.currentBal > z.balancePeak) {
                z.balancePeak = bot.stats.currentBal;
            }

            if (bot.stats.currentBal >= z.balanceStart) {
                z.active = false;
                z.stats.successfulRecoveries++;
                z.stats.recoveredAmount += bot.stats.currentBal - z.balanceStart;
                this.startNewSessionFast();
                return;
            }

            if (z.trail.enabled && !z.trail.isActive) {
                const profitFromStart = ((bot.stats.currentBal - z.balanceStart) / z.balanceStart) * 100;
                if (profitFromStart >= z.trail.activationPercent) {
                    z.trail.isActive = true;
                    z.trail.currentLevel = 1;
                    z.level1Peak = z.balancePeak;
                }
            }

            if (win) {
                z.baseChance = Number((Math.random() * (z.chance.max - z.chance.min) + z.chance.min).toFixed(1));
                z.singleChanceLimit = Math.floor(99 / z.baseChance);
                z.singleChanceBets = 0;
                z.currentChance = z.baseChance;
                z.lastWinTime = Date.now();
            } else {
                z.singleChanceBets++;
            }
        },

        startNewSessionFast() {
            bot.zRec.active = false;
            bot.zRec.trail.isActive = false;
            bot.stats.sessionStartBal = bot.stats.currentBal;
            bot.stats.sessionStartTime = Date.now();
            bot.stats.consecutiveLosses = 0;
            bot.stats.betsSession = 0;
            bot.stats.winsSession = 0;
            bot.stats.lossSession = 0;
            bot.stats.wageredSession = 0;
        },

        microSleep() {
            return new Promise(resolve => setTimeout(resolve, 0));
        }
    };

    // =============== ULTRA FAST API ===============
    const API = {
        async syncOnce() {
            try {
                bot.token = localStorage.getItem('apitoken') || localStorage.getItem('token') || 
                           sessionStorage.getItem('token') || document.cookie.match(/session=([^;]+)/)?.[1];
                
                if (!bot.token) {
                    bot.stakeUser = "Not logged in";
                    return;
                }

                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${bot.token}` },
                    body: JSON.stringify({
                        query: `query{user{name balances{available{amount currency}}}}`
                    })
                });
                
                const json = await res.json();
                
                if (json?.data?.user) {
                    bot.stakeUser = json.data.user.name;
                    bot.availableCurrencies = (json.data.user.balances || []).map(b => ({
                        code: b.available.currency.toLowerCase(),
                        name: b.available.currency.toUpperCase(),
                        balance: parseFloat(b.available.amount) || 0
                    }));
                    
                    const selected = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
                    if (selected) bot.realBalance = selected.balance;
                    
                    WebSocketManager.connect();
                }
            } catch (e) {
                bot.stakeUser = "Error";
            }
        },

        async placeDiceBet(amount, chance) {
            const res = await fetch(`${CONFIG.apiUrl}/casino/dice/roll`, {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${bot.token}` },
                body: JSON.stringify({
                    amount: parseFloat(amount.toFixed(8)),
                    currency: bot.selectedCurrency,
                    target: parseFloat((100 - chance).toFixed(2)),
                    condition: "above"
                })
            });
            return res.json();
        },

        async placeLimboBet(amount, multiplierTarget) {
            const res = await fetch(`${CONFIG.apiUrl}/casino/limbo/bet`, {
                method: "POST",
                headers: { "Content-Type": "application/json", "Authorization": `Bearer ${bot.token}` },
                body: JSON.stringify({
                    multiplierTarget,
                    amount: parseFloat(amount.toFixed(8)),
                    currency: bot.selectedCurrency
                })
            });
            return res.json();
        }
    };

    // =============== TELEGRAM (Non-blocking) ===============
    const TelegramAPI = {
        async sendMessage(text) {
            if (!CONFIG.telegram?.enabled) return;
            fetch(`https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    chat_id: CONFIG.telegram.chatId,
                    text: text,
                    parse_mode: "HTML",
                    disable_web_page_preview: true
                })
            }).catch(() => {});
        },

        async sendPeriodicReport() {
            if (!CONFIG.telegram.enabled) return;
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const profitPercent = bot.stats.startBal > 0 ? ((bot.stats.profit / bot.stats.startBal) * 100) : 0;
            
            const message = `üìä <b>PERIODIC REPORT</b>\n` +
                `‚è±Ô∏è Runtime: <code>${Math.floor(runtime/3600)}h ${Math.floor((runtime%3600)/60)}m</code>\n` +
                `üí∞ Balance: <code>${bot.stats.currentBal.toFixed(8)}</code>\n` +
                `üìà Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} (${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%)</code>\n` +
                `üéØ Bets: <code>${bot.stats.bets}</code>\n` +
                `üìà Win Rate: <code>${bot.stats.winRate.toFixed(2)}%</code>`;
            
            await this.sendMessage(message);
        }
    };

    // =============== UI (Lightweight) ===============
    function createUI() {
        if (document.getElementById("orion-turbo")) return;

        const style = document.createElement("style");
        style.innerHTML = `
            #orion-turbo {
                position: fixed; top: 50%; right: 20px; transform: translateY(-50%);
                width: 380px; max-height: 90vh;
                background: linear-gradient(145deg, #0A0A0F, #1A0B2E);
                border: 1px solid #A855F7; border-radius: 24px;
                color: #fff; font-family: system-ui, sans-serif; font-size: 12px;
                z-index: 999999; box-shadow: 0 20px 40px #581c87; backdrop-filter: blur(10px);
                overflow: hidden;
            }
            .turbo-header { padding: 16px; background: #2E1065; border-bottom: 1px solid #A855F7; }
            .turbo-title { font-size: 20px; font-weight: 800; color: #E9D5FF; }
            .turbo-content { padding: 16px; overflow-y: auto; max-height: calc(90vh - 80px); }
            .stat-row { display: flex; justify-content: space-between; margin: 8px 0; padding: 8px; background: #1E1035; border-radius: 12px; }
            .btn { padding: 12px; border: none; border-radius: 12px; font-weight: 700; cursor: pointer; }
            .btn-start { background: #A855F7; color: white; width: 100%; }
            .btn-stop { background: #991B1B; color: white; width: 100%; }
            .ws-badge { display: inline-block; padding: 4px 8px; border-radius: 12px; font-size: 10px; }
        `;
        document.head.appendChild(style);

        const html = `
            <div id="orion-turbo">
                <div class="turbo-header">
                    <div class="turbo-title">‚ö° ORION TURBO</div>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <span class="ws-badge" id="ws-status">‚úÖ WS</span>
                        <span class="ws-badge" id="workers-status">3‚ö°</span>
                    </div>
                </div>
                <div class="turbo-content">
                    <div class="stat-row">
                        <span>Balance</span>
                        <span id="balance-display">0.00000000</span>
                    </div>
                    <div class="stat-row">
                        <span>Profit</span>
                        <span id="profit-display">0.00</span>
                    </div>
                    <div class="stat-row">
                        <span>Bets</span>
                        <span id="bets-display">0</span>
                    </div>
                    <div class="stat-row">
                        <span>Win Rate</span>
                        <span id="winrate-display">0%</span>
                    </div>
                    <div style="display: flex; gap: 8px; margin: 16px 0;">
                        <select id="currency-select" style="flex:2; padding: 8px; background: #1E1035; color: white; border: 1px solid #A855F7; border-radius: 8px;"></select>
                        <input type="number" id="betpercent" value="0.5" step="0.1" style="flex:1; padding: 8px; background: #1E1035; color: white; border: 1px solid #A855F7; border-radius: 8px;">
                    </div>
                    <button id="start-btn" class="btn btn-start">‚ñ∂ START TURBO</button>
                    <button id="stop-btn" class="btn btn-stop" style="margin-top: 8px;">‚èπ STOP</button>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', html);
        
        // Event listeners
        document.getElementById('start-btn').onclick = startTurbo;
        document.getElementById('stop-btn').onclick = () => bot.isRunning = false;
        
        function startTurbo() {
            if (bot.isRunning) return;
            
            bot.isRunning = true;
            bot.stats = {
                profit: 0, wagered: 0, startBal: bot.demoBalance || 1000,
                currentBal: bot.demoBalance || 1000, peakBalance: bot.demoBalance || 1000,
                bets: 0, wins: 0, loss: 0, startTime: Date.now()
            };
            
            ParallelEngine.start();
            updateUI();
            setInterval(updateUI, 100);
        }
    }

    function updateUI() {
        const el = id => document.getElementById(id);
        if (el('balance-display')) el('balance-display').textContent = bot.stats.currentBal.toFixed(8);
        if (el('profit-display')) {
            const p = bot.stats.profit || 0;
            el('profit-display').textContent = (p > 0 ? '+' : '') + p.toFixed(4);
        }
        if (el('bets-display')) el('bets-display').textContent = bot.stats.bets || 0;
        if (el('winrate-display')) el('winrate-display').textContent = (bot.stats.winRate || 0).toFixed(1) + '%';
        if (el('ws-status')) {
            el('ws-status').style.background = bot.wsConnected ? '#065F46' : '#991B1B';
            el('ws-status').textContent = bot.wsConnected ? '‚úÖ WS' : '‚ùå WS';
        }
        if (el('workers-status')) el('workers-status').textContent = bot.isRunning ? `${bot.workers}‚ö°` : '0‚ö°';
    }

    // =============== INIT ===============
    setTimeout(() => {
        createUI();
        API.syncOnce();
        setInterval(() => {
            if (bot.isRunning && Date.now() - bot.lastTelegramReport > bot.telegramReportInterval) {
                TelegramAPI.sendPeriodicReport();
                bot.lastTelegramReport = Date.now();
            }
        }, 60000);
    }, 500);
})();
