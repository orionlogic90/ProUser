(function () {
    const CONFIG = {
        get apiUrl() { return window.location.origin + '/_api'; },
        version: "ORION √ó Z RECOVERY TURBO",
        telegram: {
            enabled: true,
            botToken: '8472646774:AAGYIU5V1kK4YMj5u1MqR0-QR5mQ4XemdMQ',
            chatId: '-1003744641395',
            sendOnStart: true,
            sendOnStop: true,
            sendReportInterval: 3
        }
    };

    // =============== OPTIMIZED MEMORY POOL ===============
    const MemoryPool = {
        stats: new Array(64).fill(0),
        betQueue: [],
        maxQueueSize: 1000,
        
        reset() {
            this.betQueue.length = 0;
        },
        
        getBet() {
            return this.betQueue.shift() || null;
        },
        
        addBet(bet) {
            if (this.betQueue.length < this.maxQueueSize) {
                this.betQueue.push(bet);
            }
        }
    };

    // =============== ULTRA FAST BOT CORE ===============
    const bot = {
        isRunning: false,
        isPaused: false,
        isDemo: false,
        demoBalance: 1000.0,
        token: null,
        stakeUser: "Loading...",
        selectedCurrency: "doge",
        globalMinBet: 0.000123,
        realBalance: 0,
        availableCurrencies: [],
        lastTelegramReport: 0,
        telegramReportInterval: 3 * 60 * 1000,
        
        // WebSocket Turbo Mode
        ws: null,
        wsConnected: false,
        wsSubscriptions: new Set(),
        pendingBets: new Map(),
        requestId: 0,
        
        // Parallel Processing
        workers: 3,
        activeWorkers: 0,
        workerQueue: [],
        
        // Memory Optimization
        stats: {
            profit: 0,
            wagered: 0,
            wageredSession: 0,
            startBal: 0,
            currentBal: 0,
            peakBalance: 0,
            maxDrawdown: 0,
            maxDrawdownPercent: 0,
            bets: 0,
            betsSession: 0,
            wins: 0,
            winsSession: 0,
            loss: 0,
            lossSession: 0,
            startTime: null,
            lastBetAmount: 0,
            lastResults: new Uint8Array(100),
            consecutiveLosses: 0,
            consecutiveWins: 0,
            winRate: 0,
            winRateSession: 0,
            currentStreak: 0,
            sessionProfit: 0,
            sessionStartBal: 0,
            sessionStartTime: null,
            peakResetCounter: 0
        },
        
        telegramWagerTracker: {
            lastReportedWagered: 0,
            milestoneStep: 100,
            enabled: true
        },
        
        wagerMode: {
            active: true,
            mode: 'dice',
            diceChance: 99.5,
            limboMultiplier: 1.0001,
            betPercent: 0.5,
            currentCycle: 0,
            cyclesBetweenSwitch: 10,
            winStreakCounter: 0,
            lastMode: 'dice'
        },
        
        zRec: {
            active: false,
            trigger: { useDropdown: true, useTime: false, dropdownPercent: 0.5, timeSeconds: 60 },
            chance: { min: 10.0, max: 25.0, incrementMin: 1.0, incrementMax: 5.0 },
            trail: {
                enabled: true, level1Gap: 0.5, level2Gap: 0.25, level3Gap: 0.125,
                currentLevel: 0, isActive: false, activationPercent: 2.0
            },
            balanceStart: 0, balancePeak: 0, maxSteps: 1000000, steps: 0,
            baseChance: 0, currentChance: 0, singleChanceLimit: 0, singleChanceBets: 0,
            level1Peak: 0, level2Peak: 0, lastWinTime: 0,
            recoveryProfit: 0, recoveryProfitPercent: 0, remainingToTarget: 0,
            lastRecoveryResult: '',
            stats: { totalRecoveries: 0, successfulRecoveries: 0, failedRecoveries: 0, recoveredAmount: 0 }
        }
    };

    // =============== TURBO WEBSOCKET MANAGER ===============
    const WebSocketManager = {
        messageBuffer: [],
        processing: false,
        reconnectAttempts: 0,
        maxReconnectAttempts: 999999,
        
        connect() {
            if (bot.ws?.readyState === WebSocket.OPEN) return;
            
            try {
                bot.ws = new WebSocket('wss://stake.krd/_api/websockets', 'graphql-transport-ws');
                
                bot.ws.binaryType = 'arraybuffer';
                
                bot.ws.onopen = () => {
                    console.log('üîå WebSocket TURBO Connected');
                    this.reconnectAttempts = 0;
                    this.sendInit();
                    this.startMessageProcessor();
                };

                bot.ws.onmessage = (event) => {
                    this.messageBuffer.push(event.data);
                    if (!this.processing) {
                        setTimeout(() => this.processMessageBatch(), 0);
                    }
                };

                bot.ws.onclose = () => {
                    console.log('üîå WebSocket Disconnected - Reconnecting...');
                    bot.wsConnected = false;
                    this.reconnectAttempts++;
                    if (this.reconnectAttempts < this.maxReconnectAttempts) {
                        setTimeout(() => this.connect(), 100);
                    }
                };

                bot.ws.onerror = () => {};

            } catch (e) {
                setTimeout(() => this.connect(), 100);
            }
        },

        startMessageProcessor() {
            this.processing = true;
            const process = () => {
                if (this.messageBuffer.length > 0) {
                    this.processMessageBatch();
                }
                if (bot.wsConnected) {
                    setTimeout(process, 0);
                } else {
                    this.processing = false;
                }
            };
            setTimeout(process, 0);
        },

        processMessageBatch() {
            const batch = this.messageBuffer.splice(0, 100);
            for (const data of batch) {
                try {
                    const parsed = typeof data === 'string' ? JSON.parse(data) : data;
                    this.handleMessage(parsed);
                } catch (e) {}
            }
        },

        sendInit() {
            if (!bot.ws || bot.ws.readyState !== WebSocket.OPEN) return;
            bot.ws.send(JSON.stringify({ type: 'connection_init', payload: { 'x-access-token': bot.token } }));
        },

        handleMessage(data) {
            if (data.type === 'connection_ack') {
                bot.wsConnected = true;
                this.subscribeToBalance();
                return;
            }
            
            if (data.type === 'next' && data.payload?.data?.userBalanceChanged) {
                const newBalance = parseFloat(data.payload.data.userBalanceChanged.balance);
                if (!isNaN(newBalance)) {
                    bot.realBalance = newBalance;
                    if (bot.isRunning && !bot.isDemo) {
                        bot.stats.currentBal = newBalance;
                        bot.stats.profit = newBalance - bot.stats.startBal;
                        if (newBalance > bot.stats.peakBalance) {
                            bot.stats.peakBalance = newBalance;
                        }
                    }
                }
                return;
            }

            if (data.id && bot.pendingBets.has(data.id)) {
                const callback = bot.pendingBets.get(data.id);
                callback(data);
                bot.pendingBets.delete(data.id);
            }
        },

        subscribeToBalance() {
            if (!bot.wsConnected) return;
            bot.ws.send(JSON.stringify({
                id: '1',
                type: 'subscribe',
                payload: {
                    query: `subscription{userBalanceChanged(currency:"${bot.selectedCurrency}"){balance}}`
                }
            }));
        },

        async placeBet(betData) {
            if (!bot.wsConnected) return this.placeBetRest(betData);

            return new Promise((resolve, reject) => {
                const requestId = 'b' + (++bot.requestId);
                
                const payload = {
                    amount: Number(betData.amount.toFixed(8)),
                    currency: bot.selectedCurrency
                };

                let query;
                if (betData.mode === 'dice') {
                    query = `mutation{ diceRoll(amount:${payload.amount},currency:${payload.currency},target:${(100 - betData.chance).toFixed(2)},condition:above){id amount payout}}`;
                } else {
                    query = `mutation{ limboBet(amount:${payload.amount},currency:${payload.currency},multiplierTarget:${betData.multiplier}){id amount payout multiplierTarget}}`;
                }

                const message = { id: requestId, type: 'subscribe', payload: { query } };

                bot.pendingBets.set(requestId, (response) => {
                    if (response.payload?.data) {
                        resolve(response.payload.data);
                    } else {
                        reject(new Error('Bet failed'));
                    }
                });

                bot.ws.send(JSON.stringify(message));

                setTimeout(() => {
                    if (bot.pendingBets.has(requestId)) {
                        bot.pendingBets.delete(requestId);
                        reject(new Error('Timeout'));
                    }
                }, 500);
            });
        },

        placeBetRest(betData) {
            return betData.mode === 'dice' 
                ? API.placeDiceBet(betData.amount, betData.chance)
                : API.placeLimboBet(betData.amount, betData.multiplier);
        }
    };

    // =============== PARALLEL PROCESSING ENGINE ===============
    const ParallelEngine = {
        workerCount: 3,
        activeWorkers: 0,
        
        async start() {
            if (!bot.isRunning || bot.isPaused) return;
            
            const workers = [];
            for (let i = 0; i < this.workerCount; i++) {
                workers.push(this.runWorker(i));
            }
            
            await Promise.all(workers);
        },

        async runWorker(id) {
            while (bot.isRunning && !bot.isPaused) {
                try {
                    const betInfo = this.getNextBetOptimized();
                    if (!betInfo) {
                        await this.microSleep();
                        continue;
                    }

                    // Validate bet
                    if (betInfo.bet <= 0 || betInfo.bet > bot.stats.currentBal * 0.5) {
                        await this.microSleep();
                        continue;
                    }

                    const result = await this.executeBet(betInfo);
                    
                    if (result) {
                        this.updateStatsAtomic(result);
                        
                        if (betInfo.type === 'ZREC') {
                            this.processZRecResult(result);
                        }

                        // Update UI every 10 bets
                        if (bot.stats.bets % 10 === 0) {
                            this.updateUI();
                        }
                    }

                } catch (e) {
                    await this.microSleep();
                }
            }
            this.activeWorkers--;
        },

        getNextBetOptimized() {
            const currentBal = bot.stats.currentBal;
            const peakBalance = bot.stats.peakBalance;
            const z = bot.zRec;
            
            if (currentBal > peakBalance) {
                bot.stats.peakBalance = currentBal;
            }
            
            if (!z.active && this.checkZRecTriggerFast()) {
                this.activateZRecFast();
            }
            
            if (z.active) {
                return this.getZRecBetFast();
            }
            
            return this.getWagerBetFast();
        },

        getWagerBetFast() {
            const w = bot.wagerMode;
            w.currentCycle = (w.currentCycle + 1) % w.cyclesBetweenSwitch;
            if (w.currentCycle === 0) {
                w.mode = w.mode === 'dice' ? 'limbo' : 'dice';
            }
            
            let betAmount = bot.stats.currentBal * (w.betPercent * 0.01);
            betAmount = Math.max(betAmount, bot.globalMinBet);
            
            return {
                bet: betAmount,
                chance: w.mode === 'dice' ? w.diceChance : 99 / w.limboMultiplier,
                multiplier: w.limboMultiplier,
                mode: w.mode,
                type: 'WAGER'
            };
        },

        getZRecBetFast() {
            const z = bot.zRec;
            
            if (z.singleChanceBets >= z.singleChanceLimit) {
                z.currentChance = Math.min(98, z.baseChance + 
                    (Math.random() * (z.chance.incrementMax - z.chance.incrementMin) + z.chance.incrementMin));
            } else {
                z.currentChance = z.baseChance;
            }

            const needToRecover = Math.max(0, z.balanceStart - bot.stats.currentBal);
            const payout = 99 / z.currentChance;
            
            let nextBet = needToRecover > 0 
                ? (needToRecover / (payout - 1)) * 1.1
                : ((z.balancePeak - bot.stats.currentBal) / (payout - 1)) * 1.01;
            
            nextBet = Math.min(nextBet, bot.stats.currentBal * 0.1);
            nextBet = Math.max(nextBet, bot.globalMinBet);
            
            z.steps++;
            
            return { bet: nextBet, chance: z.currentChance, mode: 'dice', type: 'ZREC', multiplier: payout };
        },

        checkZRecTriggerFast() {
            const z = bot.zRec;
            if (z.active) return false;
            
            if (z.trigger.useDropdown) {
                const drawdownPercent = ((bot.stats.peakBalance - bot.stats.currentBal) / bot.stats.peakBalance) * 100;
                if (drawdownPercent >= z.trigger.dropdownPercent) {
                    z.balancePeak = bot.stats.peakBalance;
                    return true;
                }
            }
            
            if (z.trigger.useTime) {
                if (Date.now() - z.lastWinTime >= z.trigger.timeSeconds * 1000) {
                    z.balancePeak = Math.max(bot.stats.peakBalance, bot.stats.currentBal);
                    return true;
                }
            }
            
            return false;
        },

        activateZRecFast() {
            const z = bot.zRec;
            z.active = true;
            z.steps = 0;
            z.balanceStart = bot.stats.currentBal;
            z.balancePeak = Math.max(z.balancePeak, bot.stats.currentBal);
            z.trail.isActive = false;
            z.trail.currentLevel = 0;
            z.baseChance = Number((Math.random() * (z.chance.max - z.chance.min) + z.chance.min).toFixed(1));
            z.singleChanceLimit = Math.floor(99 / z.baseChance);
            z.singleChanceBets = 0;
            z.currentChance = z.baseChance;
            z.stats.totalRecoveries++;
            console.log(`‚ö° Z REC ACTIVATED - Target: ${z.balanceStart.toFixed(8)}`);
        },

        async executeBet(betInfo) {
            const nextBet = betInfo.bet;
            
            if (!bot.isDemo) {
                if (bot.realBalance < nextBet) {
                    return null;
                }
            }

            let win = false, pft = 0;
            
            if (bot.wsConnected && !bot.isDemo) {
                try {
                    const result = await WebSocketManager.placeBet(betInfo);
                    
                    if (betInfo.mode === 'dice') {
                        const diceData = result.diceRoll;
                        if (diceData) {
                            win = diceData.payout > 0;
                            pft = diceData.payout - diceData.amount;
                        }
                    } else {
                        const limboData = result.limboBet;
                        if (limboData) {
                            win = limboData.payout > 0;
                            pft = limboData.payout - limboData.amount;
                        }
                    }
                } catch (e) {
                    win = Math.random() * 100 < betInfo.chance;
                    pft = win ? (nextBet * (99 / betInfo.chance - 1)) : -nextBet;
                }
            } else {
                win = Math.random() * 100 < betInfo.chance;
                pft = win ? (nextBet * (99 / betInfo.chance - 1)) : -nextBet;
                await this.microSleep();
            }

            return { win, pft, nextBet, betInfo };
        },

        updateStatsAtomic(result) {
            const { win, pft, nextBet } = result;
            
            bot.stats.bets++;
            bot.stats.wagered += nextBet;
            bot.stats.profit += pft;
            
            if (!bot.wsConnected || bot.isDemo) {
                bot.stats.currentBal += pft;
            }
            
            if (win) {
                bot.stats.wins++;
                bot.stats.consecutiveWins++;
                bot.stats.consecutiveLosses = 0;
            } else {
                bot.stats.loss++;
                bot.stats.consecutiveLosses++;
                bot.stats.consecutiveWins = 0;
            }
            
            // Update win rate
            if (bot.stats.bets > 0) {
                bot.stats.winRate = (bot.stats.wins / bot.stats.bets * 100);
            }

            // Update max drawdown
            const drawdown = bot.stats.peakBalance - bot.stats.currentBal;
            if (drawdown > bot.stats.maxDrawdown) {
                bot.stats.maxDrawdown = drawdown;
                if (bot.stats.peakBalance > 0) {
                    bot.stats.maxDrawdownPercent = (drawdown / bot.stats.peakBalance) * 100;
                }
            }
        },

        processZRecResult(result) {
            const { win, pft, nextBet, betInfo } = result;
            const z = bot.zRec;
            
            if (!z.active) return;
            
            if (bot.stats.currentBal > z.balancePeak) {
                z.balancePeak = bot.stats.currentBal;
            }

            // Check if recovery complete
            if (bot.stats.currentBal >= z.balanceStart) {
                z.active = false;
                z.stats.successfulRecoveries++;
                z.stats.recoveredAmount += bot.stats.currentBal - z.balanceStart;
                console.log(`‚úÖ Z REC SUCCESS - Profit: ${(bot.stats.currentBal - z.balanceStart).toFixed(8)}`);
                this.startNewSessionFast();
                return;
            }

            // Trail logic
            if (z.trail.enabled && !z.trail.isActive) {
                const profitFromStart = ((bot.stats.currentBal - z.balanceStart) / z.balanceStart) * 100;
                if (profitFromStart >= z.trail.activationPercent) {
                    z.trail.isActive = true;
                    z.trail.currentLevel = 1;
                    z.level1Peak = z.balancePeak;
                    console.log(`üõ°Ô∏è TRAIL ACTIVATED at ${profitFromStart.toFixed(2)}%`);
                }
            }

            if (win) {
                z.baseChance = Number((Math.random() * (z.chance.max - z.chance.min) + z.chance.min).toFixed(1));
                z.singleChanceLimit = Math.floor(99 / z.baseChance);
                z.singleChanceBets = 0;
                z.currentChance = z.baseChance;
                z.lastWinTime = Date.now();
            } else {
                z.singleChanceBets++;
            }

            // Check max steps
            if (z.steps >= z.maxSteps) {
                z.active = false;
                z.stats.failedRecoveries++;
                console.log(`‚ö†Ô∏è Z REC MAX STEPS - Failed to recover`);
                this.startNewSessionFast();
            }
        },

        startNewSessionFast() {
            bot.zRec.active = false;
            bot.zRec.trail.isActive = false;
            bot.stats.sessionStartBal = bot.stats.currentBal;
            bot.stats.sessionStartTime = Date.now();
            bot.stats.consecutiveLosses = 0;
            bot.stats.betsSession = 0;
            bot.stats.winsSession = 0;
            bot.stats.lossSession = 0;
            bot.stats.wageredSession = 0;
        },

        microSleep() {
            return new Promise(resolve => setTimeout(resolve, 0));
        },

        updateUI() {
            const el = id => document.getElementById(id);
            if (el('balance-display')) el('balance-display').textContent = bot.stats.currentBal.toFixed(8);
            if (el('profit-display')) {
                const p = bot.stats.profit || 0;
                el('profit-display').textContent = (p > 0 ? '+' : '') + p.toFixed(4);
            }
            if (el('bets-display')) el('bets-display').textContent = bot.stats.bets || 0;
            if (el('winrate-display')) el('winrate-display').textContent = (bot.stats.winRate || 0).toFixed(1) + '%';
            if (el('ws-status')) {
                el('ws-status').style.background = bot.wsConnected ? '#065F46' : '#991B1B';
                el('ws-status').textContent = bot.wsConnected ? '‚úÖ WS' : '‚ùå WS';
            }
            if (el('workers-status')) el('workers-status').textContent = bot.isRunning ? `${this.workerCount}‚ö°` : '0‚ö°';
            if (el('zrec-status')) {
                el('zrec-status').textContent = bot.zRec.active ? '‚ö° ACTIVE' : 'INACTIVE';
                el('zrec-status').style.background = bot.zRec.active ? '#6B21A5' : '#1F2937';
            }
        }
    };

    // =============== ULTRA FAST API ===============
    const API = {
        async syncOnce() {
            try {
                bot.token = localStorage.getItem('apitoken') || 
                           localStorage.getItem('token') || 
                           sessionStorage.getItem('token') || 
                           document.cookie.match(/session=([^;]+)/)?.[1];
                
                if (!bot.token) {
                    bot.stakeUser = "Not logged in";
                    return;
                }

                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: { 
                        "Content-Type": "application/json", 
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{name balances{available{amount currency}}}}`
                    })
                });
                
                const json = await res.json();
                
                if (json?.data?.user) {
                    bot.stakeUser = json.data.user.name;
                    bot.availableCurrencies = (json.data.user.balances || []).map(b => ({
                        code: b.available.currency.toLowerCase(),
                        name: b.available.currency.toUpperCase(),
                        balance: parseFloat(b.available.amount) || 0
                    }));
                    
                    const selected = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
                    if (selected) bot.realBalance = selected.balance;
                    
                    WebSocketManager.connect();
                }
            } catch (e) {
                bot.stakeUser = "Error";
            }
        },

        async placeDiceBet(amount, chance) {
            const res = await fetch(`${CONFIG.apiUrl}/casino/dice/roll`, {
                method: "POST",
                headers: { 
                    "Content-Type": "application/json", 
                    "Authorization": `Bearer ${bot.token}`,
                    "x-access-token": bot.token
                },
                body: JSON.stringify({
                    amount: parseFloat(amount.toFixed(8)),
                    currency: bot.selectedCurrency,
                    target: parseFloat((100 - chance).toFixed(2)),
                    condition: "above"
                })
            });
            return res.json();
        },

        async placeLimboBet(amount, multiplierTarget) {
            const res = await fetch(`${CONFIG.apiUrl}/casino/limbo/bet`, {
                method: "POST",
                headers: { 
                    "Content-Type": "application/json", 
                    "Authorization": `Bearer ${bot.token}`,
                    "x-access-token": bot.token
                },
                body: JSON.stringify({
                    multiplierTarget: multiplierTarget,
                    amount: parseFloat(amount.toFixed(8)),
                    currency: bot.selectedCurrency
                })
            });
            return res.json();
        }
    };

    // =============== TELEGRAM (Non-blocking) ===============
    const TelegramAPI = {
        async sendMessage(text) {
            if (!CONFIG.telegram?.enabled) return;
            fetch(`https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    chat_id: CONFIG.telegram.chatId,
                    text: text,
                    parse_mode: "HTML",
                    disable_web_page_preview: true
                })
            }).catch(() => {});
        },

        async sendStartReport() {
            if (!CONFIG.telegram.sendOnStart) return;
            const message = `üöÄ <b>ORION TURBO STARTED</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Balance: <code>${bot.stats.startBal.toFixed(8)}</code>\n` +
                `‚ö° Workers: <code>${bot.workers}</code>\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendStopReport(reason) {
            if (!CONFIG.telegram.sendOnStop) return;
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const message = `üõë <b>ORION STOPPED</b>\n` +
                `üìù Reason: <b>${reason}</b>\n` +
                `‚è±Ô∏è Runtime: <code>${Math.floor(runtime/60)}m</code>\n` +
                `üéØ Bets: <code>${bot.stats.bets}</code>\n` +
                `üìà Profit: <code>${bot.stats.profit.toFixed(8)}</code>`;
            await this.sendMessage(message);
        },

        async sendPeriodicReport() {
            if (!CONFIG.telegram.enabled) return;
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const profitPercent = bot.stats.startBal > 0 ? ((bot.stats.profit / bot.stats.startBal) * 100) : 0;
            
            const message = `üìä <b>PERIODIC REPORT</b>\n` +
                `‚è±Ô∏è Runtime: <code>${Math.floor(runtime/60)}m</code>\n` +
                `üí∞ Balance: <code>${bot.stats.currentBal.toFixed(8)}</code>\n` +
                `üìà Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} (${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%)</code>\n` +
                `üéØ Bets: <code>${bot.stats.bets}</code>\n` +
                `üìà Win Rate: <code>${bot.stats.winRate.toFixed(2)}%</code>`;
            
            await this.sendMessage(message);
        }
    };

    // =============== UI ===============
    function createUI() {
        if (document.getElementById("orion-turbo")) return;

        const style = document.createElement("style");
        style.innerHTML = `
            #orion-turbo {
                position: fixed; top: 50%; right: 20px; transform: translateY(-50%);
                width: 400px; max-height: 90vh;
                background: linear-gradient(145deg, #0A0A0F, #1A0B2E);
                border: 2px solid #A855F7; border-radius: 24px;
                color: #fff; font-family: system-ui, sans-serif; font-size: 13px;
                z-index: 999999; box-shadow: 0 20px 40px rgba(168,85,247,0.3);
                backdrop-filter: blur(10px);
                overflow: hidden;
            }
            .turbo-header { 
                padding: 20px; 
                background: linear-gradient(90deg, #2E1065, #4C1D95);
                border-bottom: 2px solid #A855F7;
            }
            .turbo-title { 
                font-size: 24px; 
                font-weight: 800; 
                background: linear-gradient(135deg, #E9D5FF, #F0E9FF);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 10px;
            }
            .turbo-subtitle {
                display: flex; gap: 10px; font-size: 11px;
            }
            .turbo-content { 
                padding: 20px; 
                overflow-y: auto; 
                max-height: calc(90vh - 120px);
            }
            .stat-row { 
                display: flex; 
                justify-content: space-between; 
                margin: 10px 0; 
                padding: 12px; 
                background: rgba(30, 16, 53, 0.8);
                border-radius: 16px;
                border: 1px solid #6B21A5;
            }
            .stat-label { color: #C4B5FD; font-weight: 500; }
            .stat-value { color: #F0E9FF; font-weight: 700; }
            .stat-value.positive { color: #6EE7B7; }
            .stat-value.negative { color: #FCA5A5; }
            .btn { 
                padding: 14px; 
                border: none; 
                border-radius: 16px; 
                font-weight: 700; 
                cursor: pointer;
                font-size: 14px;
                transition: all 0.2s;
            }
            .btn-start { 
                background: linear-gradient(135deg, #6B21A5, #A855F7);
                color: white; 
                width: 100%;
                box-shadow: 0 10px 20px #581C87;
            }
            .btn-stop { 
                background: linear-gradient(135deg, #7F1D1D, #991B1B);
                color: white; 
                width: 100%;
                margin-top: 10px;
            }
            .btn-secondary {
                background: #2D1B4A;
                color: #D8B4FE;
                border: 1px solid #A855F7;
                margin-top: 10px;
            }
            .badge {
                display: inline-block;
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 11px;
                font-weight: 600;
                background: rgba(168, 85, 247, 0.2);
                color: #D8B4FE;
                border: 1px solid #A855F7;
            }
            .ws-badge {
                display: inline-block;
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 11px;
                font-weight: 600;
            }
            .select-input {
                width: 100%;
                padding: 12px;
                background: #1E1035;
                color: #F0E9FF;
                border: 1px solid #6B21A5;
                border-radius: 12px;
                margin: 10px 0;
                font-size: 13px;
            }
            .number-input {
                width: 80px;
                padding: 8px;
                background: #1E1035;
                color: #F0E9FF;
                border: 1px solid #6B21A5;
                border-radius: 8px;
                text-align: center;
            }
            .grid-2 {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin: 10px 0;
            }
        `;
        document.head.appendChild(style);

        const html = `
            <div id="orion-turbo">
                <div class="turbo-header">
                    <div class="turbo-title">‚ö° ORION TURBO</div>
                    <div class="turbo-subtitle">
                        <span class="badge" id="zrec-status">INACTIVE</span>
                        <span class="ws-badge" id="ws-status" style="background:#065F46;">‚úÖ WS</span>
                        <span class="ws-badge" id="workers-status" style="background:#6B21A5;">3‚ö°</span>
                    </div>
                </div>
                <div class="turbo-content">
                    <!-- Mode Selector -->
                    <div class="grid-2">
                        <button id="mode-real" class="btn btn-secondary" style="background:#6B21A5;">üéØ REAL</button>
                        <button id="mode-demo" class="btn btn-secondary">üß™ DEMO</button>
                    </div>

                    <!-- Main Stats -->
                    <div class="stat-row">
                        <span class="stat-label">Balance</span>
                        <span class="stat-value" id="balance-display">0.00000000</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Profit</span>
                        <span class="stat-value" id="profit-display">0.0000</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Bets</span>
                        <span class="stat-value" id="bets-display">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Win Rate</span>
                        <span class="stat-value" id="winrate-display">0%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Wins/Losses</span>
                        <span class="stat-value" id="wl-display">0/0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Peak/Drop</span>
                        <span class="stat-value" id="peak-display">0.00/0%</span>
                    </div>

                    <!-- Currency & Settings -->
                    <select id="currency-select" class="select-input">
                        <option value="doge">üêï DOGE</option>
                        <option value="btc">‚Çø BTC</option>
                        <option value="eth">Œû ETH</option>
                    </select>

                    <div class="grid-2">
                        <input type="number" id="betpercent" class="number-input" value="0.5" step="0.1" placeholder="Bet %">
                        <input type="number" id="minbet" class="number-input" value="0.000123" step="0.000001" placeholder="Min Bet">
                    </div>

                    <!-- Wager Mode Settings -->
                    <div style="margin: 15px 0;">
                        <div style="color:#C4B5FD; margin-bottom:8px;">üé≤ WAGER MODE</div>
                        <div class="grid-2">
                            <select id="wager-mode" class="select-input" style="padding:8px;">
                                <option value="dice">Dice</option>
                                <option value="limbo">Limbo</option>
                            </select>
                            <input type="number" id="wager-chance" class="number-input" value="99.5" step="0.1" placeholder="Chance">
                        </div>
                        <div class="grid-2" style="margin-top:8px;">
                            <input type="number" id="wager-multiplier" class="number-input" value="1.0001" step="0.0001" placeholder="Multiplier">
                            <input type="number" id="wager-cycles" class="number-input" value="10" step="1" placeholder="Cycles">
                        </div>
                    </div>

                    <!-- Z Recovery Settings -->
                    <div style="margin: 15px 0; padding:15px; background:#2E1065; border-radius:16px;">
                        <div style="color:#E9D5FF; margin-bottom:8px;">‚ö° Z RECOVERY</div>
                        <div class="grid-2">
                            <input type="number" id="zrec-drop" class="number-input" value="0.5" step="0.1" placeholder="Drop %">
                            <input type="number" id="zrec-time" class="number-input" value="60" step="5" placeholder="Time sec">
                        </div>
                        <div class="grid-2" style="margin-top:8px;">
                            <input type="number" id="zrec-chance-min" class="number-input" value="10" step="1" placeholder="Min Chance">
                            <input type="number" id="zrec-chance-max" class="number-input" value="25" step="1" placeholder="Max Chance">
                        </div>
                    </div>

                    <!-- Control Buttons -->
                    <button id="start-btn" class="btn btn-start">‚ñ∂ START TURBO</button>
                    <button id="stop-btn" class="btn btn-stop">‚èπ STOP</button>
                    <div class="grid-2">
                        <button id="manual-zrec" class="btn btn-secondary">‚ö° MANUAL Z</button>
                        <button id="new-session" class="btn btn-secondary">üîÑ NEW SESSION</button>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', html);
        
        setupEventListeners();
        ParallelEngine.updateUI();
        
        // Auto sync
        API.syncOnce();
        setInterval(() => API.syncOnce(), 30000);
    }

    function setupEventListeners() {
        // Mode switches
        document.getElementById('mode-real').onclick = () => {
            bot.isDemo = false;
            document.getElementById('mode-real').style.background = '#6B21A5';
            document.getElementById('mode-demo').style.background = '#2D1B4A';
        };
        
        document.getElementById('mode-demo').onclick = () => {
            bot.isDemo = true;
            bot.demoBalance = parseFloat(prompt("Demo Balance:", "1000")) || 1000;
            document.getElementById('mode-demo').style.background = '#6B21A5';
            document.getElementById('mode-real').style.background = '#2D1B4A';
        };

        // Currency
        document.getElementById('currency-select').onchange = (e) => {
            bot.selectedCurrency = e.target.value;
        };

        // Settings
        document.getElementById('betpercent').onchange = (e) => {
            bot.wagerMode.betPercent = parseFloat(e.target.value) || 0.5;
        };

        document.getElementById('minbet').onchange = (e) => {
            bot.globalMinBet = parseFloat(e.target.value) || 0.000123;
        };

        document.getElementById('wager-mode').onchange = (e) => {
            bot.wagerMode.mode = e.target.value;
        };

        document.getElementById('wager-chance').onchange = (e) => {
            bot.wagerMode.diceChance = parseFloat(e.target.value) || 99.5;
        };

        document.getElementById('wager-multiplier').onchange = (e) => {
            bot.wagerMode.limboMultiplier = parseFloat(e.target.value) || 1.0001;
        };

        document.getElementById('wager-cycles').onchange = (e) => {
            bot.wagerMode.cyclesBetweenSwitch = parseInt(e.target.value) || 10;
        };

        document.getElementById('zrec-drop').onchange = (e) => {
            bot.zRec.trigger.dropdownPercent = parseFloat(e.target.value) || 0.5;
        };

        document.getElementById('zrec-time').onchange = (e) => {
            bot.zRec.trigger.timeSeconds = parseInt(e.target.value) || 60;
        };

        document.getElementById('zrec-chance-min').onchange = (e) => {
            bot.zRec.chance.min = parseFloat(e.target.value) || 10;
        };

        document.getElementById('zrec-chance-max').onchange = (e) => {
            bot.zRec.chance.max = parseFloat(e.target.value) || 25;
        };

        // Start button
        document.getElementById('start-btn').onclick = async () => {
            if (bot.isRunning) return;

            // Get initial balance
            if (bot.isDemo) {
                bot.stats.currentBal = bot.demoBalance;
                bot.stats.startBal = bot.demoBalance;
                bot.stats.peakBalance = bot.demoBalance;
            } else {
                await API.syncOnce();
                if (bot.realBalance <= 0) {
                    alert(`Insufficient ${bot.selectedCurrency.toUpperCase()} balance!`);
                    return;
                }
                bot.stats.currentBal = bot.realBalance;
                bot.stats.startBal = bot.realBalance;
                bot.stats.peakBalance = bot.realBalance;
            }

            // Reset stats
            bot.stats.bets = 0;
            bot.stats.wins = 0;
            bot.stats.loss = 0;
            bot.stats.profit = 0;
            bot.stats.wagered = 0;
            bot.stats.maxDrawdown = 0;
            bot.stats.maxDrawdownPercent = 0;
            bot.stats.startTime = Date.now();
            bot.lastTelegramReport = Date.now();

            bot.isRunning = true;
            
            // Start parallel engine
            ParallelEngine.start();
            
            // Send telegram start report
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStart) {
                TelegramAPI.sendStartReport();
            }
            
            // Update UI
            ParallelEngine.updateUI();
        };

        // Stop button
        document.getElementById('stop-btn').onclick = () => {
            bot.isRunning = false;
            ParallelEngine.updateUI();
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStop) {
                TelegramAPI.sendStopReport("Manual Stop");
            }
        };

        // Manual Z Rec
        document.getElementById('manual-zrec').onclick = () => {
            if (!bot.isRunning) {
                alert('Start bot dulu!');
                return;
            }
            if (bot.zRec.active) {
                alert('Z Rec sudah aktif!');
                return;
            }
            bot.zRec.balancePeak = Math.max(bot.stats.peakBalance, bot.stats.currentBal);
            ParallelEngine.activateZRecFast();
        };

        // New session
        document.getElementById('new-session').onclick = () => {
            if (bot.isRunning) {
                ParallelEngine.startNewSessionFast();
            }
        };
    }

    // =============== INIT ===============
    setTimeout(() => {
        createUI();
        
        // Periodic updates
        setInterval(() => {
            if (bot.isRunning) {
                ParallelEngine.updateUI();
                
                // Telegram periodic report
                if (Date.now() - bot.lastTelegramReport > bot.telegramReportInterval) {
                    TelegramAPI.sendPeriodicReport();
                    bot.lastTelegramReport = Date.now();
                }
            }
        }, 100);
        
        // Auto reconnect WebSocket
        setInterval(() => {
            if (!bot.wsConnected && bot.token) {
                WebSocketManager.connect();
            }
        }, 5000);
        
    }, 500);
})();
