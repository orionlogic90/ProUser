(async function () {
    // ==================== CONFIGURATION ====================
    const CONFIG = {
        apiUrl: window.location.origin + '/_api',
        tgToken: '8391763291:AAEA05v6FG70eM1WGrgU7mrPgckfjQaxkno',
        tgChatId: '-1003744641395',
        supportContact: '@OrionLogic',
        wsUrl: 'wss://ws.stake.com'
    };

    const WHITELIST = {
        "orionlogic": { tier: "VIP", expiry: "2099-12-31" },
        "biele": { tier: "PREMIUM", expiry: "2026-02-26" },
        "siska82": { tier: "PREMIUM", expiry: "2026-02-26" },
        "dfransiska": { tier: "PREMIUM", expiry: "2026-02-26" },
        "brokenpips": { tier: "PREMIUM", expiry: "2026-02-26" },
        "aynus": { tier: "PREMIUM", expiry: "2026-02-26" },
        "terbaik444": { tier: "PREMIUM", expiry: "2026-01-30" },
        "k4pitiang": { tier: "PREMIUM", expiry: "2026-02-26" }
    };

    // ==================== LICENSE VALIDATION ====================
    let currentUser = null;
    let licenseData = null;
    let websocket = null;
    let isWsConnected = false;

    async function validateLicense() {
        try {
            const token = localStorage.getItem('apitoken') || 
                         (document.cookie.match(/session=([^;]+)/) ? 
                          document.cookie.match(/session=([^;]+)/)[1] : null);

            if (!token) {
                showLicenseModal("Please login to Stake.com first");
                return false;
            }

            const response = await fetch(`${CONFIG.apiUrl}/graphql`, {
                method: "POST",
                headers: { 
                    "Content-Type": "application/json",
                    "x-access-token": token 
                },
                body: JSON.stringify({ query: `query{user{name}}` })
            });

            const data = await response.json();
            const username = data?.data?.user?.name?.toLowerCase();

            if (!username) {
                showLicenseModal("Cannot retrieve username");
                return false;
            }

            currentUser = username;
            licenseData = WHITELIST[username];
            
            if (!licenseData) {
                showLicenseModal(`Username <strong>${username}</strong> is not whitelisted.`, true);
                return false;
            }

            const expiryDate = new Date(licenseData.expiry);
            if (new Date() > expiryDate) {
                showLicenseModal(`License expired on ${expiryDate.toLocaleDateString()}.`, true);
                return false;
            }

            console.log(`✅ License validated: ${username} (${licenseData.tier})`);
            return true;

        } catch (error) {
            console.error("License validation error:", error);
            showLicenseModal("Connection error. Please refresh.");
            return false;
        }
    }

    // ==================== BOT ENGINE ====================
    const bot = {
        isRunning: false, 
        isPaused: false, 
        mode: "BASE", 
        token: null, 
        stakeUser: "Loading...", 
        startTime: null, 
        stats: { 
            profit: 0, 
            wagered: 0, 
            startBal: 0, 
            currentBal: 0, 
            bets: 0, 
            wins: 0, 
            loss: 0,
            maxDD: 0,
            maxProfit: 0,
            maxBet: 0,
            minBalance: 0,
            maxBalance: 0,
            currentStreak: 0,
            maxWinStreak: 0,
            maxLossStreak: 0,
            totalPayout: 0
        },
        selectedCurrency: localStorage.getItem('orion_last_coin') || "usdt", 
        nextBet: 0, 
        currentChance: 0,
        currentPayout: 0,
        labouchereList: [],
        gameMode: "DICE",
        lastSwitchBet: 0,
        activeModes: {
            base: true,
            wager: true,
            autoswitch: true,
            useWebSocket: false
        },
        sessionHigh: 0,
        sessionLow: 0,
        partialProfit: 0,
        lastReportTime: 0,
        lastWsUpdate: 0,
        consecutiveLosses: 0
    };

    // ==================== API FUNCTIONS ====================
    const API = {
        async syncOnce() {
            bot.token = localStorage.getItem('apitoken') || (document.cookie.match(/session=([^;]+)/) ? document.cookie.match(/session=([^;]+)/)[1] : null);
            try {
                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST", 
                    headers: { 
                        "Content-Type": "application/json", 
                        "x-access-token": bot.token 
                    },
                    body: JSON.stringify({ 
                        query: `query{user{name balances{available{amount currency}}}}` 
                    })
                });
                const json = await res.json();
                if (json?.data?.user) {
                    bot.stakeUser = json.data.user.name;
                    const bals = json.data.user.balances || [];
                    const sel = document.getElementById("p-currency");
                    
                    const currentSelected = sel.value || bot.selectedCurrency;
                    sel.innerHTML = ""; 

                    bals.forEach(b => {
                        const opt = new Option(
                            `${b.available.currency.toUpperCase()} (${parseFloat(b.available.amount).toFixed(2)})`, 
                            b.available.currency
                        );
                        if(b.available.currency === currentSelected) opt.selected = true;
                        sel.add(opt);
                    });
                    bot.selectedCurrency = sel.value;
                    
                    await updateBalanceDisplay();
                }
            } catch (e) { 
                console.error("Sync Error:", e); 
            }
        },

        async getBalance(coin) {
            try {
                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST", 
                    headers: { 
                        "Content-Type": "application/json", 
                        "x-access-token": bot.token 
                    },
                    body: JSON.stringify({ 
                        query: `query{user{balances{available{amount currency}}}}` 
                    })
                });
                const json = await res.json();
                const active = json.data.user.balances.find(
                    b => b.available.currency.toLowerCase() === coin.toLowerCase()
                );
                return active ? parseFloat(active.available.amount) : 0;
            } catch (e) { 
                return 0; 
            }
        },

        async placeDiceBet(amount, chance) {
            const payload = { 
                amount: parseFloat(amount.toFixed(8)), 
                currency: bot.selectedCurrency, 
                target: (100 - chance).toFixed(1), 
                condition: "above", 
                identifier: Math.random().toString(36).slice(2) 
            };
            
            console.log("Dice Bet:", payload);
            
            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/dice/roll`, { 
                    method: "POST", 
                    headers: { 
                        "Content-Type": "application/json", 
                        "x-access-token": bot.token 
                    }, 
                    body: JSON.stringify(payload) 
                });
                return await r.json();
            } catch (error) {
                throw error;
            }
        },

        async placeLimboBet(amount, targetMultiplier) {
            const payload = { 
                amount: parseFloat(amount.toFixed(8)), 
                currency: bot.selectedCurrency, 
                multiplierTarget: parseFloat(targetMultiplier.toFixed(2)),
                identifier: Math.random().toString(36).slice(2) 
            };
            
            console.log("Limbo Bet:", payload);
            
            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/limbo/bet`, { 
                    method: "POST", 
                    headers: { 
                        "Content-Type": "application/json", 
                        "x-access-token": bot.token 
                    }, 
                    body: JSON.stringify(payload) 
                });
                return await r.json();
            } catch (error) {
                throw error;
            }
        }
    };

    // ==================== TELEGRAM REPORT ====================
    async function sendTelegramReport(reason = "SESSION_END") {
        try {
            const winRate = bot.stats.bets > 0 ? ((bot.stats.wins / bot.stats.bets) * 100).toFixed(2) : "0.00";
            const profitPct = bot.stats.startBal > 0 ? ((bot.stats.profit / bot.stats.startBal) * 100).toFixed(2) : "0.00";
            
            const reportMessage = `ORION BOT REPORT\n\n` +
                                `User: ${bot.stakeUser}\n` +
                                `Session: ${getElapsedTime()}\n` +
                                `Profit: ${bot.stats.profit.toFixed(8)} (${profitPct}%)\n` +
                                `Bets: ${bot.stats.bets} (${bot.stats.wins}W/${bot.stats.loss}L)\n` +
                                `Win Rate: ${winRate}%\n` +
                                `Current Streak: ${bot.stats.currentStreak}\n` +
                                `Consecutive Losses: ${bot.consecutiveLosses}\n` +
                                `Max Drawdown: ${bot.stats.maxDD.toFixed(8)}\n` +
                                `Mode: ${bot.mode}\n` +
                                `Game: ${bot.gameMode}\n` +
                                `Reason: ${reason}`;
            
            const formattedReport = `\`\`\`\n${reportMessage}\n\`\`\``;
            
            await fetch(`https://api.telegram.org/bot${CONFIG.tgToken}/sendMessage`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    chat_id: CONFIG.tgChatId,
                    text: formattedReport,
                    parse_mode: "MarkdownV2"
                })
            });
            
            console.log("Telegram report sent");
        } catch (error) {
            console.error("Telegram report error:", error);
        }
    }

    // ==================== BOT LOGIC ====================
    function initLabouchere(baseBet, chance) {
        const sequenceLength = Math.floor(Math.random() * 5) + 3;
        bot.labouchereList = [];
        for (let i = 0; i < sequenceLength; i++) {
            bot.labouchereList.push(baseBet * (i + 1));
        }
        console.log("Labouchere initialized:", bot.labouchereList);
    }

    function getNextLabouchereBet() {
        if (bot.labouchereList.length === 0) {
            return getVal("p-basebet");
        }
        if (bot.labouchereList.length === 1) {
            return bot.labouchereList[0];
        }
        return bot.labouchereList[0] + bot.labouchereList[bot.labouchereList.length - 1];
    }

    function updateLabouchere(win) {
        if (bot.labouchereList.length === 0) return;
        
        if (win) {
            bot.labouchereList.pop();
            if (bot.labouchereList.length > 0) {
                bot.labouchereList.shift();
            }
        } else {
            const newBet = getNextLabouchereBet();
            bot.labouchereList.push(newBet);
        }
        
        console.log("Labouchere updated:", bot.labouchereList);
        
        if (bot.labouchereList.length === 0) {
            initLabouchere(getVal("p-lab-basebet"), getVal("p-lab-chance"));
        }
    }

    function switchGameMode() {
        if (!bot.activeModes.autoswitch || bot.stats.bets < 10) return false;
        
        if (bot.stats.bets - bot.lastSwitchBet > Math.floor(Math.random() * 25) + 15) {
            bot.gameMode = bot.gameMode === "DICE" ? "LIMBO" : "DICE";
            bot.lastSwitchBet = bot.stats.bets;
            updateStatus(`Switched to ${bot.gameMode}`, "#a855f7");
            
            if (bot.gameMode === "LIMBO") {
                bot.currentPayout = 2.0;
            } else {
                bot.currentChance = 85.0;
            }
            
            return true;
        }
        return false;
    }

    function updateStatistics(win, amount, payout) {
        // Update consecutive losses
        if (win) {
            bot.consecutiveLosses = 0;
            bot.stats.currentStreak = Math.max(0, bot.stats.currentStreak) + 1;
            bot.stats.maxWinStreak = Math.max(bot.stats.maxWinStreak, bot.stats.currentStreak);
        } else {
            bot.consecutiveLosses++;
            bot.stats.currentStreak = Math.min(0, bot.stats.currentStreak) - 1;
            bot.stats.maxLossStreak = Math.max(Math.abs(bot.stats.maxLossStreak), Math.abs(bot.stats.currentStreak));
        }

        bot.stats.maxBet = Math.max(bot.stats.maxBet, amount);
        bot.stats.maxProfit = Math.max(bot.stats.maxProfit, bot.stats.profit);
        bot.stats.maxBalance = Math.max(bot.stats.maxBalance, bot.stats.currentBal);
        bot.stats.minBalance = bot.stats.minBalance === 0 ? bot.stats.currentBal : Math.min(bot.stats.minBalance, bot.stats.currentBal);

        const currentDD = bot.stats.startBal - bot.stats.currentBal;
        bot.stats.maxDD = Math.max(bot.stats.maxDD, currentDD);

        bot.sessionHigh = Math.max(bot.sessionHigh, bot.stats.currentBal);
        bot.sessionLow = bot.sessionLow === 0 ? bot.stats.currentBal : Math.min(bot.sessionLow, bot.stats.currentBal);
    }

    function getVal(id) { 
        try {
            const el = document.getElementById(id);
            if (!el) {
                const defaults = {
                    "p-basebet": 0.00000100,
                    "p-bch-min": 80.0,
                    "p-bch-max": 95.0,
                    "p-hch-min": 20.0,
                    "p-hch-max": 30.0,
                    "p-wgr-chance": 99.0,
                    "p-wgr-div": 100,
                    "p-minbet": 0.00000001,
                    "p-target-pct": 5.0,
                    "p-wagertarget": 200,
                    "p-lab-basebet": 0.00000100,
                    "p-lab-chance": 50.0,
                    "p-limbo-min-payout": 1.1,
                    "p-limbo-max-payout": 3.0
                };
                return defaults[id] || 0;
            }
            return parseFloat(el.value) || 0;
        } catch (e) {
            return 0;
        }
    }

    async function updateBalanceDisplay() {
        const balance = await API.getBalance(bot.selectedCurrency);
        bot.stats.currentBal = balance;
        if (bot.stats.startBal === 0) {
            bot.stats.startBal = balance;
            bot.sessionHigh = balance;
            bot.sessionLow = balance;
        }
    }

    // ==================== OPTIMIZED BET LOOP ====================
    async function runLoop() {
        if (!bot.isRunning || bot.isPaused) return;
        
        // Auto report every 100 bets
        if (bot.stats.bets % 100 === 0 && Date.now() - bot.lastReportTime > 60000) {
            await sendTelegramReport("AUTO_REPORT");
            bot.lastReportTime = Date.now();
        }

        // Target profit check
        const targetAbs = bot.stats.startBal * (getVal("p-target-pct") / 100);
        if (targetAbs > 0 && bot.stats.profit >= targetAbs) { 
            await stopEngine(); 
            updateStatus("TARGET REACHED", "#10b981");
            await sendTelegramReport("TARGET_REACHED");
            return; 
        }

        try {
            // Place bet
            const res = bot.gameMode === "DICE" 
                ? await API.placeDiceBet(bot.nextBet, bot.currentChance)
                : await API.placeLimboBet(bot.nextBet, bot.currentPayout);
            
            const betData = res?.data || res;
            
            if (!betData) throw new Error("Invalid bet response");
            
            // Process result
            let win, payout, profit, amount;
            
            if (bot.gameMode === "DICE") {
                amount = betData.amount || betData.betAmount || betData.wager || bot.nextBet;
                win = betData.payoutMultiplier > 0 || betData.win === true || (betData.payout && betData.payout > 0);
                
                if (betData.payout !== undefined && betData.payout > 0) {
                    payout = betData.payout;
                } else if (betData.payoutMultiplier && betData.payoutMultiplier > 0) {
                    payout = amount * betData.payoutMultiplier;
                } else if (win) {
                    payout = amount * (100 / bot.currentChance);
                } else {
                    payout = 0;
                }
            } else {
                amount = betData.amount || betData.betAmount || betData.wager || bot.nextBet;
                const result = betData.state?.result || betData.result || 0;
                const target = betData.state?.multiplierTarget || betData.multiplierTarget || bot.currentPayout;
                win = result >= target;
                
                if (betData.payout !== undefined && betData.payout > 0) {
                    payout = betData.payout;
                } else if (win) {
                    payout = amount * target;
                } else {
                    payout = 0;
                }
            }
            
            profit = payout - amount;
            
            // Update stats
            bot.stats.bets++; 
            bot.stats.wagered += amount;
            bot.stats.profit += profit; 
            bot.stats.currentBal += profit;
            bot.partialProfit += profit;
            
            win ? bot.stats.wins++ : bot.stats.loss++;
            
            // Update statistics
            updateStatistics(win, amount, payout);
            
            // Update stats display immediately
            updateStatsDisplay();
            
            // Log bet
            updateLogs(amount, bot.gameMode === "DICE" ? bot.currentChance : bot.currentPayout, bot.mode, profit, bot.gameMode);
            
            // Mode switching logic
            if (bot.activeModes.base && bot.activeModes.wager && bot.stats.bets % 100 === 0) {
                bot.mode = bot.mode === "BASE" ? "WAGER" : "BASE";
                updateStatus(`Mode: ${bot.mode}`, "#a855f7");
                bot.partialProfit = 0;
            }
            
            // Bet calculation - FIXED MARTINGALE LOGIC
            console.log("Before calculation:", {
                win,
                mode: bot.mode,
                partialProfit: bot.partialProfit,
                nextBet: bot.nextBet,
                amount
            });
            
            if (win) {
                console.log("WIN - Resetting");
                if (bot.mode === "WAGER") {
                    bot.nextBet = bot.stats.currentBal / getVal("p-wgr-div");
                    if (bot.gameMode === "DICE") {
                        bot.currentChance = getVal("p-wgr-chance");
                    } else {
                        bot.currentPayout = 1.5;
                    }
                } else {
                    bot.nextBet = getVal("p-basebet");
                    if (bot.gameMode === "DICE") {
                        bot.currentChance = Math.random() * (getVal("p-bch-max") - getVal("p-bch-min")) + getVal("p-bch-min");
                    } else {
                        bot.currentPayout = Math.random() * (getVal("p-limbo-max-payout") - 1.1) + 1.1;
                    }
                    if (bot.labouchereList.length > 0) {
                        updateLabouchere(true);
                        bot.nextBet = getNextLabouchereBet();
                    }
                }
                bot.partialProfit = 0;
                bot.consecutiveLosses = 0;
            } else {
                console.log("LOSS - Calculating recovery bet");
                if (bot.mode === "WAGER") {
                    bot.nextBet = amount * 1.12;
                    console.log("Wager mode loss bet:", bot.nextBet);
                } else {
                    // FIXED: Pakai Math.abs() untuk partialProfit yang negatif
                    const lossAmount = Math.abs(bot.partialProfit);
                    console.log("Loss amount:", lossAmount);
                    
                    if (bot.gameMode === "DICE") {
                        bot.currentChance = Math.random() * (getVal("p-hch-max") - getVal("p-hch-min")) + getVal("p-hch-min");
                        // FIXED: Martingale formula untuk dice
                        const multiplier = (100 / bot.currentChance) - 1;
                        console.log("Dice multiplier:", multiplier);
                        bot.nextBet = (lossAmount / multiplier) * 1.5;
                        console.log("Dice recovery bet:", bot.nextBet);
                    } else {
                        // FIXED: Martingale untuk limbo
                        bot.currentPayout = Math.max(1.1, bot.currentPayout * 0.95);
                        const multiplier = bot.currentPayout - 1;
                        console.log("Limbo multiplier:", multiplier);
                        bot.nextBet = (lossAmount / multiplier) * 1.5;
                        console.log("Limbo recovery bet:", bot.nextBet);
                    }
                    
                    if (bot.labouchereList.length > 0) {
                        updateLabouchere(false);
                        bot.nextBet = getNextLabouchereBet();
                        console.log("Labouchere bet:", bot.nextBet);
                    }
                }
            }
            
            // Apply min bet
            bot.nextBet = Math.max(bot.nextBet, getVal("p-minbet"));
            
            console.log("Final next bet:", bot.nextBet);
            
            // Auto switch game mode
            switchGameMode();
            
            // Next bet with minimal delay
            setTimeout(runLoop, 50);
            
        } catch (e) { 
            console.error("Bet error:", e);
            updateStatus(`Error: ${e.message}`, "#ef4444");
            setTimeout(runLoop, 1000); 
        }
    }

    async function stopEngine() { 
        bot.isRunning = false; 
        await sendTelegramReport("MANUAL_STOP");
        await updateBalanceDisplay();
    }

    function updateStatus(text, color = "#0ff") {
        const el = document.getElementById("st-status-text");
        if (el) { 
            el.innerText = text; 
            el.style.color = color; 
        }
    }

    function updateLogs(amt, value, mode, pft, game) {
        const logBox = document.getElementById("p-log-body");
        if (!logBox) return;
        
        const row = document.createElement("div");
        row.style.cssText = `display:grid; grid-template-columns:1fr 1fr 0.8fr 1fr 0.8fr; font-size:9px; border-bottom:1px solid rgba(0,255,255,0.05); padding:2px 0; color:${pft >= 0 ? '#00ffcc' : '#ff3366'}; text-align:center;`;
        
        const valueDisplay = game === "DICE" ? `${value.toFixed(1)}%` : `${value.toFixed(2)}x`;
        const modeColors = { 'WAGER': '#60a5fa', 'BASE': '#fbbf24' };
        const gameText = game === "DICE" ? "DICE" : "LIMBO";
        
        const displayAmount = amt.toFixed(8);
        
        row.innerHTML = `
            <span title="${amt}">${displayAmount}</span>
            <span>${valueDisplay}</span>
            <span style="color:${modeColors[mode] || '#94a3b8'}">${mode}</span>
            <span>${pft.toFixed(8)}</span>
            <span>${gameText}</span>
        `;
        logBox.prepend(row);
        if (logBox.children.length > 10) logBox.lastChild.remove();
    }

    function getElapsedTime() {
        if (!bot.startTime) return "00:00:00";
        const d = Math.floor((Date.now() - bot.startTime) / 1000);
        return `${Math.floor(d/3600).toString().padStart(2,'0')}:${Math.floor((d%3600)/60).toString().padStart(2,'0')}:${(d%60).toString().padStart(2,'0')}`;
    }

    // ==================== PROFESSIONAL TEXT-ONLY UI ====================
    function createUI() {
        if (document.getElementById("orion-wrap")) document.getElementById("orion-wrap").remove();
        
        const s = document.createElement("style");
        s.innerHTML = `
            #orion-wrap {
                position: fixed;
                top: 10px;
                right: 10px;
                width: 95%;
                max-width: 450px;
                background: rgba(15, 23, 42, 0.98);
                border: 1px solid #2d3748;
                border-radius: 10px;
                padding: 15px;
                color: #e2e8f0;
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                z-index: 9999;
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
                overflow-y: auto;
                max-height: 95vh;
                box-sizing: border-box;
                font-size: 13px;
                line-height: 1.4;
            }
            
            @media (max-width: 768px) {
                #orion-wrap {
                    width: 96%;
                    right: 2%;
                    left: 2%;
                    max-width: none;
                    padding: 12px;
                }
            }
            
            .header {
                text-align: center;
                margin-bottom: 15px;
                padding-bottom: 12px;
                border-bottom: 1px solid #2d3748;
            }
            
            .header-title {
                font-size: 15px;
                font-weight: 700;
                letter-spacing: 0.5px;
                color: #4299e1;
                margin-bottom: 6px;
                text-transform: uppercase;
            }
            
            .status-badge {
                display: inline-block;
                padding: 4px 10px;
                border-radius: 12px;
                font-size: 10px;
                font-weight: 600;
                background: #2d3748;
                border: 1px solid #4a5568;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .tabs {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 6px;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid #2d3748;
            }
            
            .tab {
                padding: 8px 4px;
                background: #2d3748;
                border: 1px solid #4a5568;
                border-radius: 6px;
                cursor: pointer;
                text-align: center;
                font-size: 10px;
                font-weight: 600;
                color: #a0aec0;
                transition: all 0.2s;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                text-transform: uppercase;
            }
            
            .tab.active {
                background: #4299e1;
                color: white;
                border-color: #4299e1;
            }
            
            .tab-content {
                display: none;
            }
            
            .tab-content.active {
                display: block;
            }
            
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                margin-bottom: 15px;
            }
            
            .stat-card {
                background: #2d3748;
                border: 1px solid #4a5568;
                border-radius: 6px;
                padding: 10px;
            }
            
            .stat-label {
                font-size: 9px;
                color: #a0aec0;
                margin-bottom: 4px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .stat-value {
                font-size: 12px;
                font-weight: 600;
                color: #edf2f7;
                font-family: 'Roboto Mono', monospace;
            }
            
            .profit-positive { color: #48bb78; }
            .profit-negative { color: #f56565; }
            
            .control-panel {
                display: grid;
                gap: 8px;
                margin: 15px 0;
            }
            
            .button-row {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            
            .btn {
                padding: 10px;
                border: none;
                border-radius: 6px;
                font-weight: 600;
                font-size: 11px;
                cursor: pointer;
                transition: all 0.2s;
                text-align: center;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                background: #4a5568;
                color: #e2e8f0;
                border: 1px solid #718096;
            }
            
            .btn-run { background: #38a169; color: white; border: none; }
            .btn-pause { background: #d69e2e; color: white; border: none; }
            .btn-stop { background: #e53e3e; color: white; border: none; }
            .btn-support { background: #4299e1; color: white; border: none; }
            .btn-report { background: #805ad5; color: white; border: none; }
            
            .btn:hover {
                opacity: 0.9;
                transform: translateY(-1px);
            }
            
            .settings-section {
                margin-bottom: 15px;
            }
            
            .section-title {
                font-size: 11px;
                font-weight: 600;
                color: #a0aec0;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #4a5568;
                padding-bottom: 4px;
            }
            
            .input-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .input-group {
                margin-bottom: 8px;
            }
            
            .input-label {
                font-size: 10px;
                color: #a0aec0;
                margin-bottom: 4px;
                display: block;
            }
            
            input, select {
                width: 100%;
                padding: 8px 10px;
                background: #2d3748;
                border: 1px solid #4a5568;
                border-radius: 4px;
                color: #e2e8f0;
                font-size: 11px;
                font-family: 'Roboto Mono', monospace;
            }
            
            .log-container {
                background: #1a202c;
                border-radius: 6px;
                padding: 10px;
                max-height: 120px;
                overflow-y: auto;
                border: 1px solid #4a5568;
                margin-bottom: 10px;
            }
            
            .log-header {
                font-size: 10px;
                color: #a0aec0;
                margin-bottom: 8px;
                text-align: center;
                font-weight: 600;
                text-transform: uppercase;
            }
            
            .mode-toggle {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 10px;
                padding: 8px;
                background: #2d3748;
                border-radius: 6px;
                border: 1px solid #4a5568;
            }
            
            .mode-label {
                font-size: 11px;
                color: #e2e8f0;
            }
            
            .toggle-switch {
                position: relative;
                display: inline-block;
                width: 36px;
                height: 20px;
            }
            
            .toggle-switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }
            
            .toggle-slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #4a5568;
                transition: .2s;
                border-radius: 20px;
            }
            
            .toggle-slider:before {
                position: absolute;
                content: "";
                height: 16px;
                width: 16px;
                left: 2px;
                bottom: 2px;
                background-color: white;
                transition: .2s;
                border-radius: 50%;
            }
            
            input:checked + .toggle-slider {
                background-color: #4299e1;
            }
            
            input:checked + .toggle-slider:before {
                transform: translateX(16px);
            }
            
            .drag-handle {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 24px;
                cursor: move;
                z-index: 10;
                border-radius: 10px 10px 0 0;
            }
            
            .close-btn {
                position: absolute;
                top: 8px;
                right: 8px;
                background: none;
                border: none;
                color: #a0aec0;
                font-size: 16px;
                cursor: pointer;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: background 0.2s;
                font-weight: bold;
            }
            
            .close-btn:hover {
                background: rgba(229, 62, 62, 0.1);
                color: #e53e3e;
            }
            
            .connection-status {
                font-size: 9px;
                color: #a0aec0;
                text-align: center;
                margin-top: 5px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
        `;
        document.head.appendChild(s);
        
        const d = document.createElement("div");
        d.id = "orion-wrap";
        d.innerHTML = `
            <div class="drag-handle"></div>
            <button class="close-btn" id="close-btn">×</button>
            
            <div class="header">
                <div class="header-title">ORION TRADING BOT</div>
                <div class="status-badge" id="st-status-text">READY</div>
            </div>
            
            <div class="tabs">
                <div class="tab active" data-tab="stats">STATS</div>
                <div class="tab" data-tab="settings">SETTINGS</div>
                <div class="tab" data-tab="modes">MODES</div>
                <div class="tab" data-tab="logs">LOGS</div>
            </div>
            
            <!-- STATISTICS TAB -->
            <div id="tab-stats" class="tab-content active">
                <div class="stats-grid" id="stats-grid">
                    <!-- Dynamic stats -->
                </div>
                
                <div class="control-panel">
                    <button id="btn-run" class="btn btn-run">START</button>
                    <div class="button-row">
                        <button id="btn-pause" class="btn btn-pause">PAUSE</button>
                        <button id="btn-stop" class="btn btn-stop">STOP</button>
                        <button id="btn-report" class="btn btn-report">REPORT</button>
                    </div>
                </div>
            </div>
            
            <!-- SETTINGS TAB -->
            <div id="tab-settings" class="tab-content">
                <div class="settings-section">
                    <div class="section-title">Currency</div>
                    <select id="p-currency"></select>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">Dice Settings</div>
                    <div class="input-grid">
                        <div class="input-group">
                            <label class="input-label">Base Bet</label>
                            <input id="p-basebet" value="0.00000100" type="number" step="0.00000001">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Base Chance %</label>
                            <input id="p-bch-min" value="80.0" type="number" step="0.1">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Hunt Chance %</label>
                            <input id="p-hch-min" value="20.0" type="number" step="0.1">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Max Chance %</label>
                            <input id="p-bch-max" value="95.0" type="number" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">Limbo Settings</div>
                    <div class="input-grid">
                        <div class="input-group">
                            <label class="input-label">Min Payout</label>
                            <input id="p-limbo-min-payout" value="1.1" type="number" step="0.1">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Max Payout</label>
                            <input id="p-limbo-max-payout" value="3.0" type="number" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">Wager Mode</div>
                    <div class="input-grid">
                        <div class="input-group">
                            <label class="input-label">Chance %</label>
                            <input id="p-wgr-chance" value="99.0" type="number" step="0.1">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Divider</label>
                            <input id="p-wgr-div" value="100" type="number" step="1">
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">Safety</div>
                    <div class="input-grid">
                        <div class="input-group">
                            <label class="input-label">Min Bet</label>
                            <input id="p-minbet" value="0.00000001" type="number" step="0.00000001">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Target %</label>
                            <input id="p-target-pct" value="5.0" type="number" step="0.1">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- MODES TAB -->
            <div id="tab-modes" class="tab-content">
                <div class="settings-section">
                    <div class="section-title">Mode Toggles</div>
                    <div class="mode-toggle">
                        <span class="mode-label">Base Mode</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-base" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="mode-toggle">
                        <span class="mode-label">Wager Mode</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-wager" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="mode-toggle">
                        <span class="mode-label">Auto Switch</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-autoswitch" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">Current Game</div>
                    <div style="text-align: center; padding: 15px; background: #2d3748; border-radius: 6px; border: 1px solid #4a5568;">
                        <div style="font-size: 14px; font-weight: 700; color: #4299e1;" id="current-game-display">DICE</div>
                        <div style="font-size: 11px; color: #a0aec0; margin-top: 5px;" id="current-settings-display">Chance: 85.0%</div>
                    </div>
                </div>
                
                <div style="margin-top: 15px;">
                    <button id="btn-support" class="btn btn-support">SUPPORT</button>
                </div>
            </div>
            
            <!-- LOGS TAB -->
            <div id="tab-logs" class="tab-content">
                <div class="log-container">
                    <div class="log-header">Live Bet Log</div>
                    <div id="p-log-body"></div>
                </div>
                <button id="clear-logs" class="btn" style="width: 100%;">CLEAR LOGS</button>
            </div>
        `;
        
        document.body.appendChild(d);
        
        // Initialize draggable
        makeDraggable(document.getElementById("orion-wrap"));
        
        // Tab functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(`tab-${tabId}`).classList.add('active');
            });
        });
        
        // Mode toggles
        document.getElementById("toggle-base").onchange = (e) => {
            bot.activeModes.base = e.target.checked;
        };
        
        document.getElementById("toggle-wager").onchange = (e) => {
            bot.activeModes.wager = e.target.checked;
        };
        
        document.getElementById("toggle-autoswitch").onchange = (e) => {
            bot.activeModes.autoswitch = e.target.checked;
        };
        
        // Currency change
        document.getElementById("p-currency").onchange = async (e) => {
            bot.selectedCurrency = e.target.value;
            localStorage.setItem('orion_last_coin', bot.selectedCurrency);
            await updateBalanceDisplay();
            updateStatsDisplay();
        };

        // Buttons
        document.getElementById("btn-run").onclick = async () => {
            await startBotEngine();
        };
        
        document.getElementById("btn-pause").onclick = () => {
            bot.isPaused = !bot.isPaused;
            updateStatus(bot.isPaused ? "PAUSED" : "RUNNING", 
                       bot.isPaused ? "#d69e2e" : "#38a169");
        };
        
        document.getElementById("btn-stop").onclick = async () => { 
            await stopEngine(); 
            updateStatus("STOPPED", "#e53e3e"); 
        };
        
        document.getElementById("btn-report").onclick = async () => {
            await sendTelegramReport("MANUAL_REPORT");
            updateStatus("REPORT SENT", "#805ad5");
            setTimeout(() => {
                if (bot.isRunning) updateStatus("RUNNING", "#38a169");
            }, 2000);
        };
        
        document.getElementById("btn-support").onclick = () => {
            window.open(`https://t.me/${CONFIG.supportContact.replace('@', '')}`, '_blank');
        };
        
        document.getElementById("clear-logs").onclick = () => {
            const logBox = document.getElementById("p-log-body");
            if (logBox) logBox.innerHTML = "";
        };
        
        document.getElementById("close-btn").onclick = () => {
            document.getElementById("orion-wrap").style.display = 'none';
        };
        
        // Initialize
        updateStatsDisplay();
        API.syncOnce();
    }

    // ==================== DRAGGABLE FUNCTION ====================
    function makeDraggable(element) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        const dragHandle = element.querySelector('.drag-handle');
        
        if (dragHandle) {
            dragHandle.onmousedown = dragMouseDown;
            dragHandle.ontouchstart = dragTouchStart;
        }

        function dragMouseDown(e) {
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            
            let newTop = element.offsetTop - pos2;
            let newLeft = element.offsetLeft - pos1;
            
            newTop = Math.max(5, Math.min(window.innerHeight - element.offsetHeight - 5, newTop));
            newLeft = Math.max(5, Math.min(window.innerWidth - element.offsetWidth - 5, newLeft));
            
            element.style.top = newTop + "px";
            element.style.right = "auto";
            element.style.left = newLeft + "px";
        }

        function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
        }

        function dragTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            pos3 = touch.clientX;
            pos4 = touch.clientY;
            document.ontouchend = closeDragElementTouch;
            document.ontouchmove = elementDragTouch;
        }

        function elementDragTouch(e) {
            const touch = e.touches[0];
            pos1 = pos3 - touch.clientX;
            pos2 = pos4 - touch.clientY;
            pos3 = touch.clientX;
            pos4 = touch.clientY;
            
            let newTop = element.offsetTop - pos2;
            let newLeft = element.offsetLeft - pos1;
            
            newTop = Math.max(5, Math.min(window.innerHeight - element.offsetHeight - 5, newTop));
            newLeft = Math.max(5, Math.min(window.innerWidth - element.offsetWidth - 5, newLeft));
            
            element.style.top = newTop + "px";
            element.style.right = "auto";
            element.style.left = newLeft + "px";
        }

        function closeDragElementTouch() {
            document.ontouchend = null;
            document.ontouchmove = null;
        }
    }

    // ==================== START BOT ENGINE ====================
    async function startBotEngine() {
        if (!bot.isRunning) {
            bot.selectedCurrency = document.getElementById("p-currency").value;
            await API.syncOnce();
            
            bot.stats.startBal = await API.getBalance(bot.selectedCurrency);
            bot.stats.currentBal = bot.stats.startBal;
            bot.stats.profit = 0;
            bot.stats.wagered = 0;
            bot.stats.bets = 0;
            bot.stats.wins = 0;
            bot.stats.loss = 0;
            bot.stats.maxDD = 0;
            bot.stats.maxProfit = 0;
            bot.stats.maxBet = 0;
            bot.stats.minBalance = bot.stats.startBal;
            bot.stats.maxBalance = bot.stats.startBal;
            bot.stats.currentStreak = 0;
            bot.stats.maxWinStreak = 0;
            bot.stats.maxLossStreak = 0;
            bot.stats.totalPayout = 0;
            bot.consecutiveLosses = 0;
            
            bot.isRunning = true;
            bot.isPaused = false;
            bot.startTime = Date.now();
            bot.mode = "BASE";
            bot.nextBet = getVal("p-basebet");
            bot.currentChance = 85.0;
            bot.currentPayout = 2.0;
            bot.gameMode = "DICE";
            bot.lastSwitchBet = 0;
            bot.sessionHigh = bot.stats.startBal;
            bot.sessionLow = bot.stats.startBal;
            bot.partialProfit = 0;
            bot.lastReportTime = Date.now();
            bot.lastWsUpdate = Date.now();
            
            initLabouchere(getVal("p-lab-basebet"), getVal("p-lab-chance"));
            
            document.getElementById("p-log-body").innerHTML = "";
            updateStatus("RUNNING", "#38a169");
            
            // Initial stats update
            updateStatsDisplay();
            
            runLoop();
        }
    }

    // ==================== STATS DISPLAY ====================
    function updateStatsDisplay() {
        const statsGrid = document.getElementById("stats-grid");
        const gameDisplay = document.getElementById("current-game-display");
        const settingsDisplay = document.getElementById("current-settings-display");
        
        if (!statsGrid) return;
        
        const winRate = bot.stats.bets > 0 ? ((bot.stats.wins / bot.stats.bets) * 100).toFixed(2) : "0.00";
        const profitPct = bot.stats.startBal > 0 ? (bot.stats.profit / bot.stats.startBal * 100).toFixed(2) : "0.00";
        const currentDD = bot.stats.startBal - bot.stats.currentBal;
        const currentDDPct = bot.stats.startBal > 0 ? (currentDD / bot.stats.startBal * 100).toFixed(2) : "0.00";
        
        const stats = [
            { label: "BALANCE", value: bot.stats.currentBal.toFixed(8) },
            { label: "PROFIT", value: `${bot.stats.profit.toFixed(8)} (${profitPct}%)`, class: bot.stats.profit >= 0 ? "profit-positive" : "profit-negative" },
            { label: "BETS", value: `${bot.stats.bets} (${bot.stats.wins}W/${bot.stats.loss}L)` },
            { label: "WIN RATE", value: `${winRate}%` },
            { label: "WAGERED", value: bot.stats.wagered.toFixed(8) },
            { label: "TIME", value: getElapsedTime() },
            { label: "MODE", value: bot.mode },
            { label: "GAME", value: bot.gameMode },
            { label: "LOSS STREAK", value: bot.consecutiveLosses },
            { label: "DRAWDOWN", value: `${currentDD.toFixed(8)} (${currentDDPct}%)` }
        ];
        
        statsGrid.innerHTML = stats.map(stat => `
            <div class="stat-card">
                <div class="stat-label">${stat.label}</div>
                <div class="stat-value ${stat.class || ''}">${stat.value}</div>
            </div>
        `).join('');
        
        // Update game display
        if (gameDisplay) {
            gameDisplay.textContent = bot.gameMode;
        }
        
        if (settingsDisplay) {
            settingsDisplay.textContent = bot.gameMode === "DICE" 
                ? `Chance: ${bot.currentChance.toFixed(2)}%`
                : `Payout: ${bot.currentPayout.toFixed(2)}x`;
        }
    }

    // ==================== REAL-TIME UPDATES ====================
    setInterval(() => {
        try {
            if (!document.getElementById("stats-grid")) return;
            updateStatsDisplay();
        } catch (e) {
            console.error("UI update error:", e);
        }
    }, 500);

    // ==================== INITIALIZATION ====================
    async function initialize() {
        const isValid = await validateLicense();
        
        if (isValid) {
            console.log(`License valid for ${currentUser} (${licenseData.tier})`);
            bot.stakeUser = currentUser;
            createUI();
        } else {
            console.log("License invalid or user not whitelisted");
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();
