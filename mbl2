(function () {
    const CONFIG = {
        get apiUrl() { return window.location.origin + '/_api'; },
        version: "ORION WAGER BOT v2.0",
        license: {
            type: "PREMIUM",
            expiryDate: new Date("2026-02-26"),
            isValid: function() {
                return new Date() <= this.expiryDate;
            }
        },
        telegram: {
            enabled: true,
            botToken: '8391763291:AAGdi0yiVDwm0xZvq4UaJzMyy6_kaN0Zerc',
            chatId: '-1003744641395',
            sendOnStart: true,
            sendOnStop: true,
            sendOnRecovery: true
        }
    };

    const bot = {
        isRunning: false,
        isPaused: false,
        isDemo: false,
        demoBalance: 1000.0,
        token: null,
        stakeUser: "Loading...",
        selectedCurrency: "doge",
        globalMinBet: 0.00000001,
        realBalance: 0,
        availableCurrencies: [],
        
        stats: {
            profit: 0,
            wagered: 0,
            startBal: 0,
            currentBal: 0,
            peakBalance: 0,
            maxDrawdown: 0,
            drawdownPercentage: 0,
            bets: 0,
            wins: 0,
            loss: 0,
            startTime: null,
            lastBetAmount: 0,
            lastResults: [],
            winStreak: 0,
            lossStreak: 0,
            maxWinStreak: 0,
            maxLossStreak: 0,
            consecutiveLosses: 0,
            consecutiveWins: 0,
            winRate: 0,
            wageredPercent: 0,
            avgBetSize: 0
        },
        
        smartMartingale: {
            // General martingale settings
            multiplierOnLoss: 2.0,
            multiplierOnWin: 1.0,
            resetOnWin: true,
            resetOnLoss: false,
            resetStreaksOnModeSwitch: true,
            
            // Loss streak settings
            lossStreakForMulti: 3,
            multiAfterLossStreak: 2.5,
            
            // Win streak settings  
            winStreakForMulti: 3,
            multiAfterWinStreak: 1.5,
            
            // Reset settings
            resetBaseAfterLosses: 5,
            
            // Safety limits
            maxMultiplier: 100,
            maxBetPercent: 10,
            stopAfterLosses: 10,
            
            // RECOVERY SETTINGS - SEMUA BISA DIEDIT
            recoveryChance: 95,
            recoveryMultiplierOnLoss: 2.5,
            recoveryMultiAfterLossStreak: 3.0,
            recoveryLossStreakForMulti: 2,
            recoveryWinStreakForMulti: 2,
            recoveryMultiAfterWinStreak: 0.7,
            recoveryResetOnWin: true,
            recoveryResetBaseAfterLosses: 3,
            
            // Recovery state
            recoveryMode: false,
            recoveryStartBalance: 0,
            recoveryLossAmount: 0,
            currentMultiplier: 1,
            currentBaseBet: 0
        },
        
        wagerMode: {
            active: true,
            diceBetPercent: 1.0,
            diceChance: 99.5,
            dicePayout: 0,
            limboBetPercent: 0.5,
            limboMultiplier: 1.001,
            limboPayout: 0,
            diceBetsPerCycle: 10,
            limboBetsPerCycle: 50,
            currentMode: 'dice',
            diceBetCount: 0,
            limboBetCount: 0,
            stopLossPercent: 2.0,
            startBalance: 0,
            lossTriggered: false
        }
    };

    // =============== TELEGRAM FUNCTIONS ===============
    const TelegramAPI = {
        async sendMessage(text, parse_mode = "HTML") {
            if (!CONFIG.telegram?.enabled) return;
            try {
                const url = `https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`;
                const params = {
                    chat_id: CONFIG.telegram.chatId,
                    text: text,
                    parse_mode: parse_mode,
                    disable_web_page_preview: true
                };
                await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(params)
                });
            } catch (error) {
                console.error("Telegram error:", error);
            }
        },

        async sendStartReport() {
            if (!CONFIG.telegram.sendOnStart) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `üöÄ <b>ORION WAGER BOT STARTED</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `üí∞ Balance: <code>${bot.stats.startBal.toFixed(8)} ${currencyName}</code>\n` +
                `‚ö° Min Bet: <code>${bot.globalMinBet.toFixed(8)}</code>\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendStopReport(reason = "Manual Stop") {
            if (!CONFIG.telegram.sendOnStop) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            
            const profitPercent = bot.stats.startBal > 0 
                ? ((bot.stats.profit / bot.stats.startBal) * 100) 
                : 0;
            
            const winRate = bot.stats.bets > 0 
                ? ((bot.stats.wins / bot.stats.bets) * 100) 
                : 0;
            
            const wageredPercent = bot.stats.startBal > 0
                ? ((bot.stats.wagered / bot.stats.startBal) * 100)
                : 0;
            
            const message = `üõë <b>ORION BOT STOPPED</b>\n` +
                `üìù Reason: <b>${reason}</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `‚è±Ô∏è Runtime: <code>${hours}h ${minutes}m</code>\n` +
                `üéØ Bets: <code>${bot.stats.bets}</code>\n` +
                `üìà Win Rate: <code>${winRate.toFixed(2)}%</code>\n` +
                `üí∞ Start: <code>${bot.stats.startBal.toFixed(8)} ${currencyName}</code>\n` +
                `üí∞ End: <code>${bot.stats.currentBal.toFixed(8)} ${currencyName}</code>\n` +
                `üìà Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} ${currencyName}</code>\n` +
                `üìà %: <code>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</code>\n` +
                `üí∏ Wagered: <code>${bot.stats.wagered.toFixed(8)} ${currencyName}</code>\n` +
                `üìä Wagered %: <code>${wageredPercent.toFixed(2)}%</code>\n` +
                `‚ö° Min Bet: <code>${bot.globalMinBet.toFixed(8)}</code>\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendRecoveryTrigger(lossAmount, lossPercent) {
            if (!CONFIG.telegram.sendOnRecovery) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `‚ö†Ô∏è <b>ORION RECOVERY MODE TRIGGERED</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `üìâ Loss Amount: <code>${lossAmount.toFixed(8)} ${currencyName}</code>\n` +
                `üìâ Loss %: <code>${lossPercent.toFixed(2)}%</code>\n` +
                `üí∞ Current Balance: <code>${bot.stats.currentBal.toFixed(8)}</code>\n` +
                `üîÑ Switching to Recovery Mode\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendRecoveryComplete() {
            if (!CONFIG.telegram.enabled && CONFIG.telegram.sendOnRecovery) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `‚úÖ <b>ORION RECOVERY COMPLETE</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `üí∞ Recovered to: <code>${bot.stats.currentBal.toFixed(8)} ${currencyName}</code>\n` +
                `üîÑ Returning to Wager Mode\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        }
    };

    // =============== CURRENCY FUNCTIONS ===============
    async function syncCurrenciesFromServer() {
        try {
            if (!bot.token) {
                updateLogs("No token found, trying to sync...", true);
                return getDefaultCurrencies();
            }
            
            const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${bot.token}`,
                    "x-access-token": bot.token,
                    "x-csrf-token": bot.token
                },
                body: JSON.stringify({
                    query: `query {
                        user {
                            balances {
                                available {
                                    amount
                                    currency
                                }
                            }
                        }
                    }`
                })
            });
            
            if (!res.ok) {
                updateLogs(`‚ö†Ô∏è API responded with status: ${res.status}`, true);
                return getDefaultCurrencies();
            }
            
            const json = await res.json();
            
            if (json?.errors) {
                updateLogs(`‚ö†Ô∏è GraphQL error: ${json.errors[0]?.message}`, true);
                return getDefaultCurrencies();
            }
            
            if (!json?.data?.user?.balances) {
                updateLogs("‚ö†Ô∏è No balances data found in response", true);
                return getDefaultCurrencies();
            }
            
            const currenciesSet = new Set();
            const currencies = [];
            
            json.data.user.balances.forEach(balance => {
                if (balance.available && balance.available.currency) {
                    const currencyCode = balance.available.currency.toLowerCase();
                    if (!currenciesSet.has(currencyCode)) {
                        currenciesSet.add(currencyCode);
                        
                        currencies.push({
                            code: currencyCode,
                            name: balance.available.currency.toUpperCase(),
                            icon: getCurrencyIcon(currencyCode),
                            balance: parseFloat(balance.available.amount) || 0
                        });
                    }
                }
            });
            
            if (currencies.length === 0) {
                updateLogs("‚ö†Ô∏è No currencies found, using defaults", true);
                return getDefaultCurrencies();
            }
            
            bot.availableCurrencies = currencies;
            
            // Auto-select first currency with balance > 0, or first available
            if (!currencies.find(c => c.code === bot.selectedCurrency)) {
                const currencyWithBalance = currencies.find(c => c.balance > 0) || currencies[0];
                bot.selectedCurrency = currencyWithBalance.code;
            }
            
            updateLogs(`‚úÖ Synced ${currencies.length} currencies from server`, true);
            return currencies;
            
        } catch (e) {
            updateLogs(`‚ö†Ô∏è Failed to sync currencies: ${e.message}`, true);
            return getDefaultCurrencies();
        }
    }

    function getDefaultCurrencies() {
        return [
            { code: "doge", name: "DOGE", icon: "üêï", balance: 0 },
            { code: "btc", name: "BTC", icon: "‚Çø", balance: 0 },
            { code: "eth", name: "ETH", icon: "Œû", balance: 0 },
            { code: "ltc", name: "LTC", icon: "≈Å", balance: 0 },
            { code: "xrp", name: "XRP", icon: "‚úï", balance: 0 },
            { code: "ada", name: "ADA", icon: "A", balance: 0 },
            { code: "trx", name: "TRX", icon: "T", balance: 0 },
            { code: "usdt", name: "USDT", icon: "üíµ", balance: 0 },
            { code: "usdc", name: "USDC", icon: "üí≤", balance: 0 },
            { code: "sol", name: "SOL", icon: "‚óé", balance: 0 },
            { code: "matic", name: "MATIC", icon: "‚¨°", balance: 0 },
            { code: "bnb", name: "BNB", icon: "‚õìÔ∏è", balance: 0 },
            { code: "shib", name: "SHIB", icon: "üêï", balance: 0 }
        ];
    }

    function getCurrencyIcon(currencyCode) {
        const icons = {
            'doge': 'üêï', 'btc': '‚Çø', 'eth': 'Œû', 'ltc': '≈Å', 'xrp': '‚úï', 'ada': 'A',
            'trx': 'T', 'usdt': 'üíµ', 'usdc': 'üí≤', 'sol': '‚óé', 'matic': '‚¨°',
            'bnb': '‚õìÔ∏è', 'shib': 'üêï', 'xlm': '‚òÖ', 'algo': 'Œë', 'dot': '‚óè',
            'avax': '‚ùÑÔ∏è', 'link': 'üîó', 'uni': 'ü¶Ñ', 'aave': 'üëª', 'comp': 'ü¶Ñ',
            'yfi': 'üè¶', 'snx': '‚ö°', 'mkr': 'üè≠', 'bat': 'ü¶á', 'zrx': '0x'
        };
        
        return icons[currencyCode] || 'üí∞';
    }

    // =============== SMART MARTINGALE CALCULATION ===============
    function calculateSmartMartingaleBet(isWin, currentBet) {
        const sm = bot.smartMartingale;
        let multiplier = 1;
        let baseBet = sm.currentBaseBet || (bot.stats.currentBal * (bot.wagerMode.diceBetPercent / 100));
        
        if (isWin) {
            bot.stats.consecutiveWins++;
            bot.stats.consecutiveLosses = 0;
            multiplier = sm.multiplierOnWin;
            
            if (bot.stats.consecutiveWins >= sm.winStreakForMulti) {
                multiplier = sm.multiAfterWinStreak;
            }
            
            if (sm.resetOnWin) {
                multiplier = 1;
                baseBet = sm.currentBaseBet || (bot.stats.currentBal * (bot.wagerMode.diceBetPercent / 100));
                bot.stats.consecutiveWins = 0;
            }
        } else {
            bot.stats.consecutiveLosses++;
            bot.stats.consecutiveWins = 0;
            multiplier = sm.multiplierOnLoss;
            
            if (bot.stats.consecutiveLosses >= sm.lossStreakForMulti) {
                multiplier = sm.multiAfterLossStreak;
            }
            
            if (bot.stats.consecutiveLosses >= sm.resetBaseAfterLosses) {
                baseBet = sm.currentBaseBet || (bot.stats.currentBal * (bot.wagerMode.diceBetPercent / 100));
                bot.stats.consecutiveLosses = 0;
                updateLogs(`üîÑ Reset base bet after ${sm.resetBaseAfterLosses} losses`, true);
            }
            
            if (sm.resetOnLoss) {
                multiplier = 1;
                baseBet = sm.currentBaseBet || (bot.stats.currentBal * (bot.wagerMode.diceBetPercent / 100));
            }
        }
        
        const currentTotalMultiplier = sm.currentMultiplier * multiplier;
        if (currentTotalMultiplier > sm.maxMultiplier) {
            multiplier = sm.maxMultiplier / sm.currentMultiplier;
            updateLogs(`‚ö†Ô∏è Max multiplier reached (${sm.maxMultiplier}x)`, true);
        }
        
        let newBet = baseBet * multiplier;
        const maxBetByBalance = bot.stats.currentBal * (sm.maxBetPercent / 100);
        if (newBet > maxBetByBalance) {
            newBet = maxBetByBalance;
            updateLogs(`‚ö†Ô∏è Bet capped at ${sm.maxBetPercent}% of balance`, true);
        }
        
        if (newBet < bot.globalMinBet) {
            newBet = bot.globalMinBet;
        }
        
        sm.currentMultiplier *= multiplier;
        
        if (bot.stats.consecutiveLosses >= sm.stopAfterLosses) {
            updateLogs(`üõë Stopping after ${sm.stopAfterLosses} consecutive losses`, true);
            bot.isRunning = false;
            TelegramAPI.sendStopReport(`Auto-stop after ${sm.stopAfterLosses} consecutive losses`);
            return null;
        }
        
        return newBet;
    }

    // =============== WAGER MODE LOGIC ===============
    function initWagerMode() {
        // GET VALUES FROM UI INPUTS - TIDAK DI OVERWRITE LAGI
        // Values akan diambil dari input saat wager dimulai
        
        bot.wagerMode.active = true;
        bot.smartMartingale.recoveryMode = false;
        bot.wagerMode.startBalance = bot.stats.currentBal;
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        bot.wagerMode.lossTriggered = false;
        
        // Calculate payouts
        bot.wagerMode.dicePayout = 99 / bot.wagerMode.diceChance;
        bot.wagerMode.limboPayout = bot.wagerMode.limboMultiplier;
        
        // Set initial base bet
        bot.smartMartingale.currentBaseBet = bot.stats.currentBal * (bot.wagerMode.diceBetPercent / 100);
        bot.smartMartingale.currentMultiplier = 1;
        
        updateLogs(`üéØ ORION WAGER MODE STARTED`, true);
        updateLogs(`üí∞ Start Balance: ${bot.wagerMode.startBalance.toFixed(8)}`, true);
        updateLogs(`üé≤ Dice: ${bot.wagerMode.diceBetPercent}% | Limbo: ${bot.wagerMode.limboBetPercent}%`, true);
        updateLogs(`‚ö° Min Bet: ${bot.globalMinBet.toFixed(8)}`, true);
    }

    function wagerBetLogic() {
        const wm = bot.wagerMode;
        const profitFromStart = bot.stats.currentBal - wm.startBalance;
        const stopLossAmount = wm.startBalance * (wm.stopLossPercent / 100);
        
        // Check stop loss
        if (profitFromStart < -stopLossAmount && !wm.lossTriggered) {
            const lossAmount = Math.abs(profitFromStart);
            const lossPercent = (lossAmount / wm.startBalance) * 100;
            
            wm.lossTriggered = true;
            updateLogs(`‚ö†Ô∏è Stop loss triggered: ${lossAmount.toFixed(8)} (${lossPercent.toFixed(2)}%)`, true);
            updateLogs(`üîÑ Switching to Recovery Mode`, true);
            
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnRecovery) {
                TelegramAPI.sendRecoveryTrigger(lossAmount, lossPercent);
            }
            
            setTimeout(() => {
                switchToRecoveryMode();
            }, 1000);
            return null;
        }
        
        // Switch between dice and limbo
        if (wm.currentMode === 'dice') {
            wm.diceBetCount++;
            if (wm.diceBetCount >= wm.diceBetsPerCycle) {
                wm.currentMode = 'limbo';
                wm.diceBetCount = 0;
                updateLogs(`üîÑ Switching to Limbo Mode`, true);
            }
        } else {
            wm.limboBetCount++;
            if (wm.limboBetCount >= wm.limboBetsPerCycle) {
                wm.currentMode = 'dice';
                wm.limboBetCount = 0;
                updateLogs(`üîÑ Switching to Dice Mode`, true);
            }
        }
        
        // Calculate base bet
        let baseBetPercent = wm.currentMode === 'dice' ? wm.diceBetPercent : wm.limboBetPercent;
        let baseBet = bot.stats.currentBal * (baseBetPercent / 100);
        
        // Apply martingale if there are previous results
        if (bot.stats.lastResults.length > 0) {
            const lastResult = bot.stats.lastResults[0];
            const newBet = calculateSmartMartingaleBet(lastResult.win, lastResult.betAmount);
            if (newBet !== null) {
                baseBet = newBet;
            } else {
                return null;
            }
        }
        
        // Apply safety limits
        const maxBet = bot.stats.currentBal * (bot.smartMartingale.maxBetPercent / 100);
        if (baseBet > maxBet) baseBet = maxBet;
        if (baseBet < bot.globalMinBet) baseBet = bot.globalMinBet;
        
        if (wm.currentMode === 'dice') {
            return {
                bet: baseBet,
                chance: wm.diceChance,
                mode: 'dice'
            };
        } else {
            return {
                bet: baseBet,
                multiplier: wm.limboMultiplier,
                mode: 'limbo'
            };
        }
    }

    // =============== RECOVERY MODE LOGIC ===============
    function initRecoveryMode() {
        // GET ALL RECOVERY SETTINGS FROM UI - SEMUA DIAMBIL
        const recoveryChanceInput = document.getElementById("recovery-chance");
        const recoveryMultiplierInput = document.getElementById("recovery-multiplier");
        const recoveryMultiAfterLossInput = document.getElementById("recovery-multi-after-loss");
        const recoveryLossStreakInput = document.getElementById("recovery-loss-streak");
        const recoveryWinStreakInput = document.getElementById("recovery-win-streak");
        const recoveryMultiAfterWinInput = document.getElementById("recovery-multi-after-win");
        const recoveryResetBaseInput = document.getElementById("recovery-reset-base");
        const recoveryResetWinCheckbox = document.getElementById("recovery-reset-win");
        
        // Update bot settings from UI
        if (recoveryChanceInput && recoveryChanceInput.value) {
            bot.smartMartingale.recoveryChance = parseFloat(recoveryChanceInput.value);
        }
        if (recoveryMultiplierInput && recoveryMultiplierInput.value) {
            bot.smartMartingale.recoveryMultiplierOnLoss = parseFloat(recoveryMultiplierInput.value);
        }
        if (recoveryMultiAfterLossInput && recoveryMultiAfterLossInput.value) {
            bot.smartMartingale.recoveryMultiAfterLossStreak = parseFloat(recoveryMultiAfterLossInput.value);
        }
        if (recoveryLossStreakInput && recoveryLossStreakInput.value) {
            bot.smartMartingale.recoveryLossStreakForMulti = parseInt(recoveryLossStreakInput.value);
        }
        if (recoveryWinStreakInput && recoveryWinStreakInput.value) {
            bot.smartMartingale.recoveryWinStreakForMulti = parseInt(recoveryWinStreakInput.value);
        }
        if (recoveryMultiAfterWinInput && recoveryMultiAfterWinInput.value) {
            bot.smartMartingale.recoveryMultiAfterWinStreak = parseFloat(recoveryMultiAfterWinInput.value);
        }
        if (recoveryResetBaseInput && recoveryResetBaseInput.value) {
            bot.smartMartingale.recoveryResetBaseAfterLosses = parseInt(recoveryResetBaseInput.value);
        }
        if (recoveryResetWinCheckbox) {
            bot.smartMartingale.recoveryResetOnWin = recoveryResetWinCheckbox.checked;
        }
        
        // Set recovery mode flags
        bot.wagerMode.active = false;
        bot.smartMartingale.recoveryMode = true;
        bot.smartMartingale.recoveryStartBalance = bot.wagerMode.startBalance;
        bot.smartMartingale.recoveryLossAmount = bot.wagerMode.startBalance - bot.stats.currentBal;
        
        // Calculate base bet for recovery (1% of current balance)
        bot.smartMartingale.currentBaseBet = bot.stats.currentBal * 0.01;
        bot.smartMartingale.currentMultiplier = 1;
        
        // Reset streaks for recovery
        bot.stats.consecutiveLosses = 0;
        bot.stats.consecutiveWins = 0;
        
        // Ensure minimum bet
        if (bot.smartMartingale.currentBaseBet < bot.globalMinBet) {
            bot.smartMartingale.currentBaseBet = bot.globalMinBet;
        }
        
        updateLogs(`üîÑ ORION RECOVERY MODE STARTED`, true);
        updateLogs(`üí∞ Loss to recover: ${bot.smartMartingale.recoveryLossAmount.toFixed(8)}`, true);
        updateLogs(`üéØ Target: ${bot.smartMartingale.recoveryStartBalance.toFixed(8)}`, true);
        updateLogs(`‚ö° Min Bet: ${bot.globalMinBet.toFixed(8)}`, true);
        updateLogs(`üéØ Recovery Chance: ${bot.smartMartingale.recoveryChance}%`, true);
    }

    function recoveryBetLogic() {
        const sm = bot.smartMartingale;
        
        // Check if recovery is complete
        if (bot.stats.currentBal >= sm.recoveryStartBalance) {
            updateLogs(`‚úÖ ORION RECOVERY COMPLETE!`, true);
            updateLogs(`üí∞ Recovered to: ${bot.stats.currentBal.toFixed(8)}`, true);
            updateLogs(`üîÑ Returning to Wager Mode`, true);
            
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnRecovery) {
                TelegramAPI.sendRecoveryComplete();
            }
            
            setTimeout(() => {
                switchToWagerMode();
            }, 1000);
            return null;
        }
        
        // Check if balance too low
        if (bot.stats.currentBal < bot.globalMinBet) {
            updateLogs(`‚ö†Ô∏è Balance too low for recovery`, true);
            bot.isRunning = false;
            TelegramAPI.sendStopReport("Balance too low for recovery");
            return null;
        }
        
        // Calculate next bet with SMART recovery martingale
        let betAmount = sm.currentBaseBet * sm.currentMultiplier;
        
        if (bot.stats.lastResults.length > 0) {
            const lastResult = bot.stats.lastResults[0];
            
            if (!lastResult.win) {
                // LOSS - Apply recovery martingale
                bot.stats.consecutiveLosses++;
                bot.stats.consecutiveWins = 0;
                
                // Check if loss streak reached
                if (bot.stats.consecutiveLosses >= sm.recoveryLossStreakForMulti) {
                    sm.currentMultiplier *= sm.recoveryMultiAfterLossStreak;
                    updateLogs(`üìà Recovery martingale (streak): ${sm.currentMultiplier.toFixed(2)}x`, true);
                } else {
                    sm.currentMultiplier *= sm.recoveryMultiplierOnLoss;
                    updateLogs(`üìà Recovery martingale: ${sm.currentMultiplier.toFixed(2)}x`, true);
                }
                
                // Reset base bet after too many losses
                if (bot.stats.consecutiveLosses >= sm.recoveryResetBaseAfterLosses) {
                    sm.currentBaseBet = bot.stats.currentBal * 0.01;
                    sm.currentMultiplier = 1;
                    bot.stats.consecutiveLosses = 0;
                    updateLogs(`üîÑ Reset recovery base after ${sm.recoveryResetBaseAfterLosses} losses`, true);
                }
                
            } else {
                // WIN - Check if need to reset
                bot.stats.consecutiveWins++;
                bot.stats.consecutiveLosses = 0;
                
                if (sm.recoveryResetOnWin) {
                    sm.currentMultiplier = 1;
                    sm.currentBaseBet = bot.stats.currentBal * 0.01;
                    updateLogs(`üîÑ Reset recovery martingale after win`, true);
                } else if (bot.stats.consecutiveWins >= sm.recoveryWinStreakForMulti) {
                    sm.currentMultiplier *= sm.recoveryMultiAfterWinStreak;
                    updateLogs(`üìâ Reduce martingale after win streak: ${sm.currentMultiplier.toFixed(2)}x`, true);
                }
            }
        }
        
        // Apply safety limits
        betAmount = sm.currentBaseBet * sm.currentMultiplier;
        const maxBet = bot.stats.currentBal * (sm.maxBetPercent / 100);
        
        if (betAmount > maxBet) {
            betAmount = maxBet;
            sm.currentMultiplier = betAmount / sm.currentBaseBet;
            updateLogs(`‚ö†Ô∏è Recovery bet capped at ${sm.maxBetPercent}% of balance`, true);
        }
        
        if (betAmount < bot.globalMinBet) betAmount = bot.globalMinBet;
        
        // Check stop after losses
        if (bot.stats.consecutiveLosses >= sm.stopAfterLosses) {
            updateLogs(`üõë Stopping after ${sm.stopAfterLosses} consecutive losses in recovery`, true);
            bot.isRunning = false;
            TelegramAPI.sendStopReport(`Auto-stop after ${sm.stopAfterLosses} consecutive losses in recovery`);
            return null;
        }
        
        return {
            bet: betAmount,
            chance: sm.recoveryChance,
            mode: 'dice'
        };
    }

    // =============== MODE SWITCHING ===============
    function switchToWagerMode() {
        // Get latest settings from UI before switching
        getWagerSettingsFromUI();
        
        bot.smartMartingale.recoveryMode = false;
        bot.wagerMode.active = true;
        bot.wagerMode.startBalance = bot.stats.currentBal;
        bot.wagerMode.lossTriggered = false;
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        bot.smartMartingale.currentMultiplier = 1;
        
        if (bot.smartMartingale.resetStreaksOnModeSwitch) {
            bot.stats.consecutiveLosses = 0;
            bot.stats.consecutiveWins = 0;
        }
        
        updateLogs(`üéØ ORION RETURNING TO WAGER MODE`, true);
        updateUI();
    }

    function switchToRecoveryMode() {
        initRecoveryMode();
        updateUI();
    }

    // =============== GET SETTINGS FROM UI ===============
    function getWagerSettingsFromUI() {
        // Get dice settings
        const diceBetPercentInput = document.getElementById("dice-bet-percent");
        const diceChanceInput = document.getElementById("dice-chance");
        const diceBetsInput = document.getElementById("dice-bets");
        
        if (diceBetPercentInput) bot.wagerMode.diceBetPercent = parseFloat(diceBetPercentInput.value) || 1.0;
        if (diceChanceInput) bot.wagerMode.diceChance = parseFloat(diceChanceInput.value) || 99.5;
        if (diceBetsInput) bot.wagerMode.diceBetsPerCycle = parseInt(diceBetsInput.value) || 10;
        
        // Get limbo settings
        const limboBetPercentInput = document.getElementById("limbo-bet-percent");
        const limboMultiplierInput = document.getElementById("limbo-multiplier");
        const limboBetsInput = document.getElementById("limbo-bets");
        
        if (limboBetPercentInput) bot.wagerMode.limboBetPercent = parseFloat(limboBetPercentInput.value) || 0.5;
        if (limboMultiplierInput) bot.wagerMode.limboMultiplier = parseFloat(limboMultiplierInput.value) || 1.001;
        if (limboBetsInput) bot.wagerMode.limboBetsPerCycle = parseInt(limboBetsInput.value) || 50;
        
        // Get stop loss
        const stopLossInput = document.getElementById("wager-stop-loss");
        if (stopLossInput) bot.wagerMode.stopLossPercent = parseFloat(stopLossInput.value) || 2.0;
        
        // Get martingale settings
        const multiOnLossInput = document.getElementById("multi-on-loss");
        const multiOnWinInput = document.getElementById("multi-on-win");
        const maxMultiplierInput = document.getElementById("max-multiplier");
        const maxBetPercentInput = document.getElementById("max-bet-percent");
        const stopAfterLossesInput = document.getElementById("stop-after-losses");
        const resetOnWinCheckbox = document.getElementById("reset-on-win");
        
        if (multiOnLossInput) bot.smartMartingale.multiplierOnLoss = parseFloat(multiOnLossInput.value) || 2.0;
        if (multiOnWinInput) bot.smartMartingale.multiplierOnWin = parseFloat(multiOnWinInput.value) || 1.0;
        if (maxMultiplierInput) bot.smartMartingale.maxMultiplier = parseFloat(maxMultiplierInput.value) || 100;
        if (maxBetPercentInput) bot.smartMartingale.maxBetPercent = parseFloat(maxBetPercentInput.value) || 10;
        if (stopAfterLossesInput) bot.smartMartingale.stopAfterLosses = parseInt(stopAfterLossesInput.value) || 10;
        if (resetOnWinCheckbox) bot.smartMartingale.resetOnWin = resetOnWinCheckbox.checked;
    }

    // =============== API FUNCTIONS ===============
    const API = {
        async syncOnce() {
            try {
                bot.token = localStorage.getItem('apitoken') || 
                           localStorage.getItem('token') ||
                           sessionStorage.getItem('token') ||
                           (document.cookie.match(/session=([^;]+)/) ? document.cookie.match(/session=([^;]+)/)[1] : null);
                
                if (!bot.token) {
                    bot.stakeUser = "Not logged in";
                    bot.availableCurrencies = getDefaultCurrencies();
                    updateLogs("‚ö†Ô∏è Please login to Stake first", true);
                    return;
                }

                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{name balances{available{amount currency}}}}`
                    })
                });
                
                if (!res.ok) {
                    bot.stakeUser = "API Error";
                    bot.availableCurrencies = getDefaultCurrencies();
                    updateLogs(`‚ö†Ô∏è API error: ${res.status}`, true);
                    return;
                }
                
                const json = await res.json();
                
                if (json?.data?.user) {
                    bot.stakeUser = json.data.user.name;
                    
                    await syncCurrenciesFromServer();
                    
                    const bals = json.data.user.balances || [];
                    const selectedBal = bals.find(b => 
                        b.available && b.available.currency && 
                        b.available.currency.toLowerCase() === bot.selectedCurrency.toLowerCase()
                    );
                    
                    if (selectedBal) {
                        bot.realBalance = parseFloat(selectedBal.available.amount);
                    }
                    
                    updateLogs(`‚úÖ ORION Synced: ${bot.stakeUser} (${bot.availableCurrencies.length} coins)`, true);
                    
                } else {
                    bot.stakeUser = "API Error";
                    bot.availableCurrencies = getDefaultCurrencies();
                }
                
            } catch (e) {
                bot.stakeUser = "Connection Error";
                bot.availableCurrencies = getDefaultCurrencies();
                updateLogs(`‚ö†Ô∏è Sync error: ${e.message}`, true);
            }
        },

        async getBalance(coin) {
            if (bot.isDemo) return bot.stats.currentBal;
            
            try {
                if (!bot.token) await this.syncOnce();
                
                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "x-access-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{balances{available{amount currency}}}}`
                    })
                });
                const json = await res.json();
                const active = json.data.user.balances.find(b =>
                    b.available.currency.toLowerCase() === coin.toLowerCase()
                );
                const balance = active ? parseFloat(active.available.amount) : 0;
                bot.realBalance = balance;
                return balance;
            } catch (e) {
                return 0;
            }
        },

        async placeDiceBet(amount, chance) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() * 100 < chance;
                    setTimeout(() => {
                        r({
                            diceRoll: {
                                amount: amount,
                                payout: win ? (amount * (99 / chance)) : 0
                            }
                        });
                    }, 50);
                });
            }

            const payload = {
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency,
                target: parseFloat((100 - chance).toFixed(2)),
                condition: "above",
                identifier: Math.random().toString(36).slice(2) + Date.now()
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/dice/roll`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                throw error;
            }
        },

        async placeLimboBet(amount, multiplierTarget) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() < (1 / multiplierTarget);
                    setTimeout(() => {
                        r({
                            limboBet: {
                                amount: amount,
                                payout: win ? (amount * multiplierTarget) : 0,
                                state: {
                                    result: win ? multiplierTarget : (multiplierTarget * Math.random()),
                                    multiplierTarget: multiplierTarget
                                }
                            }
                        });
                    }, 50);
                });
            }

            const payload = {
                multiplierTarget: multiplierTarget,
                identifier: Math.random().toString(36).slice(2) + Date.now(),
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/limbo/bet`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Limbo bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                throw error;
            }
        }
    };

    // =============== MAIN GAME LOOP ===============
    async function runLoop() {
        if (!bot.isRunning || bot.isPaused) return;

        try {
            // Sync real balance periodically
            if (!bot.isDemo && bot.stats.bets % 10 === 0) {
                const realBal = await API.getBalance(bot.selectedCurrency);
                bot.realBalance = realBal;
            }

            let betInfo = null;
            
            // Get bet info based on current mode
            if (bot.wagerMode.active) {
                betInfo = wagerBetLogic();
            } else if (bot.smartMartingale.recoveryMode) {
                betInfo = recoveryBetLogic();
            }
            
            if (betInfo === null) {
                setTimeout(runLoop, 100);
                return;
            }

            let nextBet = betInfo.bet;
            let chance = betInfo.chance;
            let multiplier = betInfo.multiplier;
            let gameMode = betInfo.mode;

            // Ensure minimum bet
            if (nextBet <= 0) nextBet = bot.globalMinBet;
            if (nextBet < bot.globalMinBet) nextBet = bot.globalMinBet;
            
            // Check balance limits
            if (!bot.isDemo) {
                if (nextBet > bot.realBalance && bot.realBalance > 0) {
                    nextBet = bot.realBalance;
                }
                
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                }
            } else {
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                }
            }

            // Place bet
            let res;
            if (gameMode === 'dice') {
                res = await API.placeDiceBet(nextBet, chance);
            } else if (gameMode === 'limbo') {
                res = await API.placeLimboBet(nextBet, multiplier);
            }

            // Process result
            let win = false;
            let pft = 0;
            let betAmount = nextBet;

            if (res) {
                if (gameMode === 'dice') {
                    const d = res?.data?.diceRoll || res?.diceRoll;
                    if (d) {
                        win = d.payout > 0;
                        pft = d.payout - d.amount;
                        betAmount = d.amount;
                    }
                } else if (gameMode === 'limbo') {
                    const lb = res?.data?.limboBet || res?.limboBet;
                    if (lb) {
                        const resultMultiplier = lb.state?.result || 0;
                        const targetMultiplier = lb.state?.multiplierTarget || multiplier;
                        win = resultMultiplier >= targetMultiplier;
                        pft = win ? (lb.amount * (targetMultiplier - 1)) : -lb.amount;
                        betAmount = lb.amount;
                    }
                }
            }

            // Update stats
            bot.stats.bets++;
            bot.stats.wagered += betAmount;
            bot.stats.profit += pft;
            bot.stats.currentBal += pft;
            bot.stats.lastBetAmount = betAmount;
            
            // Update calculated stats
            bot.stats.winRate = bot.stats.bets > 0 ? (bot.stats.wins / bot.stats.bets * 100) : 0;
            bot.stats.wageredPercent = bot.stats.startBal > 0 ? (bot.stats.wagered / bot.stats.startBal * 100) : 0;
            bot.stats.avgBetSize = bot.stats.bets > 0 ? (bot.stats.wagered / bot.stats.bets) : 0;

            if (win) {
                bot.stats.wins++;
                bot.stats.winStreak++;
                bot.stats.lossStreak = 0;
                if (bot.stats.winStreak > bot.stats.maxWinStreak) {
                    bot.stats.maxWinStreak = bot.stats.winStreak;
                }
                bot.stats.consecutiveWins++;
                bot.stats.consecutiveLosses = 0;
            } else {
                bot.stats.loss++;
                bot.stats.winStreak = 0;
                bot.stats.lossStreak++;
                if (bot.stats.lossStreak > bot.stats.maxLossStreak) {
                    bot.stats.maxLossStreak = bot.stats.lossStreak;
                }
                bot.stats.consecutiveLosses++;
                bot.stats.consecutiveWins = 0;
            }

            // Update real balance if not demo
            if (!bot.isDemo) {
                bot.realBalance += pft;
            }

            // Store last result
            bot.stats.lastResults.unshift({
                win: win,
                betAmount: betAmount,
                profit: pft,
                chance: chance,
                multiplier: multiplier,
                mode: gameMode,
                time: new Date().toLocaleTimeString()
            });
            
            if (bot.stats.lastResults.length > 5) {
                bot.stats.lastResults.pop();
            }

            // Update peak balance and drawdown
            if (bot.stats.currentBal > bot.stats.peakBalance) {
                bot.stats.peakBalance = bot.stats.currentBal;
            }
            
            const drawdown = bot.stats.peakBalance - bot.stats.currentBal;
            if (drawdown > bot.stats.maxDrawdown) {
                bot.stats.maxDrawdown = drawdown;
                bot.stats.drawdownPercentage = (drawdown / bot.stats.peakBalance) * 100;
            }

            // Log the bet
            let modeInfo = "";
            if (bot.wagerMode.active) {
                if (gameMode === 'dice') {
                    modeInfo = `[Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}]`;
                } else {
                    modeInfo = `[Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}]`;
                }
            } else {
                modeInfo = `[Recovery ${bot.smartMartingale.recoveryChance}%]`;
            }
            
            let logLine;
            const betPercent = (betAmount / bot.stats.currentBal) * 100;
            
            if (gameMode === 'dice') {
                logLine = `${modeInfo} Dice: ${betAmount.toFixed(8)} (${betPercent.toFixed(2)}%) @ ${chance}% ‚Üí ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            } else {
                logLine = `${modeInfo} Limbo: ${betAmount.toFixed(8)} (${betPercent.toFixed(2)}%) @ ${multiplier}x ‚Üí ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            }
            
            if (bot.smartMartingale.currentMultiplier > 1) {
                logLine += ` (Martingale: ${bot.smartMartingale.currentMultiplier.toFixed(2)}x)`;
            }
            
            if (bot.stats.consecutiveLosses > 0) {
                logLine += ` [L:${bot.stats.consecutiveLosses}]`;
            }
            if (bot.stats.consecutiveWins > 0) {
                logLine += ` [W:${bot.stats.consecutiveWins}]`;
            }
            
            updateLogs(logLine);

            // Update UI
            updateDashboard();
            updateLiveLogs();

            // Continue loop
            if (bot.isRunning && !bot.isPaused) {
                const delay = bot.isDemo ? 50 : 100;
                setTimeout(runLoop, delay);
            }

        } catch (e) {
            updateLogs(`‚ö†Ô∏è Error: ${e.message}`, true);
            
            if (bot.isRunning && !bot.isPaused) {
                setTimeout(runLoop, 100);
            }
        }
    }

    // =============== UI FUNCTIONS ===============
    function updateDashboard() {
        const accountName = document.getElementById("account-name");
        if (accountName) accountName.textContent = bot.stakeUser;
        
        const licenseStatus = document.getElementById("license-status");
        if (licenseStatus) {
            licenseStatus.textContent = CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED";
            licenseStatus.style.color = CONFIG.license.isValid() ? "#10b981" : "#ef4444";
        }
        
        const currencyDisplay = document.getElementById("currency-display");
        if (currencyDisplay) {
            const currency = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            currencyDisplay.textContent = currency ? `${currency.icon} ${currency.name}` : bot.selectedCurrency.toUpperCase();
        }
        
        const balanceEl = document.getElementById("balance");
        if (balanceEl) {
            if (bot.isDemo) {
                balanceEl.textContent = bot.stats.currentBal.toFixed(8);
                balanceEl.title = `Demo Balance`;
            } else {
                balanceEl.textContent = bot.realBalance.toFixed(8);
                balanceEl.title = `Real Balance`;
            }
        }
        
        const profitEl = document.getElementById("profit");
        if (profitEl) profitEl.textContent = bot.stats.profit.toFixed(8);
        
        const profitPercent = bot.stats.startBal > 0 ? (bot.stats.profit / bot.stats.startBal * 100) : 0;
        const profitPercentEl = document.getElementById("profit-percent");
        if (profitPercentEl) profitPercentEl.textContent = profitPercent.toFixed(2) + '%';
        
        const betsEl = document.getElementById("bets");
        if (betsEl) betsEl.textContent = bot.stats.bets;
        
        const wageredEl = document.getElementById("wagered");
        if (wageredEl) wageredEl.textContent = bot.stats.wagered.toFixed(8);
        
        const wageredPercentEl = document.getElementById("wagered-percent");
        if (wageredPercentEl) wageredPercentEl.textContent = bot.stats.wageredPercent.toFixed(2) + '%';
        
        const winRateEl = document.getElementById("win-rate");
        if (winRateEl) winRateEl.textContent = bot.stats.winRate.toFixed(2) + '%';
        
        const minBetEl = document.getElementById("min-bet");
        if (minBetEl) minBetEl.textContent = bot.globalMinBet.toFixed(8);
        
        const avgBetEl = document.getElementById("avg-bet");
        if (avgBetEl) avgBetEl.textContent = bot.stats.avgBetSize.toFixed(8);
        
        const currencyCountEl = document.getElementById("currency-count");
        if (currencyCountEl) currencyCountEl.textContent = `${bot.availableCurrencies.length} coins`;
        
        const modeIndicator = document.getElementById("mode-indicator");
        if (modeIndicator) {
            if (bot.wagerMode.active) {
                let patternInfo = "";
                if (bot.wagerMode.currentMode === 'dice') {
                    patternInfo = `Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}`;
                } else {
                    patternInfo = `Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}`;
                }
                modeIndicator.textContent = `WAGER (${patternInfo})`;
                modeIndicator.style.color = "#10b981";
            } else if (bot.smartMartingale.recoveryMode) {
                modeIndicator.textContent = `RECOVERY`;
                modeIndicator.style.color = "#f59e0b";
            } else {
                modeIndicator.textContent = "STOPPED";
                modeIndicator.style.color = "#94a3b8";
            }
            
            if (bot.isPaused) {
                modeIndicator.textContent += " (PAUSED)";
                modeIndicator.style.color = "#f59e0b";
            }
        }
        
        const martingaleInfo = document.getElementById("martingale-info");
        if (martingaleInfo) {
            const sm = bot.smartMartingale;
            if (sm.currentMultiplier > 1) {
                martingaleInfo.textContent = `Martingale: ${sm.currentMultiplier.toFixed(2)}x`;
                martingaleInfo.style.color = "#f59e0b";
            } else {
                martingaleInfo.textContent = "Base Bet";
                martingaleInfo.style.color = "#94a3b8";
            }
        }
        
        updateCurrencyDropdown();
    }

    function updateCurrencyDropdown() {
        const currencySelect = document.getElementById("currency-select");
        if (currencySelect && bot.availableCurrencies.length > 0) {
            const currentValue = currencySelect.value;
            
            currencySelect.innerHTML = '';
            
            bot.availableCurrencies.forEach(currency => {
                const option = document.createElement("option");
                option.value = currency.code;
                option.textContent = `${currency.icon} ${currency.name}`;
                option.selected = currency.code === bot.selectedCurrency;
                currencySelect.appendChild(option);
            });
            
            if (currentValue) {
                currencySelect.value = currentValue;
            }
        }
    }

    function updateLiveLogs() {
        const logContainer = document.getElementById("live-log");
        if (!logContainer) return;
        
        let html = "";
        
        if (bot.smartMartingale.recoveryMode) {
            html += `
                <div style="color:#f59e0b;text-align:center;padding:4px;background:rgba(245,158,11,0.1);margin-bottom:6px;border-radius:3px;font-size:10px;font-weight:bold;">
                    üîÑ ORION RECOVERY MODE | Loss: ${bot.smartMartingale.recoveryLossAmount.toFixed(8)} | Target: ${bot.smartMartingale.recoveryStartBalance.toFixed(8)}
                </div>`;
        } else if (bot.wagerMode.active) {
            html += `
                <div style="color:#10b981;text-align:center;padding:4px;background:rgba(16,185,129,0.1);margin-bottom:6px;border-radius:3px;font-size:10px;font-weight:bold;">
                    üéØ ORION ${bot.wagerMode.currentMode.toUpperCase()} MODE | Stop Loss: ${bot.wagerMode.stopLossPercent}%
                </div>`;
        }
        
        if (bot.stats.lastResults.length === 0) {
            html += '<div style="color: #94a3b8; text-align: center; padding: 10px; font-size: 10px;">No bets yet</div>';
        } else {
            bot.stats.lastResults.forEach(result => {
                let color = result.win ? "#10b981" : "#ef4444";
                let bgColor = result.win ? "rgba(16,185,129,0.1)" : "rgba(239,68,68,0.1)";
                
                if (bot.smartMartingale.recoveryMode) {
                    color = result.win ? "#22c55e" : "#f97316";
                    bgColor = result.win ? "rgba(34,197,94,0.1)" : "rgba(249,115,22,0.1)";
                }
                
                const winLoss = result.win ? "WIN" : "LOSS";
                const modeIcon = result.mode === 'dice' ? 'üé≤' : 'üìà';
                
                const betPercent = (result.betAmount / bot.stats.currentBal) * 100;
                
                html += `
                    <div class="log-entry" style="color: ${color}; background: ${bgColor}; padding: 6px; margin-bottom: 4px; border-radius: 4px; font-size: 11px; border-left: 3px solid ${color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 9px; color: #94a3b8;">${result.time}</div>
                            <div style="font-weight: bold; color: ${color};">${winLoss}</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px;">
                            <div>
                                <span>${modeIcon} ${result.betAmount.toFixed(8)}</span>
                                <span style="font-size: 9px; color: #94a3b8; margin-left: 4px;">(${betPercent.toFixed(2)}%)</span>
                            </div>
                            <div style="color: ${result.profit > 0 ? '#10b981' : '#ef4444'}; font-weight: bold;">
                                ${result.profit > 0 ? '+' : ''}${result.profit.toFixed(8)}
                            </div>
                        </div>
                        ${bot.smartMartingale.currentMultiplier > 1 ? 
                            `<div style="font-size: 9px; color: #f59e0b; text-align: center; margin-top: 2px;">
                                Martingale: ${bot.smartMartingale.currentMultiplier.toFixed(2)}x
                            </div>` : ''}
                    </div>
                `;
            });
        }
        
        logContainer.innerHTML = html;
    }

    function updateLogs(customMsg, isSystem = false) {
        const logBox = document.getElementById("p-logs");
        if (!logBox) return;

        const entry = document.createElement("div");
        entry.className = "log-entry";

        if (isSystem) {
            entry.style.color = "#f59e0b";
            entry.style.fontWeight = "bold";
        }

        entry.innerHTML = customMsg;
        logBox.prepend(entry);
        
        if (logBox.children.length > 50) {
            logBox.removeChild(logBox.lastChild);
        }
    }

    function updateUI() {
        // HANYA update elemen yang bukan user inputs!
        updateCurrencyDropdown();
        updateDashboard();
        updateLiveLogs();
        
        // JANGAN update input values disini!
        // Mereka sudah punya event listeners sendiri
    }

    // =============== UI CREATION ===============
    function createUI() {
        if (document.getElementById("orion-wrap")) return;

        const s = document.createElement("style");
        s.innerHTML = `
            #orion-wrap {
                position: fixed;
                top: 20px;
                right: 20px;
                width: 450px;
                min-width: 350px;
                max-width: calc(100vw - 40px);
                max-height: calc(100vh - 40px);
                background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
                backdrop-filter: blur(10px);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 14px;
                color: #f8fafc;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 12px;
                z-index: 999999;
                box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4), 0 0 30px rgba(59, 130, 246, 0.15);
                overflow: hidden;
                display: flex;
                flex-direction: column;
                resize: both;
                overflow: auto;
            }
            
            .orion-header {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(59, 130, 246, 0.25));
                padding: 14px 16px;
                border-bottom: 1px solid rgba(59, 130, 246, 0.3);
                display: flex;
                justify-content: space-between;
                align-items: center;
                position: relative;
                overflow: hidden;
                flex-shrink: 0;
                min-height: 60px;
            }
            
            .header-left {
                flex: 1;
                min-width: 0;
            }
            
            .app-title {
                font-size: 16px;
                font-weight: 900;
                background: linear-gradient(135deg, #3b82f6, #8b5cf6);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 2px;
                letter-spacing: 0.5px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .app-subtitle {
                font-size: 10px;
                color: #94a3b8;
                font-weight: 600;
                letter-spacing: 0.3px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .header-info {
                display: flex;
                gap: 6px;
                font-size: 10px;
                color: #94a3b8;
                flex-wrap: wrap;
                margin-top: 5px;
            }
            
            .header-info span {
                padding: 3px 8px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                white-space: nowrap;
                font-weight: 600;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            
            .header-controls {
                display: flex;
                gap: 5px;
                margin-left: 10px;
                flex-shrink: 0;
            }
            
            .control-btn {
                width: 28px;
                height: 28px;
                border-radius: 6px;
                background: rgba(30, 41, 59, 0.8);
                border: 1px solid rgba(59, 130, 246, 0.3);
                color: #3b82f6;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                transition: all 0.2s;
                font-weight: bold;
            }
            
            .control-btn:hover {
                background: rgba(59, 130, 246, 0.2);
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(59, 130, 246, 0.2);
            }
            
            .content {
                padding: 16px;
                overflow-y: auto;
                flex: 1;
                -webkit-overflow-scrolling: touch;
                background: rgba(15, 23, 42, 0.3);
                min-height: 0;
            }
            
            .currency-selector {
                margin-bottom: 14px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 10px;
                padding: 12px;
                border: 1px solid rgba(59, 130, 246, 0.25);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }
            
            .currency-row {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 12px;
                flex-wrap: wrap;
            }
            
            .currency-label {
                font-size: 11px;
                color: #cbd5e1;
                width: 80px;
                font-weight: 600;
                flex-shrink: 0;
            }
            
            .currency-dropdown {
                flex: 1;
                min-width: 120px;
                background: rgba(15, 23, 42, 0.95);
                border: 1px solid rgba(59, 130, 246, 0.4);
                border-radius: 8px;
                padding: 8px 12px;
                color: #fff;
                font-size: 12px;
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' fill='%233b82f6' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 12px center;
                padding-right: 35px;
                cursor: pointer;
                transition: all 0.2s;
                font-weight: 500;
            }
            
            .currency-dropdown:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            }
            
            .input-row {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
                flex-wrap: wrap;
            }
            
            .input-field {
                width: 100px;
                background: rgba(15, 23, 42, 0.95);
                border: 1px solid rgba(59, 130, 246, 0.4);
                border-radius: 6px;
                padding: 6px 10px;
                color: #fff;
                font-size: 12px;
                font-family: 'Courier New', monospace;
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                text-align: right;
                transition: all 0.2s;
                font-weight: 500;
            }
            
            .input-field:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
            }
            
            .unit {
                font-size: 10px;
                color: #94a3b8;
                margin-left: 6px;
                width: 30px;
                text-align: left;
                font-weight: 600;
                flex-shrink: 0;
            }
            
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-bottom: 16px;
            }
            
            .stat-card {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(30, 41, 59, 0.7));
                border-radius: 10px;
                padding: 12px;
                text-align: center;
                min-height: 65px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                border: 1px solid rgba(59, 130, 246, 0.15);
                transition: transform 0.2s;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .stat-card:hover {
                transform: translateY(-2px);
                border-color: rgba(59, 130, 246, 0.4);
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            }
            
            .stat-label {
                font-size: 10px;
                color: #94a3b8;
                text-transform: uppercase;
                margin-bottom: 5px;
                font-weight: 700;
                letter-spacing: 0.5px;
            }
            
            .stat-value {
                font-size: 13px;
                font-weight: 900;
                color: #fff;
                font-family: 'Courier New', monospace;
                word-break: break-all;
                line-height: 1.3;
            }
            
            .stat-value.small {
                font-size: 11px;
            }
            
            .mode-indicator {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(30, 41, 59, 0.7));
                border-radius: 10px;
                padding: 10px;
                text-align: center;
                margin-bottom: 16px;
                font-weight: 800;
                font-size: 13px;
                border: 1px solid rgba(59, 130, 246, 0.25);
                text-transform: uppercase;
                letter-spacing: 0.5px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            }
            
            .settings-section {
                background: rgba(30, 41, 59, 0.8);
                border-radius: 10px;
                padding: 14px;
                margin-bottom: 12px;
                border: 1px solid rgba(59, 130, 246, 0.2);
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .section-title {
                font-size: 12px;
                font-weight: 800;
                color: #3b82f6;
                margin-bottom: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 6px;
                border-bottom: 1px solid rgba(59, 130, 246, 0.3);
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .tabs {
                display: flex;
                gap: 8px;
                margin-bottom: 12px;
                background: rgba(15, 23, 42, 0.95);
                border-radius: 8px;
                padding: 4px;
                border: 1px solid rgba(59, 130, 246, 0.25);
                overflow-x: auto;
                scrollbar-width: none;
            }
            
            .tabs::-webkit-scrollbar {
                display: none;
            }
            
            .tab {
                flex: 1;
                min-width: 100px;
                padding: 10px;
                text-align: center;
                background: transparent;
                border: none;
                color: #94a3b8;
                font-size: 12px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 700;
                transition: all 0.2s;
                white-space: nowrap;
            }
            
            .tab:hover {
                background: rgba(59, 130, 246, 0.15);
            }
            
            .tab.active {
                background: linear-gradient(135deg, #3b82f6, #8b5cf6);
                color: white;
                box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
            }
            
            .tab-content {
                display: none;
            }
            
            .tab-content.active {
                display: block;
            }
            
            .input-label {
                font-size: 11px;
                color: #cbd5e1;
                width: 140px;
                font-weight: 600;
                flex-shrink: 0;
            }
            
            .checkbox-row {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 8px;
                padding: 4px 0;
            }
            
            .checkbox-label {
                font-size: 11px;
                color: #cbd5e1;
                cursor: pointer;
                font-weight: 500;
            }
            
            .control-buttons {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin: 18px 0;
            }
            
            .main-btn {
                padding: 14px;
                border: none;
                border-radius: 10px;
                font-size: 12px;
                font-weight: 800;
                cursor: pointer;
                text-transform: uppercase;
                transition: all 0.2s;
                letter-spacing: 0.5px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }
            
            .main-btn:hover {
                transform: translateY(-3px);
                box-shadow: 0 8px 12px rgba(0, 0, 0, 0.25);
            }
            
            .main-btn:active {
                transform: translateY(0);
            }
            
            .btn-start {
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
            }
            
            .btn-stop {
                background: linear-gradient(135deg, #ef4444, #dc2626);
                color: white;
            }
            
            .btn-pause {
                background: linear-gradient(135deg, #f59e0b, #d97706);
                color: white;
            }
            
            .live-log {
                background: rgba(15, 23, 42, 0.95);
                border-radius: 10px;
                padding: 12px;
                height: 150px;
                overflow-y: auto;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                border: 1px solid rgba(59, 130, 246, 0.25);
                box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            
            .log-entry {
                padding: 4px 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            }
            
            .demo-toggle {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 14px;
                padding: 10px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 10px;
                border: 1px solid rgba(59, 130, 246, 0.25);
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .switch {
                position: relative;
                display: inline-block;
                width: 40px;
                height: 20px;
                flex-shrink: 0;
            }
            
            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }
            
            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #4b5563;
                transition: .4s;
                border-radius: 20px;
            }
            
            .slider:before {
                position: absolute;
                content: "";
                height: 16px;
                width: 16px;
                left: 2px;
                bottom: 2px;
                background-color: white;
                transition: .4s;
                border-radius: 50%;
            }
            
            input:checked + .slider {
                background: linear-gradient(135deg, #10b981, #059669);
            }
            
            input:checked + .slider:before {
                transform: translateX(20px);
            }
            
            .demo-label {
                font-size: 12px;
                color: #94a3b8;
                font-weight: 700;
            }
            
            .demo-label.active {
                color: #10b981;
                text-shadow: 0 0 5px rgba(16, 185, 129, 0.3);
            }
            
            /* Recovery tab specific */
            .recovery-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            
            .recovery-card {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(30, 41, 59, 0.7));
                border-radius: 8px;
                padding: 12px;
                border: 1px solid rgba(245, 158, 11, 0.4);
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .recovery-title {
                font-size: 11px;
                color: #f59e0b;
                margin-bottom: 8px;
                font-weight: 800;
                text-align: center;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .recovery-input {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
            }
            
            .recovery-input input[type="number"] {
                width: 90px;
                background: rgba(15, 23, 42, 0.95);
                border: 1px solid rgba(245, 158, 11, 0.4);
                border-radius: 6px;
                padding: 6px 10px;
                color: #f59e0b;
                font-size: 11px;
                text-align: center;
                font-weight: 700;
                font-family: 'Courier New', monospace;
            }
            
            .recovery-input input[type="checkbox"] {
                width: 18px;
                height: 18px;
                accent-color: #f59e0b;
            }
            
            .recovery-input input:focus {
                outline: none;
                border-color: #f59e0b;
                box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.3);
            }
            
            .recovery-unit {
                font-size: 10px;
                color: #fbbf24;
                font-weight: 700;
                width: 20px;
            }
            
            /* Mobile optimizations */
            @media (max-width: 768px) {
                #orion-wrap {
                    width: 380px;
                    right: 10px;
                    top: 10px;
                    max-width: calc(100vw - 20px);
                    max-height: calc(100vh - 20px);
                }
                
                .content {
                    padding: 12px;
                }
                
                .stats-grid {
                    grid-template-columns: repeat(2, 1fr);
                    gap: 8px;
                }
                
                .control-buttons {
                    grid-template-columns: repeat(3, 1fr);
                    gap: 8px;
                }
                
                .main-btn {
                    padding: 12px;
                    font-size: 11px;
                }
                
                .recovery-grid {
                    grid-template-columns: 1fr;
                    gap: 10px;
                }
                
                .tabs {
                    flex-wrap: nowrap;
                    overflow-x: auto;
                }
                
                .tab {
                    min-width: 90px;
                    padding: 8px;
                    font-size: 11px;
                }
            }
            
            @media (max-width: 480px) {
                #orion-wrap {
                    width: 350px;
                    max-width: calc(100vw - 20px);
                }
                
                .orion-header {
                    flex-direction: column;
                    align-items: stretch;
                    padding: 12px;
                }
                
                .header-left {
                    margin-bottom: 10px;
                }
                
                .header-info {
                    justify-content: center;
                }
                
                .header-controls {
                    margin-left: 0;
                    justify-content: center;
                }
                
                .currency-row {
                    flex-direction: column;
                    align-items: stretch;
                }
                
                .currency-label {
                    width: 100%;
                    margin-bottom: 5px;
                }
                
                .input-row {
                    flex-direction: column;
                    align-items: stretch;
                }
                
                .input-label {
                    width: 100%;
                    margin-bottom: 5px;
                }
                
                .input-field {
                    width: 100%;
                }
                
                .control-buttons {
                    grid-template-columns: 1fr;
                }
            }
            
            /* Scrollbar styling */
            .content::-webkit-scrollbar {
                width: 6px;
            }
            
            .content::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.08);
                border-radius: 3px;
            }
            
            .content::-webkit-scrollbar-thumb {
                background: rgba(59, 130, 246, 0.6);
                border-radius: 3px;
            }
            
            .content::-webkit-scrollbar-thumb:hover {
                background: rgba(59, 130, 246, 0.8);
            }
            
            .live-log::-webkit-scrollbar {
                width: 5px;
            }
            
            .live-log::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.08);
            }
            
            .live-log::-webkit-scrollbar-thumb {
                background: rgba(59, 130, 246, 0.6);
                border-radius: 3px;
            }
            
            /* Resize handle */
            #orion-wrap::after {
                content: '';
                position: absolute;
                bottom: 0;
                right: 0;
                width: 15px;
                height: 15px;
                background: linear-gradient(135deg, transparent 50%, rgba(59, 130, 246, 0.3) 50%);
                cursor: se-resize;
                z-index: 1000;
            }
        `;
        document.head.appendChild(s);

        const d = document.createElement("div");
        d.id = "orion-wrap";
        d.innerHTML = `
            <div class="orion-header">
                <div class="header-left">
                    <div class="app-title">üöÄ ORION WAGER BOT</div>
                    <div class="app-subtitle">Advanced Wagering System v2.0</div>
                    <div class="header-info">
                        <span id="account-name">${bot.stakeUser}</span>
                        <span id="license-status">${CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED"}</span>
                        <span id="currency-display">Loading...</span>
                    </div>
                </div>
                <div class="header-controls">
                    <button class="control-btn sync" title="Sync">‚Üª</button>
                    <button class="control-btn minimize" title="Minimize">_</button>
                    <button class="control-btn close" title="Close">√ó</button>
                </div>
            </div>
            
            <div class="content">
                <!-- Demo Mode Toggle -->
                <div class="demo-toggle">
                    <label class="switch">
                        <input type="checkbox" id="demo-toggle">
                        <span class="slider"></span>
                    </label>
                    <span id="demo-label" class="demo-label ${bot.isDemo ? 'active' : ''}">
                        ${bot.isDemo ? 'üîÑ DEMO MODE' : 'üí∞ REAL MODE'}
                    </span>
                </div>
                
                <!-- Currency Selector -->
                <div class="currency-selector">
                    <div class="currency-row">
                        <span class="currency-label">üåê Currency</span>
                        <select id="currency-select" class="currency-dropdown">
                            <option value="loading">Loading currencies...</option>
                        </select>
                    </div>
                    <div class="currency-row">
                        <span class="currency-label">‚ö° Min Bet</span>
                        <input type="number" id="min-bet-input" class="input-field" value="${bot.globalMinBet}" step="0.00000001" min="0.00000001">
                        <span class="unit" id="min-bet-unit">DOGE</span>
                    </div>
                </div>
                
                <!-- Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Balance</div>
                        <div class="stat-value" id="balance">0.00000000</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Profit</div>
                        <div class="stat-value" id="profit">0.00000000</div>
                        <div class="stat-label" id="profit-percent">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Wagered</div>
                        <div class="stat-value small" id="wagered">0.00000000</div>
                        <div class="stat-label" id="wagered-percent">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Bets</div>
                        <div class="stat-value" id="bets">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value small" id="win-rate">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Avg Bet</div>
                        <div class="stat-value small" id="avg-bet">0.00000000</div>
                    </div>
                </div>
                
                <!-- Mode Indicator -->
                <div class="mode-indicator" id="mode-indicator">
                    <span class="orion-star">‚ú¶</span> 
                    <span id="mode-text">STOPPED</span>
                    <span class="orion-star">‚ú¶</span>
                </div>
                
                <!-- Settings Tabs -->
                <div class="tabs">
                    <button class="tab active" data-tab="wager">üéØ Wager</button>
                    <button class="tab" data-tab="martingale">üìà Martingale</button>
                    <button class="tab" data-tab="recovery">üîÑ Recovery</button>
                </div>
                
                <!-- Wager Settings -->
                <div id="wager-tab" class="tab-content active">
                    <div class="settings-section">
                        <div class="section-title">üé≤ Dice Settings</div>
                        <div class="input-row">
                            <span class="input-label">Base Bet %</span>
                            <input type="number" id="dice-bet-percent" class="input-field" value="1.0" step="0.1" min="0.1" max="20">
                            <span class="unit">%</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Chance %</span>
                            <input type="number" id="dice-chance" class="input-field" value="99.5" step="0.01" min="1" max="99.99">
                            <span class="unit">%</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Bets per Cycle</span>
                            <input type="number" id="dice-bets" class="input-field" value="10" step="1" min="1" max="100">
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <div class="section-title">üìà Limbo Settings</div>
                        <div class="input-row">
                            <span class="input-label">Base Bet %</span>
                            <input type="number" id="limbo-bet-percent" class="input-field" value="0.5" step="0.1" min="0.1" max="20">
                            <span class="unit">%</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Multiplier</span>
                            <input type="number" id="limbo-multiplier" class="input-field" value="1.001" step="0.001" min="1.001" max="1000">
                            <span class="unit">x</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Bets per Cycle</span>
                            <input type="number" id="limbo-bets" class="input-field" value="50" step="1" min="1" max="100">
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <div class="section-title">‚ö†Ô∏è Stop Loss</div>
                        <div class="input-row">
                            <span class="input-label">Stop Loss %</span>
                            <input type="number" id="wager-stop-loss" class="input-field" value="2.0" step="0.1" min="0.1" max="10">
                            <span class="unit">%</span>
                        </div>
                    </div>
                </div>
                
                <!-- Martingale Settings -->
                <div id="martingale-tab" class="tab-content">
                    <div class="settings-section">
                        <div class="section-title">üéõÔ∏è Martingale Settings</div>
                        <div class="input-row">
                            <span class="input-label">Multi on Loss</span>
                            <input type="number" id="multi-on-loss" class="input-field" value="2.0" step="0.1" min="1" max="10">
                            <span class="unit">x</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Multi on Win</span>
                            <input type="number" id="multi-on-win" class="input-field" value="1.0" step="0.1" min="0.1" max="10">
                            <span class="unit">x</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Loss Streak for Multi</span>
                            <input type="number" id="loss-streak-multi" class="input-field" value="3" step="1" min="1" max="20">
                        </div>
                        <div class="input-row">
                            <span class="input-label">Multi After Streak</span>
                            <input type="number" id="multi-after-loss" class="input-field" value="2.5" step="0.1" min="1" max="10">
                            <span class="unit">x</span>
                        </div>
                        <div class="checkbox-row">
                            <input type="checkbox" id="reset-on-win" checked>
                            <span class="checkbox-label">Reset Martingale on Win</span>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <div class="section-title">üõ°Ô∏è Safety Limits</div>
                        <div class="input-row">
                            <span class="input-label">Max Multiplier</span>
                            <input type="number" id="max-multiplier" class="input-field" value="100" step="1" min="1" max="1000">
                            <span class="unit">x</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Max Bet %</span>
                            <input type="number" id="max-bet-percent" class="input-field" value="10" step="0.1" min="0.1" max="50">
                            <span class="unit">%</span>
                        </div>
                        <div class="input-row">
                            <span class="input-label">Stop After Losses</span>
                            <input type="number" id="stop-after-losses" class="input-field" value="10" step="1" min="1" max="50">
                            <span class="unit">losses</span>
                        </div>
                    </div>
                </div>
                
                <!-- Recovery Settings -->
                <div id="recovery-tab" class="tab-content">
                    <div class="recovery-grid">
                        <div class="recovery-card">
                            <div class="recovery-title">Recovery Chance</div>
                            <div class="recovery-input">
                                <input type="number" id="recovery-chance" value="95" step="1" min="50" max="99.5">
                                <span class="recovery-unit">%</span>
                            </div>
                        </div>
                        
                        <div class="recovery-card">
                            <div class="recovery-title">Multi on Loss</div>
                            <div class="recovery-input">
                                <input type="number" id="recovery-multiplier" value="2.5" step="0.1" min="1" max="10">
                                <span class="recovery-unit">x</span>
                            </div>
                        </div>
                        
                        <div class="recovery-card">
                            <div class="recovery-title">Multi After Loss Streak</div>
                            <div class="recovery-input">
                                <input type="number" id="recovery-multi-after-loss" value="3.0" step="0.1" min="1" max="10">
                                <span class="recovery-unit">x</span>
                            </div>
                        </div>
                        
                        <div class="recovery-card">
                            <div class="recovery-title">Loss Streak for Multi</div>
                            <div class="recovery-input">
                                <input type="number" id="recovery-loss-streak" value="2" step="1" min="1" max="10">
                            </div>
                        </div>
                        
                        <div class="recovery-card">
                            <div class="recovery-title">Multi After Win Streak</div>
                            <div class="recovery-input">
                                <input type="number" id="recovery-multi-after-win" value="0.7" step="0.1" min="0.1" max="5">
                                <span class="recovery-unit">x</span>
                            </div>
                        </div>
                        
                        <div class="recovery-card">
                            <div class="recovery-title">Win Streak for Multi</div>
                            <div class="recovery-input">
                                <input type="number" id="recovery-win-streak" value="2" step="1" min="1" max="10">
                            </div>
                        </div>
                        
                        <div class="recovery-card">
                            <div class="recovery-title">Reset Base After Losses</div>
                            <div class="recovery-input">
                                <input type="number" id="recovery-reset-base" value="3" step="1" min="1" max="10">
                            </div>
                        </div>
                        
                        <div class="recovery-card">
                            <div class="recovery-title">Reset on Win</div>
                            <div class="recovery-input">
                                <input type="checkbox" id="recovery-reset-win" checked>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Control Buttons -->
                <div class="control-buttons">
                    <button id="p-start" class="main-btn btn-start">‚ñ∂ START</button>
                    <button id="p-pause" class="main-btn btn-pause">‚è∏ PAUSE</button>
                    <button id="p-stop" class="main-btn btn-stop">‚èπ STOP</button>
                </div>
                
                <!-- Live Log -->
                <div class="section-title" style="margin-top: 15px; margin-bottom: 8px;">üìä ORION LIVE LOG</div>
                <div class="live-log" id="live-log">
                    <div style="color: #94a3b8; text-align: center; padding: 20px; font-size: 11px;">
                        <div style="margin-bottom: 10px; color: #3b82f6; font-weight: bold;">üöÄ ORION WAGER BOT READY</div>
                        <div style="font-size: 10px;">Waiting for wager commands...</div>
                    </div>
                </div>
            </div>
            
            <div id="p-logs" style="display: none;"></div>
        `;
        document.body.appendChild(d);

        setupEventListeners();
        setupTabs();
        updateUI();
        
        // Make resizable
        makeResizable();
        
        setTimeout(() => {
            API.syncOnce();
        }, 1500);
    }

    function makeResizable() {
        const element = document.getElementById('orion-wrap');
        const resizer = document.createElement('div');
        resizer.style.cssText = `
            position: absolute;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            cursor: se-resize;
            z-index: 1000;
        `;
        element.appendChild(resizer);
        
        resizer.addEventListener('mousedown', initResize, false);
        
        function initResize(e) {
            e.preventDefault();
            window.addEventListener('mousemove', resize, false);
            window.addEventListener('mouseup', stopResize, false);
        }
        
        function resize(e) {
            const width = e.clientX - element.getBoundingClientRect().left;
            const height = e.clientY - element.getBoundingClientRect().top;
            
            if (width > 320) element.style.width = width + 'px';
            if (height > 400) element.style.height = height + 'px';
        }
        
        function stopResize() {
            window.removeEventListener('mousemove', resize, false);
            window.removeEventListener('mouseup', stopResize, false);
        }
    }

    function setupTabs() {
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                tabContents.forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });
    }

    function setupEventListeners() {
        // Demo toggle
        const demoToggle = document.getElementById('demo-toggle');
        const demoLabel = document.getElementById('demo-label');
        
        if (demoToggle) {
            demoToggle.checked = bot.isDemo;
            demoToggle.addEventListener('change', function() {
                bot.isDemo = this.checked;
                demoLabel.textContent = bot.isDemo ? 'üîÑ DEMO MODE' : 'üí∞ REAL MODE';
                demoLabel.classList.toggle('active', bot.isDemo);
                updateLogs(`Switched to ${bot.isDemo ? 'DEMO' : 'REAL'} mode`, true);
            });
        }

        // Currency selector
        const currencySelect = document.getElementById('currency-select');
        if (currencySelect) {
            currencySelect.addEventListener('change', function() {
                bot.selectedCurrency = this.value;
                const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
                updateLogs(`Currency changed to: ${currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase()}`, true);
                updateUI();
            });
        }

        // Min Bet Input
        const minBetInput = document.getElementById('min-bet-input');
        if (minBetInput) {
            minBetInput.addEventListener('change', function() {
                const value = parseFloat(this.value);
                if (!isNaN(value) && value > 0) {
                    bot.globalMinBet = value;
                    updateLogs(`Min bet set to: ${value.toFixed(8)}`, true);
                } else {
                    this.value = bot.globalMinBet;
                }
            });
        }

        // Sync button
        const syncBtn = document.querySelector('.control-btn.sync');
        if (syncBtn) {
            syncBtn.addEventListener('click', async () => {
                updateLogs("üîç ORION: Syncing account and currencies...", true);
                await API.syncOnce();
                updateDashboard();
                updateLogs("‚úÖ ORION: Sync complete!", true);
            });
        }

        // Minimize button
        const minimizeBtn = document.querySelector('.control-btn.minimize');
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', () => {
                const content = document.querySelector('.content');
                const wrap = document.getElementById('orion-wrap');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    minimizeBtn.textContent = '_';
                    wrap.style.height = 'auto';
                    wrap.style.minHeight = '400px';
                } else {
                    content.style.display = 'none';
                    minimizeBtn.textContent = '‚ñ°';
                    wrap.style.height = 'auto';
                    wrap.style.minHeight = '60px';
                }
            });
        }

        // Close button
        const closeBtn = document.querySelector('.control-btn.close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                if (bot.isRunning) {
                    if (confirm("ORION Bot is running. Close anyway?")) {
                        document.getElementById("orion-wrap").remove();
                    }
                } else {
                    document.getElementById("orion-wrap").remove();
                }
            });
        }

        // =============== WAGER SETTINGS EVENT LISTENERS ===============
        const wagerInputs = [
            { id: 'dice-bet-percent', property: 'wagerMode.diceBetPercent', min: 0.1, max: 20 },
            { id: 'dice-chance', property: 'wagerMode.diceChance', min: 1, max: 99.99 },
            { id: 'limbo-bet-percent', property: 'wagerMode.limboBetPercent', min: 0.1, max: 20 },
            { id: 'limbo-multiplier', property: 'wagerMode.limboMultiplier', min: 1.001, max: 1000 },
            { id: 'wager-stop-loss', property: 'wagerMode.stopLossPercent', min: 0.1, max: 10 },
            { id: 'dice-bets', property: 'wagerMode.diceBetsPerCycle', min: 1, max: 100 },
            { id: 'limbo-bets', property: 'wagerMode.limboBetsPerCycle', min: 1, max: 100 }
        ];

        wagerInputs.forEach(input => {
            const el = document.getElementById(input.id);
            if (el) {
                el.addEventListener('change', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value)) {
                        if ((!input.min || value >= input.min) && (!input.max || value <= input.max)) {
                            const props = input.property.split('.');
                            if (props.length === 2) {
                                bot[props[0]][props[1]] = value;
                            }
                            updateLogs(`‚öôÔ∏è ${input.id}: ${value}`, true);
                        } else {
                            // Reset to default if invalid
                            const defaultValue = getDefaultValue(input.property);
                            e.target.value = defaultValue;
                            updateLogs(`‚ö†Ô∏è ${input.id} reset to default: ${defaultValue}`, true);
                        }
                    }
                });
            }
        });

        // =============== MARTINGALE SETTINGS EVENT LISTENERS ===============
        const martingaleInputs = [
            { id: 'multi-on-loss', property: 'smartMartingale.multiplierOnLoss', min: 1, max: 10 },
            { id: 'multi-on-win', property: 'smartMartingale.multiplierOnWin', min: 0.1, max: 10 },
            { id: 'loss-streak-multi', property: 'smartMartingale.lossStreakForMulti', min: 1, max: 20 },
            { id: 'multi-after-loss', property: 'smartMartingale.multiAfterLossStreak', min: 1, max: 10 },
            { id: 'max-multiplier', property: 'smartMartingale.maxMultiplier', min: 1, max: 1000 },
            { id: 'max-bet-percent', property: 'smartMartingale.maxBetPercent', min: 0.1, max: 50 },
            { id: 'stop-after-losses', property: 'smartMartingale.stopAfterLosses', min: 1, max: 50 }
        ];

        martingaleInputs.forEach(input => {
            const el = document.getElementById(input.id);
            if (el) {
                el.addEventListener('change', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value)) {
                        if ((!input.min || value >= input.min) && (!input.max || value <= input.max)) {
                            const props = input.property.split('.');
                            if (props.length === 2) {
                                bot[props[0]][props[1]] = value;
                            }
                            updateLogs(`‚öôÔ∏è ${input.id}: ${value}`, true);
                        } else {
                            const defaultValue = getDefaultValue(input.property);
                            e.target.value = defaultValue;
                            updateLogs(`‚ö†Ô∏è ${input.id} reset to default: ${defaultValue}`, true);
                        }
                    }
                });
            }
        });

        // =============== RECOVERY SETTINGS EVENT LISTENERS ===============
        const recoveryInputs = [
            { id: 'recovery-chance', property: 'smartMartingale.recoveryChance', min: 50, max: 99.5 },
            { id: 'recovery-multiplier', property: 'smartMartingale.recoveryMultiplierOnLoss', min: 1, max: 10 },
            { id: 'recovery-multi-after-loss', property: 'smartMartingale.recoveryMultiAfterLossStreak', min: 1, max: 10 },
            { id: 'recovery-loss-streak', property: 'smartMartingale.recoveryLossStreakForMulti', min: 1, max: 10 },
            { id: 'recovery-multi-after-win', property: 'smartMartingale.recoveryMultiAfterWinStreak', min: 0.1, max: 5 },
            { id: 'recovery-win-streak', property: 'smartMartingale.recoveryWinStreakForMulti', min: 1, max: 10 },
            { id: 'recovery-reset-base', property: 'smartMartingale.recoveryResetBaseAfterLosses', min: 1, max: 10 }
        ];

        recoveryInputs.forEach(input => {
            const el = document.getElementById(input.id);
            if (el) {
                el.addEventListener('change', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value)) {
                        if ((!input.min || value >= input.min) && (!input.max || value <= input.max)) {
                            const props = input.property.split('.');
                            if (props.length === 2) {
                                bot[props[0]][props[1]] = value;
                            }
                            updateLogs(`‚öôÔ∏è Recovery ${input.id}: ${value}`, true);
                        } else {
                            const defaultValue = getDefaultValue(input.property);
                            e.target.value = defaultValue;
                            updateLogs(`‚ö†Ô∏è Recovery ${input.id} reset to default: ${defaultValue}`, true);
                        }
                    }
                });
            }
        });

        // Checkbox listeners
        const resetOnWin = document.getElementById('reset-on-win');
        if (resetOnWin) {
            resetOnWin.addEventListener('change', (e) => {
                bot.smartMartingale.resetOnWin = e.target.checked;
                updateLogs(`üîÑ Reset on win: ${e.target.checked ? 'ON' : 'OFF'}`, true);
            });
        }

        const recoveryResetWin = document.getElementById('recovery-reset-win');
        if (recoveryResetWin) {
            recoveryResetWin.addEventListener('change', (e) => {
                bot.smartMartingale.recoveryResetOnWin = e.target.checked;
                updateLogs(`üîÑ Recovery reset on win: ${e.target.checked ? 'ON' : 'OFF'}`, true);
            });
        }

        // Helper function to get default values
        function getDefaultValue(propertyPath) {
            const props = propertyPath.split('.');
            let value = bot;
            
            for (const prop of props) {
                if (value && value[prop] !== undefined) {
                    value = value[prop];
                } else {
                    return 0;
                }
            }
            
            return value;
        }

        // Start Button
        const pStart = document.getElementById("p-start");
        if (pStart) {
            pStart.onclick = async () => {
                if (bot.isRunning) return;

                if (!CONFIG.license.isValid() && !bot.isDemo) {
                    alert(`üö´ ORION License expired! Renew please.`);
                    return;
                }

                if (bot.isDemo) {
                    const demoBalanceInput = prompt("Enter Demo Starting Balance:", bot.demoBalance);
                    if (demoBalanceInput !== null) {
                        const demoBal = parseFloat(demoBalanceInput);
                        if (!isNaN(demoBal) && demoBal >= bot.globalMinBet) {
                            bot.demoBalance = demoBal;
                            updateLogs(`üíæ Demo balance set to: ${demoBal.toFixed(8)}`, true);
                        } else {
                            alert(`Please enter a valid amount (min: ${bot.globalMinBet})`);
                            return;
                        }
                    }
                } else {
                    try {
                        await API.syncOnce();
                        if (bot.stakeUser === "Not logged in" || bot.stakeUser === "API Error") {
                            alert("üîë Please login to Stake first!");
                            return;
                        }
                        
                        bot.realBalance = await API.getBalance(bot.selectedCurrency);
                        if (bot.realBalance <= 0) {
                            alert(`üí∞ Insufficient ${bot.selectedCurrency.toUpperCase()} balance!`);
                            return;
                        }
                        
                    } catch (e) {
                        alert(`‚ö†Ô∏è Sync error: ${e.message}`);
                        return;
                    }
                }

                bot.isRunning = true;
                bot.isPaused = false;

                // Reset stats
                bot.stats = {
                    profit: 0,
                    wagered: 0,
                    startBal: 0,
                    currentBal: 0,
                    peakBalance: 0,
                    maxDrawdown: 0,
                    drawdownPercentage: 0,
                    bets: 0,
                    wins: 0,
                    loss: 0,
                    startTime: Date.now(),
                    lastBetAmount: 0,
                    lastResults: [],
                    winStreak: 0,
                    lossStreak: 0,
                    maxWinStreak: 0,
                    maxLossStreak: 0,
                    consecutiveLosses: 0,
                    consecutiveWins: 0,
                    winRate: 0,
                    wageredPercent: 0,
                    avgBetSize: 0
                };

                // Set starting balance
                if (bot.isDemo) {
                    bot.stats.startBal = bot.demoBalance;
                    bot.stats.currentBal = bot.demoBalance;
                    bot.stats.peakBalance = bot.demoBalance;
                } else {
                    bot.stats.startBal = bot.realBalance;
                    bot.stats.currentBal = bot.realBalance;
                    bot.stats.peakBalance = bot.realBalance;
                }

                // Get latest settings from UI
                getWagerSettingsFromUI();
                
                // Reset martingale
                bot.smartMartingale.currentMultiplier = 1;
                bot.smartMartingale.recoveryMode = false;
                bot.wagerMode.active = true;

                initWagerMode();

                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStart) {
                    TelegramAPI.sendStartReport();
                }

                updateUI();
                updateLogs(`üöÄ ORION BOT STARTED! (${bot.isDemo ? 'Demo' : 'Real'} mode)`, true);

                setTimeout(() => {
                    runLoop();
                }, 100);
            };
        }

        // Stop Button
        const pStop = document.getElementById("p-stop");
        if (pStop) {
            pStop.onclick = () => {
                bot.isRunning = false;
                bot.isPaused = false;
                
                updateLogs("üõë ORION Bot stopped", true);
                updateUI();
                
                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStop) {
                    TelegramAPI.sendStopReport("Manual Stop");
                }
            };
        }

        // Pause Button
        const pPause = document.getElementById("p-pause");
        if (pPause) {
            pPause.onclick = () => {
                if (!bot.isRunning) return;
                bot.isPaused = !bot.isPaused;
                
                if (bot.isPaused) {
                    pPause.textContent = "‚ñ∂ RESUME";
                    updateLogs("‚è∏ ORION Bot paused", true);
                } else {
                    pPause.textContent = "‚è∏ PAUSE";
                    updateLogs("‚ñ∂ ORION Bot resumed", true);
                    setTimeout(() => {
                        runLoop();
                    }, 100);
                }
                updateUI();
            };
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                document.getElementById('p-start').click();
            }
            if (e.ctrlKey && e.key === 'x') {
                e.preventDefault();
                document.getElementById('p-stop').click();
            }
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                document.getElementById('p-pause').click();
            }
        });
    }

    createUI();
})();
