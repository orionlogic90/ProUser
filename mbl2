(function () {
    const CONFIG = {
        get apiUrl() { return window.location.origin + '/_api'; },
        version: "ORION WAGER BOT v2.0",
        license: {
            type: "PREMIUM",
            expiryDate: new Date("2026-02-26"),
            isValid: function() {
                return new Date() <= this.expiryDate;
            }
        },
        telegram: {
            enabled: true,
            botToken: '8391763291:AAGdi0yiVDwm0xZvq4UaJzMyy6_kaN0Zerc',
            chatId: '-1003744641395',
            sendOnStart: true,
            sendOnStop: true,
            sendOnRecovery: true
        }
    };

    const bot = {
        isRunning: false,
        isPaused: false,
        isDemo: false,
        demoBalance: 1000.0,
        token: null,
        stakeUser: "Loading...",
        selectedCurrency: "doge",
        globalMinBet: 0.00000001,
        realBalance: 0,
        availableCurrencies: [],
        
        stats: {
            profit: 0,
            wagered: 0,
            startBal: 0,
            currentBal: 0,
            peakBalance: 0,
            maxDrawdown: 0,
            drawdownPercentage: 0,
            bets: 0,
            wins: 0,
            loss: 0,
            startTime: null,
            lastBetAmount: 0,
            lastResults: [],
            winStreak: 0,
            lossStreak: 0,
            maxWinStreak: 0,
            maxLossStreak: 0,
            consecutiveLosses: 0,
            consecutiveWins: 0,
            winRate: 0,
            wageredPercent: 0,
            avgBetSize: 0
        },
        
        wagerMode: {
            active: true,
            diceBetPercent: 1.0,
            diceChance: 99.5,
            dicePayout: 0,
            limboBetPercent: 0.5,
            limboMultiplier: 1.001,
            limboPayout: 0,
            diceBetsPerCycle: 10,
            limboBetsPerCycle: 50,
            currentMode: 'dice',
            diceBetCount: 0,
            limboBetCount: 0,
            stopLossPercent: 2.0,
            startBalance: 0,
            lossTriggered: false
        },
        
        recoveryMode: {
            active: false,
            chance: 95.0,
            recoveryStartBalance: 0,
            recoveryLossAmount: 0,
            consecutiveLossesForAggressive: 3,
            betMultiplier: 2.0,
            maxBetPercent: 50.0
        }
    };

    // =============== TELEGRAM FUNCTIONS ===============
    const TelegramAPI = {
        async sendMessage(text, parse_mode = "HTML") {
            if (!CONFIG.telegram?.enabled) return;
            try {
                const url = `https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`;
                const params = {
                    chat_id: CONFIG.telegram.chatId,
                    text: text,
                    parse_mode: parse_mode,
                    disable_web_page_preview: true
                };
                await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(params)
                });
            } catch (error) {
                console.error("Telegram error:", error);
            }
        },

        async sendStartReport() {
            if (!CONFIG.telegram.sendOnStart) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `üöÄ <b>ORION WAGER BOT STARTED</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `üí∞ Balance: <code>${bot.stats.startBal.toFixed(8)} ${currencyName}</code>\n` +
                `‚ö° Min Bet: <code>${bot.globalMinBet.toFixed(8)}</code>\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendStopReport(reason = "Manual Stop") {
            if (!CONFIG.telegram.sendOnStop) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            
            const profitPercent = bot.stats.startBal > 0 
                ? ((bot.stats.profit / bot.stats.startBal) * 100) 
                : 0;
            
            const winRate = bot.stats.bets > 0 
                ? ((bot.stats.wins / bot.stats.bets) * 100) 
                : 0;
            
            const wageredPercent = bot.stats.startBal > 0
                ? ((bot.stats.wagered / bot.stats.startBal) * 100)
                : 0;
            
            const message = `üõë <b>ORION BOT STOPPED</b>\n` +
                `üìù Reason: <b>${reason}</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `‚è±Ô∏è Runtime: <code>${hours}h ${minutes}m</code>\n` +
                `üéØ Bets: <code>${bot.stats.bets}</code>\n` +
                `üìà Win Rate: <code>${winRate.toFixed(2)}%</code>\n` +
                `üí∞ Start: <code>${bot.stats.startBal.toFixed(8)} ${currencyName}</code>\n` +
                `üí∞ End: <code>${bot.stats.currentBal.toFixed(8)} ${currencyName}</code>\n` +
                `üìà Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} ${currencyName}</code>\n` +
                `üìà %: <code>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</code>\n` +
                `üí∏ Wagered: <code>${bot.stats.wagered.toFixed(8)} ${currencyName}</code>\n` +
                `üìä Wagered %: <code>${wageredPercent.toFixed(2)}%</code>\n` +
                `‚ö° Min Bet: <code>${bot.globalMinBet.toFixed(8)}</code>\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendRecoveryTrigger(lossAmount, lossPercent) {
            if (!CONFIG.telegram.sendOnRecovery) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `‚ö†Ô∏è <b>ORION RECOVERY MODE TRIGGERED</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `üìâ Loss Amount: <code>${lossAmount.toFixed(8)} ${currencyName}</code>\n` +
                `üìâ Loss %: <code>${lossPercent.toFixed(2)}%</code>\n` +
                `üí∞ Current Balance: <code>${bot.stats.currentBal.toFixed(8)}</code>\n` +
                `üîÑ Switching to Recovery Mode\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendRecoveryComplete() {
            if (!CONFIG.telegram.sendOnRecovery) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `‚úÖ <b>ORION RECOVERY COMPLETE</b>\n` +
                `üë§ User: <code>${bot.stakeUser}</code>\n` +
                `üí∞ Currency: <code>${currencyName}</code>\n` +
                `üí∞ Recovered to: <code>${bot.stats.currentBal.toFixed(8)} ${currencyName}</code>\n` +
                `üîÑ Returning to Wager Mode\n` +
                `‚è∞ ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        }
    };

    // =============== CURRENCY FUNCTIONS ===============
    async function syncCurrenciesFromServer() {
        try {
            if (!bot.token) {
                updateLogs("No token found, trying to sync...", true);
                return getDefaultCurrencies();
            }
            
            const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${bot.token}`,
                    "x-access-token": bot.token,
                    "x-csrf-token": bot.token
                },
                body: JSON.stringify({
                    query: `query {
                        user {
                            balances {
                                available {
                                    amount
                                    currency
                                }
                            }
                        }
                    }`
                })
            });
            
            if (!res.ok) {
                updateLogs(`‚ö†Ô∏è API responded with status: ${res.status}`, true);
                return getDefaultCurrencies();
            }
            
            const json = await res.json();
            
            if (json?.errors) {
                updateLogs(`‚ö†Ô∏è GraphQL error: ${json.errors[0]?.message}`, true);
                return getDefaultCurrencies();
            }
            
            if (!json?.data?.user?.balances) {
                updateLogs("‚ö†Ô∏è No balances data found in response", true);
                return getDefaultCurrencies();
            }
            
            const currenciesSet = new Set();
            const currencies = [];
            
            json.data.user.balances.forEach(balance => {
                if (balance.available && balance.available.currency) {
                    const currencyCode = balance.available.currency.toLowerCase();
                    if (!currenciesSet.has(currencyCode)) {
                        currenciesSet.add(currencyCode);
                        
                        currencies.push({
                            code: currencyCode,
                            name: balance.available.currency.toUpperCase(),
                            icon: getCurrencyIcon(currencyCode),
                            balance: parseFloat(balance.available.amount) || 0
                        });
                    }
                }
            });
            
            if (currencies.length === 0) {
                updateLogs("‚ö†Ô∏è No currencies found, using defaults", true);
                return getDefaultCurrencies();
            }
            
            bot.availableCurrencies = currencies;
            
            // Auto-select first currency with balance > 0, or first available
            if (!currencies.find(c => c.code === bot.selectedCurrency)) {
                const currencyWithBalance = currencies.find(c => c.balance > 0) || currencies[0];
                bot.selectedCurrency = currencyWithBalance.code;
            }
            
            updateLogs(`‚úÖ Synced ${currencies.length} currencies from server`, true);
            return currencies;
            
        } catch (e) {
            updateLogs(`‚ö†Ô∏è Failed to sync currencies: ${e.message}`, true);
            return getDefaultCurrencies();
        }
    }

    function getDefaultCurrencies() {
        return [
            { code: "doge", name: "DOGE", icon: "üêï", balance: 0 },
            { code: "btc", name: "BTC", icon: "‚Çø", balance: 0 },
            { code: "eth", name: "ETH", icon: "Œû", balance: 0 },
            { code: "ltc", name: "LTC", icon: "≈Å", balance: 0 },
            { code: "xrp", name: "XRP", icon: "‚úï", balance: 0 },
            { code: "ada", name: "ADA", icon: "A", balance: 0 },
            { code: "trx", name: "TRX", icon: "T", balance: 0 },
            { code: "usdt", name: "USDT", icon: "üíµ", balance: 0 },
            { code: "usdc", name: "USDC", icon: "üí≤", balance: 0 },
            { code: "sol", name: "SOL", icon: "‚óé", balance: 0 },
            { code: "matic", name: "MATIC", icon: "‚¨°", balance: 0 },
            { code: "bnb", name: "BNB", icon: "‚õìÔ∏è", balance: 0 },
            { code: "shib", name: "SHIB", icon: "üêï", balance: 0 }
        ];
    }

    function getCurrencyIcon(currencyCode) {
        const icons = {
            'doge': 'üêï', 'btc': '‚Çø', 'eth': 'Œû', 'ltc': '≈Å', 'xrp': '‚úï', 'ada': 'A',
            'trx': 'T', 'usdt': 'üíµ', 'usdc': 'üí≤', 'sol': '‚óé', 'matic': '‚¨°',
            'bnb': '‚õìÔ∏è', 'shib': 'üêï', 'xlm': '‚òÖ', 'algo': 'Œë', 'dot': '‚óè',
            'avax': '‚ùÑÔ∏è', 'link': 'üîó', 'uni': 'ü¶Ñ', 'aave': 'üëª', 'comp': 'ü¶Ñ',
            'yfi': 'üè¶', 'snx': '‚ö°', 'mkr': 'üè≠', 'bat': 'ü¶á', 'zrx': '0x'
        };
        
        return icons[currencyCode] || 'üí∞';
    }

    // =============== WAGER MODE LOGIC ===============
    function initWagerMode() {
        const diceBetPercentInput = document.getElementById("dice-bet-percent");
        const diceChanceInput = document.getElementById("dice-chance");
        const limboBetPercentInput = document.getElementById("limbo-bet-percent");
        const limboMultiplierInput = document.getElementById("limbo-multiplier");
        const diceBetsInput = document.getElementById("dice-bets");
        const limboBetsInput = document.getElementById("limbo-bets");
        const stopLossInput = document.getElementById("wager-stop-loss");
        
        if (diceBetPercentInput && diceBetPercentInput.value) {
            bot.wagerMode.diceBetPercent = parseFloat(diceBetPercentInput.value);
        }
        if (diceChanceInput && diceChanceInput.value) {
            bot.wagerMode.diceChance = parseFloat(diceChanceInput.value);
        }
        if (limboBetPercentInput && limboBetPercentInput.value) {
            bot.wagerMode.limboBetPercent = parseFloat(limboBetPercentInput.value);
        }
        if (limboMultiplierInput && limboMultiplierInput.value) {
            bot.wagerMode.limboMultiplier = parseFloat(limboMultiplierInput.value);
        }
        if (diceBetsInput && diceBetsInput.value) {
            bot.wagerMode.diceBetsPerCycle = parseInt(diceBetsInput.value);
        }
        if (limboBetsInput && limboBetsInput.value) {
            bot.wagerMode.limboBetsPerCycle = parseInt(limboBetsInput.value);
        }
        if (stopLossInput && stopLossInput.value) {
            bot.wagerMode.stopLossPercent = parseFloat(stopLossInput.value);
        }
        
        bot.wagerMode.active = true;
        bot.recoveryMode.active = false;
        bot.wagerMode.startBalance = bot.stats.currentBal;
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        bot.wagerMode.lossTriggered = false;
        
        bot.wagerMode.dicePayout = 99 / bot.wagerMode.diceChance;
        bot.wagerMode.limboPayout = bot.wagerMode.limboMultiplier;
        
        updateLogs(`üéØ ORION WAGER MODE STARTED`, true);
        updateLogs(`üí∞ Start Balance: ${bot.wagerMode.startBalance.toFixed(8)}`, true);
        updateLogs(`üé≤ Dice: ${bot.wagerMode.diceBetPercent}% | Limbo: ${bot.wagerMode.limboBetPercent}%`, true);
        updateLogs(`‚ö° Min Bet: ${bot.globalMinBet.toFixed(8)}`, true);
    }

    function wagerBetLogic() {
        const wm = bot.wagerMode;
        const profitFromStart = bot.stats.currentBal - wm.startBalance;
        const stopLossAmount = wm.startBalance * (wm.stopLossPercent / 100);
        
        if (profitFromStart < -stopLossAmount && !wm.lossTriggered) {
            const lossAmount = Math.abs(profitFromStart);
            const lossPercent = (lossAmount / wm.startBalance) * 100;
            
            wm.lossTriggered = true;
            updateLogs(`‚ö†Ô∏è Stop loss triggered: ${lossAmount.toFixed(8)} (${lossPercent.toFixed(2)}%)`, true);
            updateLogs(`üîÑ Switching to Recovery Mode`, true);
            
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnRecovery) {
                TelegramAPI.sendRecoveryTrigger(lossAmount, lossPercent);
            }
            
            setTimeout(() => {
                switchToRecoveryMode();
            }, 1000);
            return null;
        }
        
        if (wm.currentMode === 'dice') {
            wm.diceBetCount++;
            if (wm.diceBetCount >= wm.diceBetsPerCycle) {
                wm.currentMode = 'limbo';
                wm.diceBetCount = 0;
                updateLogs(`üîÑ Switching to Limbo Mode`, true);
            }
        } else {
            wm.limboBetCount++;
            if (wm.limboBetCount >= wm.limboBetsPerCycle) {
                wm.currentMode = 'dice';
                wm.limboBetCount = 0;
                updateLogs(`üîÑ Switching to Dice Mode`, true);
            }
        }
        
        let baseBetPercent = wm.currentMode === 'dice' ? wm.diceBetPercent : wm.limboBetPercent;
        let baseBet = bot.stats.currentBal * (baseBetPercent / 100);
        
        const maxBet = bot.stats.currentBal * 0.8;
        if (baseBet > maxBet) baseBet = maxBet;
        if (baseBet < bot.globalMinBet) baseBet = bot.globalMinBet;
        
        if (wm.currentMode === 'dice') {
            return {
                bet: baseBet,
                chance: wm.diceChance,
                mode: 'dice'
            };
        } else {
            return {
                bet: baseBet,
                multiplier: wm.limboMultiplier,
                mode: 'limbo'
            };
        }
    }

    // =============== RECOVERY MODE LOGIC (SIMPLE & AGGRESSIVE) ===============
    function initRecoveryMode() {
        const recoveryChanceInput = document.getElementById("recovery-chance");
        const betMultiplierInput = document.getElementById("bet-multiplier");
        const maxBetPercentInput = document.getElementById("max-bet-percent");
        const aggLossesInput = document.getElementById("agg-losses");
        
        if (recoveryChanceInput && recoveryChanceInput.value) {
            bot.recoveryMode.chance = parseFloat(recoveryChanceInput.value);
        }
        if (betMultiplierInput && betMultiplierInput.value) {
            bot.recoveryMode.betMultiplier = parseFloat(betMultiplierInput.value);
        }
        if (maxBetPercentInput && maxBetPercentInput.value) {
            bot.recoveryMode.maxBetPercent = parseFloat(maxBetPercentInput.value);
        }
        if (aggLossesInput && aggLossesInput.value) {
            bot.recoveryMode.consecutiveLossesForAggressive = parseInt(aggLossesInput.value);
        }
        
        bot.wagerMode.active = false;
        bot.recoveryMode.active = true;
        bot.recoveryMode.recoveryStartBalance = bot.wagerMode.startBalance;
        bot.recoveryMode.recoveryLossAmount = bot.wagerMode.startBalance - bot.stats.currentBal;
        
        // Reset consecutive losses saat masuk recovery
        bot.stats.consecutiveLosses = 0;
        
        updateLogs(`üîÑ ORION AGGRESSIVE RECOVERY STARTED`, true);
        updateLogs(`üí∞ Loss to recover: ${bot.recoveryMode.recoveryLossAmount.toFixed(8)}`, true);
        updateLogs(`üéØ Target: ${bot.recoveryMode.recoveryStartBalance.toFixed(8)}`, true);
        updateLogs(`‚ö° Strategy: Bet √ó${bot.recoveryMode.betMultiplier} after ${bot.recoveryMode.consecutiveLossesForAggressive} losses`, true);
    }

    function recoveryBetLogic() {
        const rm = bot.recoveryMode;
        
        if (bot.stats.currentBal >= rm.recoveryStartBalance) {
            updateLogs(`‚úÖ ORION RECOVERY COMPLETE!`, true);
            updateLogs(`üí∞ Recovered to: ${bot.stats.currentBal.toFixed(8)}`, true);
            updateLogs(`üîÑ Returning to Wager Mode`, true);
            
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnRecovery) {
                TelegramAPI.sendRecoveryComplete();
            }
            
            setTimeout(() => {
                switchToWagerMode();
            }, 1000);
            return null;
        }
        
        if (bot.stats.currentBal < bot.globalMinBet) {
            updateLogs(`‚ö†Ô∏è Balance too low for recovery`, true);
            bot.isRunning = false;
            TelegramAPI.sendStopReport("Balance too low for recovery");
            return null;
        }
        
        let betAmount = 0;
        const chance = rm.chance;
        const payoutMultiplier = 99 / chance;
        
        // AGGRESSIVE RECOVERY: Hanya 2 mode saja
        
        // Mode 1: Base bet (1% dari balance)
        if (bot.stats.consecutiveLosses < rm.consecutiveLossesForAggressive) {
            betAmount = bot.stats.currentBal * 0.01; // 1% dari balance
            updateLogs(`üìä Recovery Base: 1% bet (${bot.stats.consecutiveLosses}/${rm.consecutiveLossesForAggressive} losses)`, true);
        }
        // Mode 2: Aggressive bet (previous bet √ó multiplier)
        else {
            if (bot.stats.lastBetAmount > 0) {
                betAmount = bot.stats.lastBetAmount * rm.betMultiplier;
                updateLogs(`‚ö° Recovery Aggressive: ${bot.stats.lastBetAmount.toFixed(8)} √ó ${rm.betMultiplier} = ${betAmount.toFixed(8)}`, true);
            } else {
                betAmount = bot.stats.currentBal * 0.03; // 3% jika tidak ada previous bet
                updateLogs(`üìä Recovery Start: 3% bet (no previous bet)`, true);
            }
        }
        
        // Cap maximum bet
        const maxBet = bot.stats.currentBal * (rm.maxBetPercent / 100);
        if (betAmount > maxBet) {
            betAmount = maxBet;
            updateLogs(`‚ö†Ô∏è Bet capped at ${rm.maxBetPercent}% of balance`, true);
        }
        
        if (betAmount < bot.globalMinBet) {
            betAmount = bot.globalMinBet;
        }
        
        return {
            bet: betAmount,
            chance: chance,
            mode: 'dice'
        };
    }

    // =============== MODE SWITCHING ===============
    function switchToWagerMode() {
        bot.recoveryMode.active = false;
        bot.wagerMode.active = true;
        bot.wagerMode.startBalance = bot.stats.currentBal;
        bot.wagerMode.lossTriggered = false;
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        
        // Reset consecutive losses saat kembali ke wager
        bot.stats.consecutiveLosses = 0;
        
        updateLogs(`üéØ ORION RETURNING TO WAGER MODE`, true);
        updateUI();
    }

    function switchToRecoveryMode() {
        initRecoveryMode();
        updateUI();
    }

    // =============== API FUNCTIONS ===============
    const API = {
        async syncOnce() {
            try {
                bot.token = localStorage.getItem('apitoken') || 
                           localStorage.getItem('token') ||
                           sessionStorage.getItem('token') ||
                           (document.cookie.match(/session=([^;]+)/) ? document.cookie.match(/session=([^;]+)/)[1] : null);
                
                if (!bot.token) {
                    bot.stakeUser = "Not logged in";
                    bot.availableCurrencies = getDefaultCurrencies();
                    updateLogs("‚ö†Ô∏è Please login to Stake first", true);
                    return;
                }

                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{name balances{available{amount currency}}}}`
                    })
                });
                
                if (!res.ok) {
                    bot.stakeUser = "API Error";
                    bot.availableCurrencies = getDefaultCurrencies();
                    updateLogs(`‚ö†Ô∏è API error: ${res.status}`, true);
                    return;
                }
                
                const json = await res.json();
                
                if (json?.data?.user) {
                    bot.stakeUser = json.data.user.name;
                    
                    await syncCurrenciesFromServer();
                    
                    const bals = json.data.user.balances || [];
                    const selectedBal = bals.find(b => 
                        b.available && b.available.currency && 
                        b.available.currency.toLowerCase() === bot.selectedCurrency.toLowerCase()
                    );
                    
                    if (selectedBal) {
                        bot.realBalance = parseFloat(selectedBal.available.amount);
                    }
                    
                    updateLogs(`‚úÖ ORION Synced: ${bot.stakeUser} (${bot.availableCurrencies.length} coins)`, true);
                    
                } else {
                    bot.stakeUser = "API Error";
                    bot.availableCurrencies = getDefaultCurrencies();
                }
                
            } catch (e) {
                bot.stakeUser = "Connection Error";
                bot.availableCurrencies = getDefaultCurrencies();
                updateLogs(`‚ö†Ô∏è Sync error: ${e.message}`, true);
            }
        },

        async getBalance(coin) {
            if (bot.isDemo) return bot.stats.currentBal;
            
            try {
                if (!bot.token) await this.syncOnce();
                
                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "x-access-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{balances{available{amount currency}}}}`
                    })
                });
                const json = await res.json();
                const active = json.data.user.balances.find(b =>
                    b.available.currency.toLowerCase() === coin.toLowerCase()
                );
                const balance = active ? parseFloat(active.available.amount) : 0;
                bot.realBalance = balance;
                return balance;
            } catch (e) {
                return 0;
            }
        },

        async placeDiceBet(amount, chance) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() * 100 < chance;
                    setTimeout(() => {
                        r({
                            diceRoll: {
                                amount: amount,
                                payout: win ? (amount * (99 / chance)) : 0
                            }
                        });
                    }, 50);
                });
            }

            const payload = {
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency,
                target: parseFloat((100 - chance).toFixed(2)),
                condition: "above",
                identifier: Math.random().toString(36).slice(2) + Date.now()
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/dice/roll`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                throw error;
            }
        },

        async placeLimboBet(amount, multiplierTarget) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() < (1 / multiplierTarget);
                    setTimeout(() => {
                        r({
                            limboBet: {
                                amount: amount,
                                payout: win ? (amount * multiplierTarget) : 0,
                                state: {
                                    result: win ? multiplierTarget : (multiplierTarget * Math.random()),
                                    multiplierTarget: multiplierTarget
                                }
                            }
                        });
                    }, 50);
                });
            }

            const payload = {
                multiplierTarget: multiplierTarget,
                identifier: Math.random().toString(36).slice(2) + Date.now(),
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/limbo/bet`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Limbo bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                throw error;
            }
        }
    };

    // =============== MAIN GAME LOOP ===============
    async function runLoop() {
        if (!bot.isRunning || bot.isPaused) return;

        try {
            if (!bot.isDemo && bot.stats.bets % 10 === 0) {
                const realBal = await API.getBalance(bot.selectedCurrency);
                bot.realBalance = realBal;
            }

            let betInfo = null;
            
            if (bot.wagerMode.active) {
                betInfo = wagerBetLogic();
            } else if (bot.recoveryMode.active) {
                betInfo = recoveryBetLogic();
            }
            
            if (betInfo === null) {
                setTimeout(runLoop, 100);
                return;
            }

            let nextBet = betInfo.bet;
            let chance = betInfo.chance;
            let multiplier = betInfo.multiplier;
            let gameMode = betInfo.mode;

            if (nextBet <= 0) nextBet = bot.globalMinBet;
            if (nextBet < bot.globalMinBet) nextBet = bot.globalMinBet;
            
            if (!bot.isDemo) {
                if (nextBet > bot.realBalance && bot.realBalance > 0) {
                    nextBet = bot.realBalance;
                }
                
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                }
            } else {
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                }
            }

            let res;
            if (gameMode === 'dice') {
                res = await API.placeDiceBet(nextBet, chance);
            } else if (gameMode === 'limbo') {
                res = await API.placeLimboBet(nextBet, multiplier);
            }

            let win = false;
            let pft = 0;
            let betAmount = nextBet;

            if (res) {
                if (gameMode === 'dice') {
                    const d = res?.data?.diceRoll || res?.diceRoll;
                    if (d) {
                        win = d.payout > 0;
                        pft = d.payout - d.amount;
                        betAmount = d.amount;
                    }
                } else if (gameMode === 'limbo') {
                    const lb = res?.data?.limboBet || res?.limboBet;
                    if (lb) {
                        const resultMultiplier = lb.state?.result || 0;
                        const targetMultiplier = lb.state?.multiplierTarget || multiplier;
                        win = resultMultiplier >= targetMultiplier;
                        pft = win ? (lb.amount * (targetMultiplier - 1)) : -lb.amount;
                        betAmount = lb.amount;
                    }
                }
            }

            bot.stats.bets++;
            bot.stats.wagered += betAmount;
            bot.stats.profit += pft;
            bot.stats.currentBal += pft;
            bot.stats.lastBetAmount = betAmount;
            
            bot.stats.winRate = bot.stats.bets > 0 ? (bot.stats.wins / bot.stats.bets * 100) : 0;
            bot.stats.wageredPercent = bot.stats.startBal > 0 ? (bot.stats.wagered / bot.stats.startBal * 100) : 0;
            bot.stats.avgBetSize = bot.stats.bets > 0 ? (bot.stats.wagered / bot.stats.bets) : 0;

            if (win) {
                bot.stats.wins++;
                bot.stats.winStreak++;
                bot.stats.lossStreak = 0;
                if (bot.stats.winStreak > bot.stats.maxWinStreak) {
                    bot.stats.maxWinStreak = bot.stats.winStreak;
                }
                bot.stats.consecutiveWins++;
                bot.stats.consecutiveLosses = 0;
                
                // Reset jika win dalam recovery mode
                if (bot.recoveryMode.active && bot.stats.currentBal >= bot.recoveryMode.recoveryStartBalance) {
                    setTimeout(() => {
                        switchToWagerMode();
                    }, 1000);
                }
            } else {
                bot.stats.loss++;
                bot.stats.winStreak = 0;
                bot.stats.lossStreak++;
                if (bot.stats.lossStreak > bot.stats.maxLossStreak) {
                    bot.stats.maxLossStreak = bot.stats.lossStreak;
                }
                bot.stats.consecutiveLosses++;
                bot.stats.consecutiveWins = 0;
            }

            if (!bot.isDemo) {
                bot.realBalance += pft;
            }

            bot.stats.lastResults.unshift({
                win: win,
                betAmount: betAmount,
                profit: pft,
                chance: chance,
                multiplier: multiplier,
                mode: gameMode,
                time: new Date().toLocaleTimeString()
            });
            
            if (bot.stats.lastResults.length > 5) {
                bot.stats.lastResults.pop();
            }

            if (bot.stats.currentBal > bot.stats.peakBalance) {
                bot.stats.peakBalance = bot.stats.currentBal;
            }
            
            const drawdown = bot.stats.peakBalance - bot.stats.currentBal;
            if (drawdown > bot.stats.maxDrawdown) {
                bot.stats.maxDrawdown = drawdown;
                bot.stats.drawdownPercentage = (drawdown / bot.stats.peakBalance) * 100;
            }

            let modeInfo = "";
            if (bot.wagerMode.active) {
                if (gameMode === 'dice') {
                    modeInfo = `[Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}]`;
                } else {
                    modeInfo = `[Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}]`;
                }
            } else {
                modeInfo = `[Recovery ${bot.recoveryMode.chance}%]`;
            }
            
            let logLine;
            const betPercent = (betAmount / bot.stats.currentBal) * 100;
            
            if (gameMode === 'dice') {
                logLine = `${modeInfo} Dice: ${betAmount.toFixed(8)} (${betPercent.toFixed(2)}%) @ ${chance}% ‚Üí ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            } else {
                logLine = `${modeInfo} Limbo: ${betAmount.toFixed(8)} (${betPercent.toFixed(2)}%) @ ${multiplier}x ‚Üí ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            }
            
            if (bot.recoveryMode.active) {
                if (bot.stats.consecutiveLosses >= bot.recoveryMode.consecutiveLossesForAggressive) {
                    logLine += ` [AGGRESSIVE √ó${bot.recoveryMode.betMultiplier}]`;
                }
            }
            
            if (bot.stats.consecutiveLosses > 0) {
                logLine += ` [L:${bot.stats.consecutiveLosses}]`;
            }
            if (bot.stats.consecutiveWins > 0) {
                logLine += ` [W:${bot.stats.consecutiveWins}]`;
            }
            
            updateLogs(logLine);

            updateDashboard();
            updateLiveLogs();

            if (bot.isRunning && !bot.isPaused) {
                const delay = bot.isDemo ? 50 : 100;
                setTimeout(runLoop, delay);
            }

        } catch (e) {
            updateLogs(`‚ö†Ô∏è Error: ${e.message}`, true);
            
            if (bot.isRunning && !bot.isPaused) {
                setTimeout(runLoop, 100);
            }
        }
    }

    // =============== UI FUNCTIONS ===============
    function updateDashboard() {
        const accountName = document.getElementById("account-name");
        if (accountName) accountName.textContent = bot.stakeUser;
        
        const licenseStatus = document.getElementById("license-status");
        if (licenseStatus) {
            licenseStatus.textContent = CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED";
            licenseStatus.style.color = CONFIG.license.isValid() ? "#10b981" : "#ef4444";
        }
        
        const currencyDisplay = document.getElementById("currency-display");
        if (currencyDisplay) {
            const currency = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            currencyDisplay.textContent = currency ? `${currency.icon} ${currency.name}` : bot.selectedCurrency.toUpperCase();
        }
        
        const balanceEl = document.getElementById("balance");
        if (balanceEl) {
            if (bot.isDemo) {
                balanceEl.textContent = bot.stats.currentBal.toFixed(8);
                balanceEl.title = `Demo Balance`;
            } else {
                balanceEl.textContent = bot.realBalance.toFixed(8);
                balanceEl.title = `Real Balance`;
            }
        }
        
        const profitEl = document.getElementById("profit");
        if (profitEl) profitEl.textContent = bot.stats.profit.toFixed(8);
        
        const profitPercent = bot.stats.startBal > 0 ? (bot.stats.profit / bot.stats.startBal * 100) : 0;
        const profitPercentEl = document.getElementById("profit-percent");
        if (profitPercentEl) profitPercentEl.textContent = profitPercent.toFixed(2) + '%';
        
        const betsEl = document.getElementById("bets");
        if (betsEl) betsEl.textContent = bot.stats.bets;
        
        const wageredEl = document.getElementById("wagered");
        if (wageredEl) wageredEl.textContent = bot.stats.wagered.toFixed(8);
        
        const wageredPercentEl = document.getElementById("wagered-percent");
        if (wageredPercentEl) wageredPercentEl.textContent = bot.stats.wageredPercent.toFixed(2) + '%';
        
        const winRateEl = document.getElementById("win-rate");
        if (winRateEl) winRateEl.textContent = bot.stats.winRate.toFixed(2) + '%';
        
        const minBetEl = document.getElementById("min-bet");
        if (minBetEl) minBetEl.textContent = bot.globalMinBet.toFixed(8);
        
        const avgBetEl = document.getElementById("avg-bet");
        if (avgBetEl) avgBetEl.textContent = bot.stats.avgBetSize.toFixed(8);
        
        const currencyCountEl = document.getElementById("currency-count");
        if (currencyCountEl) currencyCountEl.textContent = `${bot.availableCurrencies.length} coins`;
        
        const modeIndicator = document.getElementById("mode-indicator");
        if (modeIndicator) {
            if (bot.wagerMode.active) {
                let patternInfo = "";
                if (bot.wagerMode.currentMode === 'dice') {
                    patternInfo = `Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}`;
                } else {
                    patternInfo = `Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}`;
                }
                modeIndicator.textContent = `WAGER (${patternInfo})`;
                modeIndicator.style.color = "#10b981";
            } else if (bot.recoveryMode.active) {
                modeIndicator.textContent = `AGGRESSIVE RECOVERY`;
                modeIndicator.style.color = "#f59e0b";
            } else {
                modeIndicator.textContent = "STOPPED";
                modeIndicator.style.color = "#94a3b8";
            }
            
            if (bot.isPaused) {
                modeIndicator.textContent += " (PAUSED)";
                modeIndicator.style.color = "#f59e0b";
            }
        }
        
        updateCurrencyDropdown();
    }

    function updateCurrencyDropdown() {
        const currencySelect = document.getElementById("currency-select");
        if (currencySelect && bot.availableCurrencies.length > 0) {
            const currentValue = currencySelect.value;
            
            currencySelect.innerHTML = '';
            
            bot.availableCurrencies.forEach(currency => {
                const option = document.createElement("option");
                option.value = currency.code;
                option.textContent = `${currency.icon} ${currency.name}`;
                option.selected = currency.code === bot.selectedCurrency;
                currencySelect.appendChild(option);
            });
            
            if (currentValue) {
                currencySelect.value = currentValue;
            }
        }
    }

    function updateLiveLogs() {
        const logContainer = document.getElementById("live-log");
        if (!logContainer) return;
        
        let html = "";
        
        if (bot.recoveryMode.active) {
            html += `
                <div style="color:#f59e0b;text-align:center;padding:4px;background:rgba(245,158,11,0.1);margin-bottom:6px;border-radius:3px;font-size:10px;font-weight:bold;">
                    ‚ö° AGGRESSIVE RECOVERY | Loss: ${bot.recoveryMode.recoveryLossAmount.toFixed(8)} | Strategy: √ó${bot.recoveryMode.betMultiplier} after ${bot.recoveryMode.consecutiveLossesForAggressive} losses
                </div>`;
        } else if (bot.wagerMode.active) {
            html += `
                <div style="color:#10b981;text-align:center;padding:4px;background:rgba(16,185,129,0.1);margin-bottom:6px;border-radius:3px;font-size:10px;font-weight:bold;">
                    üéØ ORION ${bot.wagerMode.currentMode.toUpperCase()} MODE | Stop Loss: ${bot.wagerMode.stopLossPercent}%
                </div>`;
        }
        
        if (bot.stats.lastResults.length === 0) {
            html += '<div style="color: #94a3b8; text-align: center; padding: 10px; font-size: 10px;">No bets yet</div>';
        } else {
            bot.stats.lastResults.forEach(result => {
                let color = result.win ? "#10b981" : "#ef4444";
                let bgColor = result.win ? "rgba(16,185,129,0.1)" : "rgba(239,68,68,0.1)";
                
                if (bot.recoveryMode.active) {
                    color = result.win ? "#22c55e" : "#f97316";
                    bgColor = result.win ? "rgba(34,197,94,0.1)" : "rgba(249,115,22,0.1)";
                }
                
                const winLoss = result.win ? "WIN" : "LOSS";
                const modeIcon = result.mode === 'dice' ? 'üé≤' : 'üìà';
                
                const betPercent = (result.betAmount / bot.stats.currentBal) * 100;
                
                html += `
                    <div class="log-entry" style="color: ${color}; background: ${bgColor}; padding: 6px; margin-bottom: 4px; border-radius: 4px; font-size: 11px; border-left: 3px solid ${color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 9px; color: #94a3b8;">${result.time}</div>
                            <div style="font-weight: bold; color: ${color};">${winLoss}</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 4px;">
                            <div>
                                <span>${modeIcon} ${result.betAmount.toFixed(8)}</span>
                                <span style="font-size: 9px; color: #94a3b8; margin-left: 4px;">(${betPercent.toFixed(2)}%)</span>
                            </div>
                            <div style="color: ${result.profit > 0 ? '#10b981' : '#ef4444'}; font-weight: bold;">
                                ${result.profit > 0 ? '+' : ''}${result.profit.toFixed(8)}
                            </div>
                        </div>
                        ${bot.recoveryMode.active && bot.stats.consecutiveLosses >= bot.recoveryMode.consecutiveLossesForAggressive ? 
                            `<div style="font-size: 9px; color: #f59e0b; text-align: center; margin-top: 2px;">
                                Aggressive Mode: √ó${bot.recoveryMode.betMultiplier}
                            </div>` : ''}
                    </div>
                `;
            });
        }
        
        logContainer.innerHTML = html;
    }

    function updateLogs(customMsg, isSystem = false) {
        const logBox = document.getElementById("p-logs");
        if (!logBox) return;

        const entry = document.createElement("div");
        entry.className = "log-entry";

        if (isSystem) {
            entry.style.color = "#f59e0b";
            entry.style.fontWeight = "bold";
        }

        entry.innerHTML = customMsg;
        logBox.prepend(entry);
        
        if (logBox.children.length > 50) {
            logBox.removeChild(logBox.lastChild);
        }
    }

    function updateUI() {
        updateCurrencyDropdown();
        
        const minBetInput = document.getElementById("min-bet-input");
        if (minBetInput) {
            minBetInput.value = bot.globalMinBet;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const unitEl = minBetInput.nextElementSibling;
            if (unitEl && unitEl.classList.contains('unit')) {
                unitEl.textContent = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            }
        }
        
        const diceBetPercentInput = document.getElementById("dice-bet-percent");
        if (diceBetPercentInput) diceBetPercentInput.value = bot.wagerMode.diceBetPercent;
        
        const diceChanceInput = document.getElementById("dice-chance");
        if (diceChanceInput) diceChanceInput.value = bot.wagerMode.diceChance;
        
        const limboBetPercentInput = document.getElementById("limbo-bet-percent");
        if (limboBetPercentInput) limboBetPercentInput.value = bot.wagerMode.limboBetPercent;
        
        const limboMultiplierInput = document.getElementById("limbo-multiplier");
        if (limboMultiplierInput) limboMultiplierInput.value = bot.wagerMode.limboMultiplier;
        
        const wagerStopLoss = document.getElementById("wager-stop-loss");
        if (wagerStopLoss) wagerStopLoss.value = bot.wagerMode.stopLossPercent;
        
        const recoveryChance = document.getElementById("recovery-chance");
        if (recoveryChance) recoveryChance.value = bot.recoveryMode.chance;
        
        const betMultiplier = document.getElementById("bet-multiplier");
        if (betMultiplier) betMultiplier.value = bot.recoveryMode.betMultiplier;
        
        const maxBetPercent = document.getElementById("max-bet-percent");
        if (maxBetPercent) maxBetPercent.value = bot.recoveryMode.maxBetPercent;
        
        const aggLosses = document.getElementById("agg-losses");
        if (aggLosses) aggLosses.value = bot.recoveryMode.consecutiveLossesForAggressive;
        
        const diceBets = document.getElementById("dice-bets");
        if (diceBets) diceBets.value = bot.wagerMode.diceBetsPerCycle;
        
        const limboBets = document.getElementById("limbo-bets");
        if (limboBets) limboBets.value = bot.wagerMode.limboBetsPerCycle;
        
        updateDashboard();
        updateLiveLogs();
    }

    // =============== UI CREATION ===============
    function createUI() {
        if (document.getElementById("orion-wrap")) return;

        const s = document.createElement("style");
        s.innerHTML = `
            #orion-wrap {
                position: fixed;
                top: 10px;
                right: 10px;
                width: 450px;
                max-width: calc(100vw - 20px);
                max-height: calc(100vh - 20px);
                background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
                backdrop-filter: blur(10px);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 12px;
                color: #f8fafc;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 13px;
                z-index: 999999;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3), 0 0 20px rgba(59, 130, 246, 0.1);
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            
            .orion-header {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(59, 130, 246, 0.2));
                padding: 12px 16px;
                border-bottom: 1px solid rgba(59, 130, 246, 0.3);
                display: flex;
                justify-content: space-between;
                align-items: center;
                position: relative;
                overflow: hidden;
            }
            
            .app-title {
                font-size: 16px;
                font-weight: 800;
                background: linear-gradient(135deg, #3b82f6, #8b5cf6);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 4px;
                letter-spacing: 0.5px;
            }
            
            .app-subtitle {
                font-size: 10px;
                color: #94a3b8;
                font-weight: 600;
            }
            
            .header-info {
                display: flex;
                gap: 8px;
                font-size: 10px;
                color: #94a3b8;
                flex-wrap: wrap;
            }
            
            .header-info span {
                padding: 3px 8px;
                background: rgba(30, 41, 59, 0.6);
                border-radius: 5px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .header-controls {
                display: flex;
                gap: 6px;
            }
            
            .control-btn {
                width: 28px;
                height: 28px;
                border-radius: 6px;
                background: rgba(30, 41, 59, 0.7);
                border: 1px solid rgba(59, 130, 246, 0.3);
                color: #3b82f6;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                transition: all 0.2s;
            }
            
            .control-btn:hover {
                background: rgba(59, 130, 246, 0.2);
                transform: translateY(-1px);
            }
            
            .content {
                padding: 16px;
                overflow-y: auto;
                flex: 1;
                -webkit-overflow-scrolling: touch;
                background: rgba(15, 23, 42, 0.3);
            }
            
            .demo-toggle {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 16px;
                padding: 10px;
                background: rgba(30, 41, 59, 0.7);
                border-radius: 8px;
                border: 1px solid rgba(59, 130, 246, 0.2);
            }
            
            .switch {
                position: relative;
                display: inline-block;
                width: 40px;
                height: 20px;
            }
            
            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }
            
            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #4b5563;
                transition: .4s;
                border-radius: 20px;
            }
            
            .slider:before {
                position: absolute;
                content: "";
                height: 16px;
                width: 16px;
                left: 2px;
                bottom: 2px;
                background-color: white;
                transition: .4s;
                border-radius: 50%;
            }
            
            input:checked + .slider {
                background: linear-gradient(135deg, #10b981, #059669);
            }
            
            input:checked + .slider:before {
                transform: translateX(20px);
            }
            
            .demo-label {
                font-size: 12px;
                color: #94a3b8;
                font-weight: 600;
            }
            
            .demo-label.active {
                color: #10b981;
                font-weight: 700;
            }
            
            .currency-selector {
                margin-bottom: 16px;
                background: rgba(30, 41, 59, 0.7);
                border-radius: 8px;
                padding: 12px;
                border: 1px solid rgba(59, 130, 246, 0.2);
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .currency-row {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 12px;
            }
            
            .currency-label {
                font-size: 11px;
                color: #94a3b8;
                width: 90px;
                font-weight: 600;
            }
            
            .currency-dropdown {
                flex: 1;
                background: rgba(15, 23, 42, 0.9);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 6px;
                padding: 8px 12px;
                color: #fff;
                font-size: 12px;
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%233b82f6' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 12px center;
                padding-right: 35px;
                cursor: pointer;
                transition: border 0.2s;
            }
            
            .currency-dropdown:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
            }
            
            .currency-dropdown option {
                background: rgba(15, 23, 42, 0.95);
                color: white;
                padding: 10px;
            }
            
            .min-bet-input {
                display: flex;
                align-items: center;
                gap: 10px;
                flex: 1;
            }
            
            .input-field {
                flex: 1;
                background: rgba(15, 23, 42, 0.9);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 6px;
                padding: 8px 12px;
                color: #fff;
                font-size: 12px;
                font-family: 'Courier New', monospace;
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                text-align: right;
                transition: all 0.2s;
            }
            
            .input-field:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
            }
            
            .unit {
                font-size: 10px;
                color: #94a3b8;
                min-width: 40px;
                text-align: center;
                font-weight: 600;
            }
            
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-bottom: 16px;
            }
            
            .stat-card {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(30, 41, 59, 0.6));
                border-radius: 8px;
                padding: 12px;
                text-align: center;
                min-height: 60px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                border: 1px solid rgba(59, 130, 246, 0.1);
                transition: transform 0.2s;
            }
            
            .stat-card:hover {
                transform: translateY(-2px);
                border-color: rgba(59, 130, 246, 0.3);
            }
            
            .stat-label {
                font-size: 10px;
                color: #94a3b8;
                text-transform: uppercase;
                margin-bottom: 5px;
                font-weight: 600;
                letter-spacing: 0.5px;
            }
            
            .stat-value {
                font-size: 13px;
                font-weight: 800;
                color: #fff;
                font-family: 'Courier New', monospace;
                word-break: break-all;
                line-height: 1.3;
            }
            
            .stat-value.small {
                font-size: 11px;
            }
            
            .mode-indicator {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(30, 41, 59, 0.6));
                border-radius: 8px;
                padding: 10px;
                text-align: center;
                margin-bottom: 16px;
                font-weight: 700;
                font-size: 13px;
                border: 1px solid rgba(59, 130, 246, 0.2);
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .settings-section {
                background: rgba(30, 41, 59, 0.7);
                border-radius: 8px;
                padding: 14px;
                margin-bottom: 12px;
                border: 1px solid rgba(59, 130, 246, 0.1);
            }
            
            .section-title {
                font-size: 12px;
                font-weight: 700;
                color: #3b82f6;
                margin-bottom: 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 6px;
                border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            }
            
            .input-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
                padding: 6px 0;
            }
            
            .input-label {
                font-size: 11px;
                color: #cbd5e1;
                width: 160px;
                font-weight: 500;
            }
            
            .input-wrapper {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .control-buttons {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin: 18px 0;
            }
            
            .main-btn {
                padding: 14px;
                border: none;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 700;
                cursor: pointer;
                text-transform: uppercase;
                transition: all 0.2s;
                letter-spacing: 0.5px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .main-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            }
            
            .main-btn:active {
                transform: translateY(0);
            }
            
            .btn-start {
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
            }
            
            .btn-stop {
                background: linear-gradient(135deg, #ef4444, #dc2626);
                color: white;
            }
            
            .btn-pause {
                background: linear-gradient(135deg, #f59e0b, #d97706);
                color: white;
            }
            
            .live-log {
                background: rgba(15, 23, 42, 0.9);
                border-radius: 8px;
                padding: 12px;
                height: 150px;
                overflow-y: auto;
                font-family: 'Courier New', monospace;
                font-size: 11px;
                border: 1px solid rgba(59, 130, 246, 0.2);
            }
            
            /* Scrollbar styling */
            .content::-webkit-scrollbar {
                width: 6px;
            }
            
            .content::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 3px;
            }
            
            .content::-webkit-scrollbar-thumb {
                background: rgba(59, 130, 246, 0.5);
                border-radius: 3px;
            }
            
            .content::-webkit-scrollbar-thumb:hover {
                background: rgba(59, 130, 246, 0.7);
            }
            
            .live-log::-webkit-scrollbar {
                width: 5px;
            }
            
            .live-log::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }
            
            .live-log::-webkit-scrollbar-thumb {
                background: rgba(59, 130, 246, 0.5);
                border-radius: 2px;
            }
            
            /* Mobile optimizations */
            @media (max-width: 768px) {
                #orion-wrap {
                    width: 380px;
                    font-size: 12px;
                }
                
                .stat-value {
                    font-size: 12px;
                }
                
                .main-btn {
                    padding: 12px;
                    font-size: 11px;
                }
            }
            
            @media (max-width: 480px) {
                #orion-wrap {
                    width: 360px;
                    right: 5px;
                    top: 5px;
                }
            }
        `;
        document.head.appendChild(s);

        const d = document.createElement("div");
        d.id = "orion-wrap";
        d.innerHTML = `
            <div class="orion-header">
                <div>
                    <div class="app-title">üöÄ ORION WAGER BOT</div>
                    <div class="app-subtitle">Aggressive Recovery System v2.0</div>
                </div>
                <div class="header-info">
                    <span id="account-name">${bot.stakeUser}</span>
                    <span id="license-status">${CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED"}</span>
                    <span id="currency-display">Loading...</span>
                </div>
                <div class="header-controls">
                    <button class="control-btn sync" title="Sync">‚Üª</button>
                    <button class="control-btn minimize" title="Minimize">_</button>
                    <button class="control-btn close" title="Close">√ó</button>
                </div>
            </div>
            
            <div class="content">
                <!-- Demo Mode Toggle -->
                <div class="demo-toggle">
                    <label class="switch">
                        <input type="checkbox" id="demo-toggle">
                        <span class="slider"></span>
                    </label>
                    <span id="demo-label" class="demo-label ${bot.isDemo ? 'active' : ''}">
                        ${bot.isDemo ? 'üîÑ DEMO MODE' : 'üí∞ REAL MODE'}
                    </span>
                </div>
                
                <!-- Currency Selector -->
                <div class="currency-selector">
                    <div class="currency-row">
                        <span class="currency-label">üåê Currency</span>
                        <select id="currency-select" class="currency-dropdown">
                            <option value="loading">Loading currencies...</option>
                        </select>
                    </div>
                    <div class="currency-row">
                        <span class="currency-label">‚ö° Min Bet</span>
                        <div class="min-bet-input">
                            <input type="number" id="min-bet-input" class="input-field" value="${bot.globalMinBet}" step="0.00000001" min="0.00000001">
                            <span class="unit" id="min-bet-unit">DOGE</span>
                        </div>
                    </div>
                </div>
                
                <!-- Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Balance</div>
                        <div class="stat-value" id="balance">0.00000000</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Profit</div>
                        <div class="stat-value" id="profit">0.00000000</div>
                        <div class="stat-label" id="profit-percent">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Wagered</div>
                        <div class="stat-value small" id="wagered">0.00000000</div>
                        <div class="stat-label" id="wagered-percent">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Bets</div>
                        <div class="stat-value" id="bets">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value small" id="win-rate">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Avg Bet</div>
                        <div class="stat-value small" id="avg-bet">0.00000000</div>
                    </div>
                </div>
                
                <!-- Mode Indicator -->
                <div class="mode-indicator" id="mode-indicator">
                    <span class="orion-star">‚ú¶</span> ORION SYSTEM: <span id="mode-text">STOPPED</span> <span class="orion-star">‚ú¶</span>
                </div>
                
                <!-- Wager Settings -->
                <div class="settings-section">
                    <div class="section-title">üé≤ Dice Settings</div>
                    <div class="input-row">
                        <span class="input-label">Base Bet %</span>
                        <div class="input-wrapper">
                            <input type="number" id="dice-bet-percent" class="input-field" value="${bot.wagerMode.diceBetPercent}" step="0.1" min="0.1" max="20">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Chance %</span>
                        <div class="input-wrapper">
                            <input type="number" id="dice-chance" class="input-field" value="${bot.wagerMode.diceChance}" step="0.01" min="1" max="99.99">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Bets per Cycle</span>
                        <div class="input-wrapper">
                            <input type="number" id="dice-bets" class="input-field" value="${bot.wagerMode.diceBetsPerCycle}" step="1" min="1" max="100">
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">üìà Limbo Settings</div>
                    <div class="input-row">
                        <span class="input-label">Base Bet %</span>
                        <div class="input-wrapper">
                            <input type="number" id="limbo-bet-percent" class="input-field" value="${bot.wagerMode.limboBetPercent}" step="0.1" min="0.1" max="20">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Multiplier</span>
                        <div class="input-wrapper">
                            <input type="number" id="limbo-multiplier" class="input-field" value="${bot.wagerMode.limboMultiplier}" step="0.001" min="1.001" max="1000">
                            <span class="unit">x</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Bets per Cycle</span>
                        <div class="input-wrapper">
                            <input type="number" id="limbo-bets" class="input-field" value="${bot.wagerMode.limboBetsPerCycle}" step="1" min="1" max="100">
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">‚ö†Ô∏è Stop Loss</div>
                    <div class="input-row">
                        <span class="input-label">Stop Loss %</span>
                        <div class="input-wrapper">
                            <input type="number" id="wager-stop-loss" class="input-field" value="${bot.wagerMode.stopLossPercent}" step="0.1" min="0.1" max="10">
                            <span class="unit">%</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">‚ö° Aggressive Recovery</div>
                    <div class="input-row">
                        <span class="input-label">Recovery Chance</span>
                        <div class="input-wrapper">
                            <input type="number" id="recovery-chance" class="input-field" value="${bot.recoveryMode.chance}" step="1" min="50" max="99.5">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Bet Multiplier</span>
                        <div class="input-wrapper">
                            <input type="number" id="bet-multiplier" class="input-field" value="${bot.recoveryMode.betMultiplier}" step="0.1" min="1" max="10">
                            <span class="unit">x</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Max Bet %</span>
                        <div class="input-wrapper">
                            <input type="number" id="max-bet-percent" class="input-field" value="${bot.recoveryMode.maxBetPercent}" step="1" min="10" max="90">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Trigger After Losses</span>
                        <div class="input-wrapper">
                            <input type="number" id="agg-losses" class="input-field" value="${bot.recoveryMode.consecutiveLossesForAggressive}" step="1" min="1" max="20">
                            <span class="unit">losses</span>
                        </div>
                    </div>
                </div>
                
                <!-- Control Buttons -->
                <div class="control-buttons">
                    <button id="p-start" class="main-btn btn-start">‚ñ∂ START</button>
                    <button id="p-pause" class="main-btn btn-pause">‚è∏ PAUSE</button>
                    <button id="p-stop" class="main-btn btn-stop">‚èπ STOP</button>
                </div>
                
                <!-- Live Log -->
                <div class="section-title" style="margin-top: 15px; margin-bottom: 8px;">üìä ORION LIVE LOG</div>
                <div class="live-log" id="live-log">
                    <div style="color: #94a3b8; text-align: center; padding: 20px; font-size: 12px;">
                        <div style="margin-bottom: 10px; color: #3b82f6; font-weight: bold;">üöÄ ORION WAGER BOT READY</div>
                        <div style="font-size: 11px;">Waiting for wager commands...</div>
                    </div>
                </div>
            </div>
            
            <div id="p-logs" style="display: none;"></div>
        `;
        document.body.appendChild(d);

        setupEventListeners();
        updateUI();
        
        setTimeout(() => {
            API.syncOnce();
        }, 1500);
    }

    function setupEventListeners() {
        // Demo toggle
        const demoToggle = document.getElementById('demo-toggle');
        const demoLabel = document.getElementById('demo-label');
        
        if (demoToggle) {
            demoToggle.checked = bot.isDemo;
            demoToggle.addEventListener('change', function() {
                bot.isDemo = this.checked;
                demoLabel.textContent = bot.isDemo ? 'üîÑ DEMO MODE' : 'üí∞ REAL MODE';
                demoLabel.classList.toggle('active', bot.isDemo);
                updateLogs(`Switched to ${bot.isDemo ? 'DEMO' : 'REAL'} mode`, true);
            });
        }

        // Currency selector
        const currencySelect = document.getElementById('currency-select');
        if (currencySelect) {
            currencySelect.addEventListener('change', function() {
                bot.selectedCurrency = this.value;
                const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
                updateLogs(`Currency changed to: ${currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase()}`, true);
                updateUI();
            });
        }

        // Min Bet Input
        const minBetInput = document.getElementById('min-bet-input');
        if (minBetInput) {
            minBetInput.addEventListener('change', function() {
                const value = parseFloat(this.value);
                if (!isNaN(value) && value > 0) {
                    bot.globalMinBet = value;
                    updateLogs(`Min bet set to: ${value.toFixed(8)}`, true);
                    updateUI();
                } else {
                    this.value = bot.globalMinBet;
                }
            });
        }

        // Sync button
        const syncBtn = document.querySelector('.control-btn.sync');
        if (syncBtn) {
            syncBtn.addEventListener('click', async () => {
                updateLogs("üîç ORION: Syncing account and currencies...", true);
                await API.syncOnce();
                updateDashboard();
                updateLogs("‚úÖ ORION: Sync complete!", true);
            });
        }

        // Minimize button
        const minimizeBtn = document.querySelector('.control-btn.minimize');
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', () => {
                const content = document.querySelector('.content');
                const wrap = document.getElementById('orion-wrap');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    minimizeBtn.textContent = '_';
                    wrap.style.width = '450px';
                } else {
                    content.style.display = 'none';
                    minimizeBtn.textContent = '‚ñ°';
                    wrap.style.width = 'auto';
                }
            });
        }

        // Close button
        const closeBtn = document.querySelector('.control-btn.close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                if (bot.isRunning) {
                    if (confirm("ORION Bot is running. Close anyway?")) {
                        document.getElementById("orion-wrap").remove();
                    }
                } else {
                    document.getElementById("orion-wrap").remove();
                }
            });
        }

        // Input listeners
        const inputs = [
            { id: 'dice-bet-percent', property: 'wagerMode.diceBetPercent', min: 0.1, max: 20 },
            { id: 'dice-chance', property: 'wagerMode.diceChance', min: 1, max: 99.99 },
            { id: 'limbo-bet-percent', property: 'wagerMode.limboBetPercent', min: 0.1, max: 20 },
            { id: 'limbo-multiplier', property: 'wagerMode.limboMultiplier', min: 1.001 },
            { id: 'wager-stop-loss', property: 'wagerMode.stopLossPercent', min: 0.1, max: 10 },
            { id: 'recovery-chance', property: 'recoveryMode.chance', min: 50, max: 99.5 },
            { id: 'bet-multiplier', property: 'recoveryMode.betMultiplier', min: 1, max: 10 },
            { id: 'max-bet-percent', property: 'recoveryMode.maxBetPercent', min: 10, max: 90 },
            { id: 'agg-losses', property: 'recoveryMode.consecutiveLossesForAggressive', min: 1, max: 20 },
            { id: 'dice-bets', property: 'wagerMode.diceBetsPerCycle', min: 1 },
            { id: 'limbo-bets', property: 'wagerMode.limboBetsPerCycle', min: 1 }
        ];

        inputs.forEach(input => {
            const el = document.getElementById(input.id);
            if (el) {
                el.addEventListener('change', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value)) {
                        if ((!input.min || value >= input.min) && (!input.max || value <= input.max)) {
                            const props = input.property.split('.');
                            if (props.length === 2) {
                                bot[props[0]][props[1]] = value;
                            } else {
                                bot[input.property] = value;
                            }
                            updateLogs(`‚öôÔ∏è ${input.id.replace(/-/g, ' ')}: ${value}`, true);
                            updateUI();
                        } else {
                            e.target.value = bot[input.property.split('.')[0]][input.property.split('.')[1]];
                        }
                    }
                });
            }
        });

        // Start Button
        const pStart = document.getElementById("p-start");
        if (pStart) {
            pStart.onclick = async () => {
                if (bot.isRunning) return;

                if (!CONFIG.license.isValid() && !bot.isDemo) {
                    alert(`üö´ ORION License expired! Renew please.`);
                    return;
                }

                if (bot.isDemo) {
                    const demoBalanceInput = prompt("Enter Demo Starting Balance:", bot.demoBalance);
                    if (demoBalanceInput !== null) {
                        const demoBal = parseFloat(demoBalanceInput);
                        if (!isNaN(demoBal) && demoBal >= bot.globalMinBet) {
                            bot.demoBalance = demoBal;
                            updateLogs(`üíæ Demo balance set to: ${demoBal.toFixed(8)}`, true);
                        } else {
                            alert(`Please enter a valid amount (min: ${bot.globalMinBet})`);
                            return;
                        }
                    }
                } else {
                    try {
                        await API.syncOnce();
                        if (bot.stakeUser === "Not logged in" || bot.stakeUser === "API Error") {
                            alert("üîë Please login to Stake first!");
                            return;
                        }
                        
                        bot.realBalance = await API.getBalance(bot.selectedCurrency);
                        if (bot.realBalance <= 0) {
                            alert(`üí∞ Insufficient ${bot.selectedCurrency.toUpperCase()} balance!`);
                            return;
                        }
                        
                    } catch (e) {
                        alert(`‚ö†Ô∏è Sync error: ${e.message}`);
                        return;
                    }
                }

                bot.isRunning = true;
                bot.isPaused = false;

                bot.stats = {
                    profit: 0,
                    wagered: 0,
                    startBal: 0,
                    currentBal: 0,
                    peakBalance: 0,
                    maxDrawdown: 0,
                    drawdownPercentage: 0,
                    bets: 0,
                    wins: 0,
                    loss: 0,
                    startTime: Date.now(),
                    lastBetAmount: 0,
                    lastResults: [],
                    winStreak: 0,
                    lossStreak: 0,
                    maxWinStreak: 0,
                    maxLossStreak: 0,
                    consecutiveLosses: 0,
                    consecutiveWins: 0,
                    winRate: 0,
                    wageredPercent: 0,
                    avgBetSize: 0
                };

                if (bot.isDemo) {
                    bot.stats.startBal = bot.demoBalance;
                    bot.stats.currentBal = bot.demoBalance;
                    bot.stats.peakBalance = bot.demoBalance;
                } else {
                    bot.stats.startBal = bot.realBalance;
                    bot.stats.currentBal = bot.realBalance;
                    bot.stats.peakBalance = bot.realBalance;
                }

                bot.recoveryMode.active = false;
                bot.wagerMode.active = true;

                initWagerMode();

                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStart) {
                    TelegramAPI.sendStartReport();
                }

                updateUI();
                updateLogs(`üöÄ ORION BOT STARTED! (${bot.isDemo ? 'Demo' : 'Real'} mode)`, true);

                setTimeout(() => {
                    runLoop();
                }, 100);
            };
        }

        // Stop Button
        const pStop = document.getElementById("p-stop");
        if (pStop) {
            pStop.onclick = () => {
                bot.isRunning = false;
                bot.isPaused = false;
                
                updateLogs("üõë ORION Bot stopped", true);
                updateUI();
                
                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStop) {
                    TelegramAPI.sendStopReport("Manual Stop");
                }
            };
        }

        // Pause Button
        const pPause = document.getElementById("p-pause");
        if (pPause) {
            pPause.onclick = () => {
                if (!bot.isRunning) return;
                bot.isPaused = !bot.isPaused;
                
                if (bot.isPaused) {
                    pPause.textContent = "‚ñ∂ RESUME";
                    updateLogs("‚è∏ ORION Bot paused", true);
                } else {
                    pPause.textContent = "‚è∏ PAUSE";
                    updateLogs("‚ñ∂ ORION Bot resumed", true);
                    setTimeout(() => {
                        runLoop();
                    }, 100);
                }
                updateUI();
            };
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                document.getElementById('p-start').click();
            }
            if (e.ctrlKey && e.key === 'x') {
                e.preventDefault();
                document.getElementById('p-stop').click();
            }
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                document.getElementById('p-pause').click();
            }
        });
    }

    createUI();
})();
