(function () {
    const CONFIG = {
        get apiUrl() { return window.location.origin + '/_api'; },
        version: "HYBRID WAGER v2.0",
        license: {
            type: "PREMIUM",
            expiryDate: new Date("2026-02-26"),
            isValid: function() {
                return new Date() <= this.expiryDate;
            }
        },
        telegram: {
            enabled: true,
            botToken: '8391763291:AAGdi0yiVDwm0xZvq4UaJzMyy6_kaN0Zerc',
            chatId: '-1003744641395',
            reportInterval: 30,
            lastReportTime: 0,
            sendOnStart: true,
            sendOnStop: true,
            sendOnTarget: true,
            sendOnStopLoss: true,
            sendPeriodic: true,
            sendBigWins: true,
            bigWinThreshold: 0.001
        }
    };

    const bot = {
        isRunning: false,
        isPaused: false,
        isDemo: false,
        demoBalance: 1000.0,
        token: null,
        stakeUser: "Loading...",
        selectedCurrency: "doge",
        globalMinBet: 0.00000001,
        realBalance: 0,
        
        stats: {
            profit: 0,
            wagered: 0,
            startBal: 0,
            currentBal: 0,
            peakBalance: 0,
            maxDrawdown: 0,
            drawdownPercentage: 0,
            bets: 0,
            wins: 0,
            loss: 0,
            startTime: null,
            lastBetAmount: 0,
            lastResults: [],
            wagerTime: 0,
            recoveryTime: 0,
            wagerBets: 0,
            recoveryBets: 0,
            recentWins: 0,
            recentLosses: 0,
            winStreak: 0,
            lossStreak: 0,
            maxWinStreak: 0,
            maxLossStreak: 0,
            lastHourBets: 0,
            lastHourWins: 0,
            lastHourProfit: 0,
            startMinute: null
        },
        
        // Advanced Martingale Settings
        martingaleSettings: {
            baseMultiplier: 2,
            maxMultiplier: 100,
            resetOnWin: true,
            increaseOnLoss: true,
            multiplierSequence: [2, 3, 5, 8, 13, 21],
            useSequence: false,
            maxLossStreak: 10
        },
        
        wagerMode: {
            active: false,
            basebetDice: 0,
            basebetLimbo: 0,
            diceChance: 99.98,
            limboMultiplier: 1.001,
            dicePayout: 0,
            limboPayout: 0,
            stopLossPercent: 1.0,
            currentMode: 'dice',
            diceBetCount: 0,
            limboBetCount: 0,
            diceBetsPerCycle: 10,
            limboBetsPerCycle: 50,
            lossTriggered: false,
            startBalance: 0,
            profitTrigger: {
                enabled: true,
                stopAtProfit: true,
                minProfitThreshold: 0.000001
            }
        },
        
        recoveryMode: {
            active: false,
            basebet: 0,
            chance: 80,
            originalLoss: 0,
            recoveryTarget: 0,
            consecutiveLosses: 0,
            consecutiveWins: 0,
            currentStep: 0,
            maxSteps: 50,
            recoveryComplete: false,
            requiredProfit: 0,
            hybridMode: false,
            currentHybridMethod: null,
            hybridMethodsUsed: [],
            labouchereSequence: [],
            laboucherePointer: 0,
            fibonacciSequence: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55],
            fibonacciIndex: 0,
            dAlembertLevel: 0,
            paroliWinStreak: 0,
            paroliBaseBet: 0
        },
        
        recoveryMethods: {
            martingale: true,
            paroli: false,
            dAlembert: false,
            labouchere: false,
            fibonacci: false,
            hybrid: false,
            selected: 'martingale'
        },
        
        triggers: {
            minuteTrigger: {
                enabled: false,
                minutes: 5,
                action: 'stop',
                lastTriggerTime: 0
            },
            
            lossTrigger: {
                enabled: false,
                amount: 0.001,
                consecutive: 3,
                action: 'recovery'
            },
            
            winTrigger: {
                enabled: false,
                amount: 0.01,
                consecutive: 3,
                action: 'increase_bet'
            },
            
            balanceTrigger: {
                enabled: false,
                targetProfit: 0.1,
                action: 'stop'
            }
        },
        
        bettingSystems: {
            paroli: false,
            dAlembert: false,
            labouchere: false
        },
        
        speedSettings: {
            turboMode: true,
            wagerSpeed: 1,
            recoverySpeed: 100,
            demoSpeed: 10
        }
    };

    // =============== TELEGRAM FUNCTIONS ===============
    const TelegramAPI = {
        async sendMessage(text, parse_mode = "HTML") {
            if (!CONFIG.telegram.enabled || !CONFIG.telegram.botToken || !CONFIG.telegram.chatId) {
                return;
            }
            try {
                const url = `https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`;
                const params = {
                    chat_id: CONFIG.telegram.chatId,
                    text: text,
                    parse_mode: parse_mode,
                    disable_web_page_preview: true
                };
                await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(params)
                });
            } catch (error) {
                console.error("Telegram error:", error);
            }
        },

        async sendStartReport() {
            if (!CONFIG.telegram.sendOnStart) return;
            
            const currency = bot.selectedCurrency.toUpperCase();
            const dicePayout = (99/bot.wagerMode.diceChance).toFixed(4);
            const limboPayout = bot.wagerMode.limboMultiplier.toFixed(4);
            
            const message = `ğŸš€ <b>HYBRID WAGER v2.0 STARTED</b>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ’° Balance: <code>${bot.stats.startBal.toFixed(8)} ${currency}</code>\n` +
                `ğŸ¯ Dice: ${bot.wagerMode.diceChance}% (${bot.wagerMode.basebetDice.toFixed(8)} ${currency})\n` +
                `ğŸ¯ Payout: ${dicePayout}x\n` +
                `ğŸ¯ Limbo: ${bot.wagerMode.limboMultiplier}x (${bot.wagerMode.basebetLimbo.toFixed(8)} ${currency})\n` +
                `ğŸ¯ Payout: ${limboPayout}x\n` +
                `ğŸ“Š Pattern: ${bot.wagerMode.diceBetsPerCycle} Dice â†’ ${bot.wagerMode.limboBetsPerCycle} Limbo\n` +
                `ğŸ”„ Recovery: ${bot.recoveryMode.chance}% (${bot.recoveryMethods.selected.toUpperCase()})\n` +
                `âš¡ Speed: ${bot.speedSettings.turboMode ? 'TURBO' : 'NORMAL'}\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `â° ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendStopReport(reason = "Manual Stop") {
            if (!CONFIG.telegram.sendOnStop) return;
            
            const currency = bot.selectedCurrency.toUpperCase();
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            const seconds = runtime % 60;
            
            const profitPercent = bot.stats.startBal > 0 
                ? ((bot.stats.profit / bot.stats.startBal) * 100) 
                : 0;
            
            const winRate = bot.stats.bets > 0 
                ? ((bot.stats.wins / bot.stats.bets) * 100) 
                : 0;
            
            const drawdownPercent = bot.stats.peakBalance > 0 
                ? (bot.stats.maxDrawdown / bot.stats.peakBalance * 100) 
                : 0;

            const wagerHours = Math.floor(bot.stats.wagerTime / 3600000);
            const wagerMinutes = Math.floor((bot.stats.wagerTime % 3600000) / 60000);
            const recoveryHours = Math.floor(bot.stats.recoveryTime / 3600000);
            const recoveryMinutes = Math.floor((bot.stats.recoveryTime % 3600000) / 60000);

            const message = `ğŸ›‘ <b>BOT STOPPED</b>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ“ Reason: <b>${reason}</b>\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `â±ï¸ Runtime: <code>${hours}h ${minutes}m ${seconds}s</code>\n` +
                `ğŸ“Š Wager Mode: <code>${wagerHours}h ${wagerMinutes}m (${bot.stats.wagerBets} bets)</code>\n` +
                `ğŸ”„ Recovery Mode: <code>${recoveryHours}h ${recoveryMinutes}m (${bot.stats.recoveryBets} bets)</code>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ’° Start Balance: <code>${bot.stats.startBal.toFixed(8)} ${currency}</code>\n` +
                `ğŸ’° End Balance: <code>${bot.stats.currentBal.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“ˆ Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“ˆ Profit %: <code>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</code>\n` +
                `ğŸ’° Peak Balance: <code>${bot.stats.peakBalance.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“‰ Max Drawdown: <code>${bot.stats.maxDrawdown.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“‰ Max DD %: <code>${drawdownPercent.toFixed(2)}%</code>\n` +
                `ğŸ° Wagered: <code>${bot.stats.wagered.toFixed(8)} ${currency}</code>\n` +
                `ğŸ² Bets: <code>${bot.stats.bets}</code>\n` +
                `âœ… Wins: <code>${bot.stats.wins}</code>\n` +
                `âŒ Losses: <code>${bot.stats.loss}</code>\n` +
                `ğŸ“Š Win Rate: <code>${winRate.toFixed(2)}%</code>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `â° ${new Date().toLocaleString()}`;

            await this.sendMessage(message);
        },

        async sendModeSwitchToRecovery(lossAmount, lossPercent) {
            if (!CONFIG.telegram.enabled) return;
            
            const currency = bot.selectedCurrency.toUpperCase();
            
            const message = `ğŸ”„ <b>SWITCHING TO RECOVERY MODE</b>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ“‰ Loss Detected: <code>${lossAmount.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“‰ Loss %: <code>${lossPercent.toFixed(2)}%</code>\n` +
                `ğŸ¯ Recovery Method: <b>${bot.recoveryMethods.selected.toUpperCase()}${bot.recoveryMode.hybridMode ? ' (HYBRID)' : ''}</b>\n` +
                `âš™ï¸ Settings: ${bot.recoveryMode.chance}% chance\n` +
                `ğŸ’° Current Balance: <code>${bot.stats.currentBal.toFixed(8)} ${currency}</code>\n` +
                `ğŸ’° Target: <code>${bot.wagerMode.startBalance.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“Š Required Profit: <code>${lossAmount.toFixed(8)} ${currency}</code>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `â° ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendRecoveryComplete(recoveredAmount, steps) {
            if (!CONFIG.telegram.enabled) return;
            
            const currency = bot.selectedCurrency.toUpperCase();
            const recoveryPercent = bot.recoveryMode.originalLoss > 0 
                ? (recoveredAmount / bot.recoveryMode.originalLoss * 100) 
                : 0;
            
            const message = `âœ… <b>RECOVERY COMPLETE</b>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ’° Recovered: <code>${recoveredAmount.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“Š Recovery %: <code>${recoveryPercent.toFixed(2)}%</code>\n` +
                `ğŸ“Š Steps Taken: <code>${steps}</code>\n` +
                `${bot.recoveryMode.hybridMode ? `ğŸ”„ Methods Used: ${bot.recoveryMode.hybridMethodsUsed.join(', ')}\n` : ''}` +
                `ğŸ”„ Returning to Wager Mode\n` +
                `ğŸ’° Current Balance: <code>${bot.stats.currentBal.toFixed(8)} ${currency}</code>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `â° ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendPeriodicReport() {
            if (!CONFIG.telegram.enabled || !CONFIG.telegram.sendPeriodic) return;
            
            const now = Date.now();
            if (now - CONFIG.telegram.lastReportTime < CONFIG.telegram.reportInterval * 1000) return;
            
            CONFIG.telegram.lastReportTime = now;
            
            const currency = bot.selectedCurrency.toUpperCase();
            const runtime = bot.stats.startTime ? Math.floor((now - bot.stats.startTime) / 1000) : 0;
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            const seconds = runtime % 60;
            
            const profitPercent = bot.stats.startBal > 0 
                ? (bot.stats.profit / bot.stats.startBal * 100) 
                : 0;
            
            const winRate = bot.stats.bets > 0 
                ? ((bot.stats.wins / bot.stats.bets) * 100) 
                : 0;
            
            const drawdownPercent = bot.stats.peakBalance > 0 
                ? (bot.stats.maxDrawdown / bot.stats.peakBalance * 100) 
                : 0;
            
            let mode = "IDLE";
            let modeDetails = "";
            
            if (bot.wagerMode.active) {
                mode = "WAGER";
                const currentCycle = bot.wagerMode.currentMode === 'dice' 
                    ? `Dice: ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}`
                    : `Limbo: ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}`;
                
                const profitFromStart = bot.stats.currentBal - bot.wagerMode.startBalance;
                const profitFromStartPercent = bot.wagerMode.startBalance > 0 
                    ? (profitFromStart / bot.wagerMode.startBalance * 100) 
                    : 0;
                
                modeDetails = `${currentCycle}, Profit: ${profitFromStart > 0 ? '+' : ''}${profitFromStart.toFixed(8)} ${currency} (${profitFromStartPercent > 0 ? '+' : ''}${profitFromStartPercent.toFixed(2)}%)`;
            } else if (bot.recoveryMode.active) {
                mode = "RECOVERY";
                const neededProfit = bot.recoveryMode.recoveryTarget - bot.stats.currentBal;
                const neededPercent = bot.recoveryMode.recoveryTarget > 0 
                    ? (neededProfit / bot.recoveryMode.recoveryTarget * 100) 
                    : 0;
                
                const method = bot.recoveryMode.hybridMode ? `HYBRID (${bot.recoveryMode.currentHybridMethod})` : bot.recoveryMethods.selected;
                modeDetails = `Method: ${method}, Step: ${bot.recoveryMode.currentStep}/${bot.recoveryMode.maxSteps}, Need: ${neededProfit.toFixed(8)} ${currency} (${neededPercent.toFixed(2)}%)`;
            }
            
            const message = `ğŸ“Š <b>PERIODIC REPORT</b>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ“Š Mode: <b>${mode}</b>\n` +
                `ğŸ“ ${modeDetails}\n` +
                `â±ï¸ Runtime: <code>${hours}h ${minutes}m ${seconds}s</code>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ’° Balance: <code>${bot.stats.currentBal.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“ˆ Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“ˆ Profit %: <code>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</code>\n` +
                `ğŸ“‰ Max DD: <code>${bot.stats.maxDrawdown.toFixed(8)} ${currency}</code>\n` +
                `ğŸ“‰ Max DD %: <code>${drawdownPercent.toFixed(2)}%</code>\n` +
                `ğŸ° Wagered: <code>${bot.stats.wagered.toFixed(8)} ${currency}</code>\n` +
                `ğŸ² Bets: <code>${bot.stats.bets}</code>\n` +
                `âœ… Wins: <code>${bot.stats.wins}</code>\n` +
                `âŒ Losses: <code>${bot.stats.loss}</code>\n` +
                `ğŸ“Š Win Rate: <code>${winRate.toFixed(2)}%</code>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `â° ${new Date().toLocaleString()}`;
            
            await this.sendMessage(message);
        },

        async sendTriggerAlert(triggerType, details) {
            if (!CONFIG.telegram.enabled) return;
            
            const currency = bot.selectedCurrency.toUpperCase();
            
            const message = `ğŸš¨ <b>TRIGGER ACTIVATED</b>\n` +
                `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ”” Trigger: <b>${triggerType}</b>\n` +
                `ğŸ“ Details: ${details}\n` +
                `ğŸ’° Current Balance: <code>${bot.stats.currentBal.toFixed(8)} ${currency}</code>\n` +
                `â° ${new Date().toLocaleString()}`;
            
            await this.sendMessage(message);
        }
    };

    // =============== STATISTICS FUNCTIONS ===============
    function updateStatistics(win, betAmount, profit) {
        const stats = bot.stats;
        
        if (stats.currentBal > stats.peakBalance) {
            stats.peakBalance = stats.currentBal;
        }
        
        const drawdown = stats.peakBalance - stats.currentBal;
        if (drawdown > stats.maxDrawdown) {
            stats.maxDrawdown = drawdown;
            stats.drawdownPercentage = (drawdown / stats.peakBalance) * 100;
        }
        
        if (win) {
            stats.recentWins++;
            stats.recentLosses = 0;
            stats.winStreak++;
            stats.lossStreak = 0;
            
            if (stats.winStreak > stats.maxWinStreak) {
                stats.maxWinStreak = stats.winStreak;
            }
        } else {
            stats.recentWins = 0;
            stats.recentLosses++;
            stats.winStreak = 0;
            stats.lossStreak++;
            
            if (stats.lossStreak > stats.maxLossStreak) {
                stats.maxLossStreak = stats.lossStreak;
            }
        }
        
        if (!stats.startMinute) {
            stats.startMinute = Date.now();
        }
        
        const now = Date.now();
        const minutesElapsed = Math.floor((now - stats.startMinute) / 60000);
        
        if (minutesElapsed >= 60) {
            stats.lastHourBets = 0;
            stats.lastHourWins = 0;
            stats.lastHourProfit = 0;
            stats.startMinute = now;
        }
        
        stats.lastHourBets++;
        if (win) stats.lastHourWins++;
        stats.lastHourProfit += profit;
        
        if (bot.wagerMode.active) {
            bot.stats.wagerTime += getCurrentSpeed();
            bot.stats.wagerBets++;
        } else if (bot.recoveryMode.active) {
            bot.stats.recoveryTime += getCurrentSpeed();
            bot.stats.recoveryBets++;
        }
    }

    // =============== TRIGGER FUNCTIONS ===============
    function checkTriggers() {
        const triggers = bot.triggers;
        const now = Date.now();
        
        if (triggers.minuteTrigger.enabled) {
            const minutesElapsed = Math.floor((now - bot.stats.startTime) / 60000);
            if (minutesElapsed >= triggers.minuteTrigger.minutes && 
                now - triggers.minuteTrigger.lastTriggerTime > 60000) {
                
                triggers.minuteTrigger.lastTriggerTime = now;
                const action = triggers.minuteTrigger.action;
                const details = `${triggers.minuteTrigger.minutes} minutes elapsed`;
                
                TelegramAPI.sendTriggerAlert('Time Trigger', details);
                executeTriggerAction(action, details);
                return true;
            }
        }
        
        if (triggers.lossTrigger.enabled && bot.stats.lossStreak >= triggers.lossTrigger.consecutive) {
            const totalLoss = bot.stats.lastResults
                .slice(0, triggers.lossTrigger.consecutive)
                .filter(r => !r.win)
                .reduce((sum, r) => sum + Math.abs(r.profit), 0);
            
            if (totalLoss >= triggers.lossTrigger.amount) {
                const details = `${triggers.lossTrigger.consecutive} consecutive losses (${totalLoss.toFixed(8)} loss)`;
                TelegramAPI.sendTriggerAlert('Loss Trigger', details);
                executeTriggerAction(triggers.lossTrigger.action, details);
                return true;
            }
        }
        
        if (triggers.winTrigger.enabled && bot.stats.winStreak >= triggers.winTrigger.consecutive) {
            const totalWin = bot.stats.lastResults
                .slice(0, triggers.winTrigger.consecutive)
                .filter(r => r.win)
                .reduce((sum, r) => sum + r.profit, 0);
            
            if (totalWin >= triggers.winTrigger.amount) {
                const details = `${triggers.winTrigger.consecutive} consecutive wins (${totalWin.toFixed(8)} profit)`;
                TelegramAPI.sendTriggerAlert('Win Trigger', details);
                executeTriggerAction(triggers.winTrigger.action, details);
                return true;
            }
        }
        
        if (triggers.balanceTrigger.enabled && bot.stats.profit >= triggers.balanceTrigger.targetProfit) {
            const details = `Target profit reached: ${bot.stats.profit.toFixed(8)}`;
            TelegramAPI.sendTriggerAlert('Balance Trigger', details);
            executeTriggerAction(triggers.balanceTrigger.action, details);
            return true;
        }
        
        return false;
    }

    function executeTriggerAction(action, details) {
        switch(action) {
            case 'stop':
                bot.isRunning = false;
                updateLogs(0, 0, 0, `ğŸ›‘ Trigger activated: ${details} - Stopping bot`, true);
                break;
                
            case 'pause':
                bot.isPaused = true;
                updateLogs(0, 0, 0, `â¸ Trigger activated: ${details} - Pausing bot`, true);
                break;
                
            case 'recovery':
                if (bot.wagerMode.active && !bot.wagerMode.lossTriggered) {
                    bot.wagerMode.lossTriggered = true;
                    updateLogs(0, 0, 0, `ğŸ”„ Trigger activated: ${details} - Switching to recovery`, true);
                    setTimeout(() => {
                        switchToRecoveryMode();
                    }, 1000);
                }
                break;
                
            case 'switch_to_recovery':
                if (bot.wagerMode.active) {
                    bot.wagerMode.lossTriggered = true;
                    updateLogs(0, 0, 0, `ğŸ”„ Trigger activated: ${details} - Switching to recovery`, true);
                    setTimeout(() => {
                        switchToRecoveryMode();
                    }, 1000);
                }
                break;
                
            case 'increase_bet':
                bot.wagerMode.basebetDice *= 1.1;
                bot.wagerMode.basebetLimbo *= 1.1;
                updateLogs(0, 0, 0, `ğŸ“ˆ Trigger activated: ${details} - Increasing base bet by 10%`, true);
                break;
        }
    }

    // =============== HYBRID RECOVERY SYSTEM ===============
    function getRandomRecoveryMethod() {
        const methods = ['martingale', 'paroli', 'dAlembert', 'labouchere', 'fibonacci'];
        const availableMethods = methods.filter(m => m !== bot.recoveryMode.currentHybridMethod);
        
        if (availableMethods.length === 0) {
            bot.recoveryMode.hybridMethodsUsed = [];
            return methods[Math.floor(Math.random() * methods.length)];
        }
        
        const randomMethod = availableMethods[Math.floor(Math.random() * availableMethods.length)];
        bot.recoveryMode.hybridMethodsUsed.push(randomMethod);
        return randomMethod;
    }

    function initializeRecoveryMethod() {
        const rm = bot.recoveryMode;
        const method = bot.recoveryMethods.selected;
        
        rm.consecutiveLosses = 0;
        rm.consecutiveWins = 0;
        rm.currentStep = 0;
        rm.recoveryComplete = false;
        
        if (method === 'hybrid') {
            rm.hybridMode = true;
            rm.currentHybridMethod = getRandomRecoveryMethod();
            bot.recoveryMethods.selected = rm.currentHybridMethod;
            updateLogs(0, 0, 0, `ğŸ² Hybrid Recovery: Selected ${rm.currentHybridMethod.toUpperCase()}`, true);
        } else {
            rm.hybridMode = false;
            rm.currentHybridMethod = null;
            rm.hybridMethodsUsed = [];
        }
        
        switch(bot.recoveryMethods.selected) {
            case 'martingale':
                break;
                
            case 'paroli':
                rm.paroliBaseBet = rm.basebet;
                rm.paroliWinStreak = 0;
                break;
                
            case 'dAlembert':
                rm.dAlembertLevel = 0;
                break;
                
            case 'labouchere':
                rm.labouchereSequence = [
                    rm.basebet * 0.5,
                    rm.basebet,
                    rm.basebet * 1.5
                ];
                rm.laboucherePointer = 0;
                break;
                
            case 'fibonacci':
                rm.fibonacciIndex = 0;
                break;
        }
        
        updateLogs(0, 0, 0, `ğŸ”„ Recovery method initialized: ${bot.recoveryMethods.selected.toUpperCase()}`, true);
    }

    function calculateRecoveryBet() {
        const rm = bot.recoveryMode;
        let method = bot.recoveryMethods.selected;
        
        if (rm.hybridMode && rm.currentStep > 0 && rm.currentStep % 5 === 0) {
            const oldMethod = method;
            method = getRandomRecoveryMethod();
            bot.recoveryMethods.selected = method;
            rm.currentHybridMethod = method;
            updateLogs(0, 0, 0, `ğŸ”„ Hybrid: Switching from ${oldMethod.toUpperCase()} to ${method.toUpperCase()}`, true);
            
            initializeRecoveryMethod();
        }
        
        let betAmount = rm.basebet;
        
        const remainingProfit = rm.recoveryTarget - bot.stats.currentBal;
        
        if (remainingProfit <= 0) {
            return bot.globalMinBet;
        }
        
        switch(method) {
            case 'martingale':
                if (bot.martingaleSettings.useSequence) {
                    const sequenceIndex = Math.min(
                        rm.consecutiveLosses, 
                        bot.martingaleSettings.multiplierSequence.length - 1
                    );
                    betAmount = rm.basebet * bot.martingaleSettings.multiplierSequence[sequenceIndex];
                } else {
                    betAmount = rm.basebet * Math.pow(bot.martingaleSettings.baseMultiplier, rm.consecutiveLosses);
                }
                
                const maxBetByMultiplier = rm.basebet * bot.martingaleSettings.maxMultiplier;
                if (betAmount > maxBetByMultiplier) {
                    betAmount = maxBetByMultiplier;
                }
                break;
                
            case 'paroli':
                if (rm.consecutiveWins > 0) {
                    betAmount = rm.paroliBaseBet * Math.pow(2, rm.consecutiveWins);
                } else {
                    betAmount = rm.paroliBaseBet;
                }
                break;
                
            case 'dAlembert':
                betAmount = rm.basebet + (rm.dAlembertLevel * rm.basebet * 0.5);
                if (betAmount < rm.basebet) betAmount = rm.basebet;
                break;
                
            case 'labouchere':
                if (rm.labouchereSequence.length === 0) {
                    betAmount = rm.basebet;
                } else {
                    betAmount = rm.labouchereSequence[rm.laboucherePointer];
                }
                break;
                
            case 'fibonacci':
                betAmount = rm.basebet * rm.fibonacciSequence[rm.fibonacciIndex];
                break;
        }
        
        const maxBet = bot.stats.currentBal * 0.15;
        if (betAmount > maxBet) {
            betAmount = maxBet;
        }
        
        if (betAmount < bot.globalMinBet) betAmount = bot.globalMinBet;
        
        return betAmount;
    }

    function updateRecoveryMethodAfterBet(win) {
        const rm = bot.recoveryMode;
        const method = bot.recoveryMethods.selected;
        
        if (win) {
            rm.consecutiveWins++;
            rm.consecutiveLosses = 0;
            
            switch(method) {
                case 'martingale':
                    if (bot.martingaleSettings.resetOnWin) {
                        rm.consecutiveLosses = 0;
                    }
                    break;
                    
                case 'paroli':
                    break;
                    
                case 'dAlembert':
                    rm.dAlembertLevel = Math.max(0, rm.dAlembertLevel - 1);
                    break;
                    
                case 'labouchere':
                    if (rm.labouchereSequence.length >= 2) {
                        rm.labouchereSequence.shift();
                        rm.labouchereSequence.pop();
                    }
                    rm.laboucherePointer = 0;
                    break;
                    
                case 'fibonacci':
                    rm.fibonacciIndex = Math.max(0, rm.fibonacciIndex - 2);
                    break;
            }
        } else {
            rm.consecutiveWins = 0;
            rm.consecutiveLosses++;
            
            if (method === 'martingale' && rm.consecutiveLosses >= bot.martingaleSettings.maxLossStreak) {
                updateLogs(0, 0, 0, `âš ï¸ Martingale max loss streak reached (${bot.martingaleSettings.maxLossStreak})`, true);
                bot.wagerMode.lossTriggered = true;
                setTimeout(() => {
                    switchToRecoveryMode();
                }, 1000);
            }
            
            switch(method) {
                case 'martingale':
                    break;
                    
                case 'paroli':
                    rm.paroliWinStreak = 0;
                    break;
                    
                case 'dAlembert':
                    rm.dAlembertLevel++;
                    break;
                    
                case 'labouchere':
                    const lastBet = bot.stats.lastResults[0]?.betAmount || rm.basebet;
                    rm.labouchereSequence.push(lastBet);
                    break;
                    
                case 'fibonacci':
                    rm.fibonacciIndex = Math.min(rm.fibonacciSequence.length - 1, rm.fibonacciIndex + 1);
                    break;
            }
        }
    }

    // =============== HYBRID WAGER FUNCTIONS ===============
    function initHybridWager() {
        bot.wagerMode.active = true;
        bot.recoveryMode.active = false;
        bot.wagerMode.startBalance = bot.stats.currentBal;
        
        bot.wagerMode.basebetDice = bot.stats.currentBal * 0.01;
        bot.wagerMode.basebetLimbo = bot.stats.currentBal * 0.005;
        
        bot.wagerMode.dicePayout = 99 / bot.wagerMode.diceChance;
        bot.wagerMode.limboPayout = bot.wagerMode.limboMultiplier;
        
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        bot.wagerMode.lossTriggered = false;
        
        if (bot.wagerMode.basebetDice < bot.globalMinBet) bot.wagerMode.basebetDice = bot.globalMinBet;
        if (bot.wagerMode.basebetLimbo < bot.globalMinBet) bot.wagerMode.basebetLimbo = bot.globalMinBet;
        
        updateLogs(0, 0, 0, `ğŸ¯ HYBRID WAGER STARTED`, true);
        updateLogs(0, 0, 0, `ğŸ’° Start Balance: ${bot.wagerMode.startBalance.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ² Dice: ${bot.wagerMode.basebetDice.toFixed(8)} @ ${bot.wagerMode.diceChance}% (Payout: ${bot.wagerMode.dicePayout.toFixed(4)}x)`, true);
        updateLogs(0, 0, 0, `ğŸ² Limbo: ${bot.wagerMode.basebetLimbo.toFixed(8)} @ ${bot.wagerMode.limboMultiplier}x (Payout: ${bot.wagerMode.limboPayout.toFixed(4)}x)`, true);
        updateLogs(0, 0, 0, `ğŸ“Š Pattern: ${bot.wagerMode.diceBetsPerCycle} Dice â†’ ${bot.wagerMode.limboBetsPerCycle} Limbo`, true);
        updateLogs(0, 0, 0, `âš¡ Speed: ${bot.speedSettings.turboMode ? 'TURBO' : 'NORMAL'}`, true);
    }

    function hybridWagerBetLogic() {
        const wm = bot.wagerMode;
        
        const profitFromStart = bot.stats.currentBal - wm.startBalance;
        
        if (profitFromStart < -wm.startBalance * (wm.stopLossPercent / 100)) {
            const lossAmount = Math.abs(profitFromStart);
            const lossPercent = (lossAmount / wm.startBalance) * 100;
            
            if (!wm.lossTriggered) {
                wm.lossTriggered = true;
                updateLogs(0, 0, 0, `âš ï¸ Loss from start balance: ${lossAmount.toFixed(8)} (${lossPercent.toFixed(2)}%)`, true);
                updateLogs(0, 0, 0, `ğŸ”„ Switching to Recovery Mode`, true);
                
                if (CONFIG.telegram.enabled) {
                    TelegramAPI.sendModeSwitchToRecovery(lossAmount, lossPercent);
                }
                
                setTimeout(() => {
                    switchToRecoveryMode();
                }, 1000);
                return null;
            }
        }
        
        if (checkTriggers()) {
            return null;
        }
        
        if (wm.currentMode === 'dice') {
            wm.diceBetCount++;
            
            if (wm.diceBetCount >= wm.diceBetsPerCycle) {
                wm.currentMode = 'limbo';
                wm.diceBetCount = 0;
                updateLogs(0, 0, 0, `ğŸ”„ Switching to Limbo Mode (${wm.limboBetsPerCycle} bets)`, true);
            }
        } else {
            wm.limboBetCount++;
            
            if (wm.limboBetCount >= wm.limboBetsPerCycle) {
                wm.currentMode = 'dice';
                wm.limboBetCount = 0;
                updateLogs(0, 0, 0, `ğŸ”„ Switching to Dice Mode (${wm.diceBetsPerCycle} bets)`, true);
            }
        }
        
        let betAmount = wm.currentMode === 'dice' ? wm.basebetDice : wm.basebetLimbo;
        
        if (bot.bettingSystems.paroli) {
            const lastResult = bot.stats.lastResults[0];
            if (lastResult && lastResult.win) {
                betAmount = lastResult.betAmount * 2;
            }
        } else if (bot.bettingSystems.dAlembert) {
            const lastResult = bot.stats.lastResults[0];
            if (lastResult) {
                if (lastResult.win) {
                    betAmount = Math.max(bot.globalMinBet, betAmount * 0.9);
                } else {
                    betAmount = betAmount * 1.1;
                }
            }
        }
        
        const maxBet = bot.stats.currentBal * 0.02;
        if (betAmount > maxBet) betAmount = maxBet;
        if (betAmount < bot.globalMinBet) betAmount = bot.globalMinBet;
        
        if (wm.currentMode === 'dice') {
            return {
                bet: betAmount,
                chance: wm.diceChance,
                payout: wm.dicePayout,
                mode: 'dice'
            };
        } else {
            return {
                bet: betAmount,
                multiplier: wm.limboMultiplier,
                payout: wm.limboPayout,
                mode: 'limbo'
            };
        }
    }

    // =============== RECOVERY MODE FUNCTIONS ===============
    function initRecoveryMode() {
        bot.wagerMode.active = false;
        bot.recoveryMode.active = true;
        
        bot.recoveryMode.originalLoss = bot.wagerMode.startBalance - bot.stats.currentBal;
        bot.recoveryMode.recoveryTarget = bot.wagerMode.startBalance;
        bot.recoveryMode.requiredProfit = bot.recoveryMode.originalLoss;
        
        const payout = 99 / bot.recoveryMode.chance;
        const profitMultiplier = payout - 1;
        const optimalBet = (bot.recoveryMode.requiredProfit * 1.5) / profitMultiplier;
        
        const maxBet = bot.stats.currentBal * 0.1;
        bot.recoveryMode.basebet = Math.min(optimalBet, maxBet);
        
        if (bot.recoveryMode.basebet < bot.globalMinBet) {
            bot.recoveryMode.basebet = bot.globalMinBet;
        }
        
        initializeRecoveryMethod();
        
        updateLogs(0, 0, 0, `ğŸ”„ RECOVERY MODE STARTED`, true);
        updateLogs(0, 0, 0, `ğŸ’° Wager Start: ${bot.wagerMode.startBalance.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ’° Current: ${bot.stats.currentBal.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ“‰ Loss to recover: ${bot.recoveryMode.originalLoss.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ¯ Target: ${bot.recoveryMode.recoveryTarget.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ’° Base Bet: ${bot.recoveryMode.basebet.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ² Chance: ${bot.recoveryMode.chance}% (Payout: ${payout.toFixed(4)}x)`, true);
        updateLogs(0, 0, 0, `ğŸ“Š Method: ${bot.recoveryMethods.selected.toUpperCase()}${bot.recoveryMode.hybridMode ? ' (HYBRID)' : ''}`, true);
    }

    function recoveryBetLogic() {
        const rm = bot.recoveryMode;
        
        if (rm.recoveryComplete) {
            return null;
        }
        
        rm.currentStep++;
        
        const currentProfit = bot.stats.currentBal - bot.wagerMode.startBalance;
        
        if (currentProfit >= bot.wagerMode.profitTrigger.minProfitThreshold) {
            const recovered = bot.stats.currentBal - (rm.recoveryTarget - rm.originalLoss);
            
            updateLogs(0, 0, 0, `âœ… RECOVERY COMPLETE - Back to profit!`, true);
            updateLogs(0, 0, 0, `ğŸ’° Profit from start: ${currentProfit.toFixed(8)}`, true);
            updateLogs(0, 0, 0, `ğŸ’° Recovered: ${recovered.toFixed(8)} in ${rm.currentStep} steps`, true);
            updateLogs(0, 0, 0, `ğŸ”„ Returning to Wager Mode`, true);
            
            if (CONFIG.telegram.enabled) {
                TelegramAPI.sendRecoveryComplete(recovered, rm.currentStep);
            }
            
            rm.recoveryComplete = true;
            setTimeout(() => {
                switchToWagerMode();
            }, 1000);
            return null;
        }
        
        if (rm.currentStep > rm.maxSteps) {
            const currentLoss = rm.recoveryTarget - bot.stats.currentBal;
            const recovered = rm.originalLoss - currentLoss;
            
            updateLogs(0, 0, 0, `âš ï¸ Max recovery steps reached (${rm.maxSteps})`, true);
            updateLogs(0, 0, 0, `ğŸ“Š Partially recovered ${recovered.toFixed(8)} of ${rm.originalLoss.toFixed(8)}`, true);
            updateLogs(0, 0, 0, `ğŸ”„ Returning to Wager Mode`, true);
            
            rm.recoveryComplete = true;
            setTimeout(() => {
                switchToWagerMode();
            }, 1000);
            return null;
        }
        
        if (bot.stats.currentBal < bot.globalMinBet) {
            updateLogs(0, 0, 0, `âš ï¸ Insufficient balance for recovery`, true);
            updateLogs(0, 0, 0, `ğŸ”„ Returning to Wager Mode`, true);
            
            rm.recoveryComplete = true;
            setTimeout(() => {
                switchToWagerMode();
            }, 1000);
            return null;
        }
        
        if (checkTriggers()) {
            return null;
        }
        
        if (rm.currentStep % 5 === 0) {
            const remainingProfit = rm.recoveryTarget - bot.stats.currentBal;
            updateLogs(0, 0, 0, `ğŸ“Š Recovery Progress: Step ${rm.currentStep}/${rm.maxSteps}, Need ${remainingProfit.toFixed(8)}`, true);
        }
        
        const betAmount = calculateRecoveryBet();
        
        return {
            bet: betAmount,
            chance: rm.chance,
            mode: 'dice'
        };
    }

    // =============== MODE SWITCHING ===============
    function switchToWagerMode() {
        bot.recoveryMode.active = false;
        bot.recoveryMode.recoveryComplete = false;
        bot.recoveryMode.currentStep = 0;
        bot.recoveryMode.consecutiveLosses = 0;
        bot.recoveryMode.consecutiveWins = 0;
        bot.recoveryMode.hybridMethodsUsed = [];
        
        bot.wagerMode.startBalance = bot.stats.currentBal;
        bot.wagerMode.basebetDice = bot.stats.currentBal * 0.01;
        bot.wagerMode.basebetLimbo = bot.stats.currentBal * 0.005;
        bot.wagerMode.lossTriggered = false;
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        
        bot.wagerMode.active = true;
        
        updateLogs(0, 0, 0, `ğŸ¯ RETURNING TO WAGER MODE`, true);
        updateLogs(0, 0, 0, `ğŸ’° New Start Balance: ${bot.wagerMode.startBalance.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ² Dice Bet: ${bot.wagerMode.basebetDice.toFixed(8)}`, true);
        updateLogs(0, 0, 0, `ğŸ² Limbo Bet: ${bot.wagerMode.basebetLimbo.toFixed(8)}`, true);
        
        updateUI();
    }

    function switchToRecoveryMode() {
        initRecoveryMode();
        updateUI();
    }

    // =============== SPEED CONTROL ===============
    function getCurrentSpeed() {
        if (bot.isDemo) return bot.speedSettings.demoSpeed;
        if (bot.recoveryMode.active) return bot.speedSettings.recoverySpeed;
        return bot.speedSettings.turboMode ? bot.speedSettings.wagerSpeed : 100;
    }

    // =============== API FUNCTIONS ===============
    const API = {
        async syncOnce() {
            try {
                bot.token = localStorage.getItem('apitoken') || 
                           localStorage.getItem('token') ||
                           sessionStorage.getItem('token') ||
                           (document.cookie.match(/session=([^;]+)/) ? document.cookie.match(/session=([^;]+)/)[1] : null) ||
                           (document.cookie.match(/token=([^;]+)/) ? document.cookie.match(/token=([^;]+)/)[1] : null);
                
                if (!bot.token) {
                    console.log("No token found");
                    bot.stakeUser = "Not logged in";
                    return;
                }

                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{name balances{available{amount currency}}}}`
                    })
                });
                
                if (!res.ok) throw new Error(`API request failed: ${res.status}`);
                
                const json = await res.json();
                
                if (json?.data?.user) {
                    bot.stakeUser = json.data.user.name;
                    
                    const bals = json.data.user.balances || [];
                    const selectedBal = bals.find(b => 
                        b.available && b.available.currency && 
                        b.available.currency.toLowerCase() === bot.selectedCurrency.toLowerCase()
                    );
                    
                    if (selectedBal) {
                        bot.realBalance = parseFloat(selectedBal.available.amount);
                    }
                    
                    const sel = document.getElementById("p-currency");
                    
                    if (sel && bals.length > 0) {
                        const currentSelection = bot.selectedCurrency;
                        sel.innerHTML = '';
                        
                        bals.forEach(b => {
                            if (b.available && b.available.currency) {
                                const currency = b.available.currency.toLowerCase();
                                const opt = new Option(currency.toUpperCase(), currency);
                                sel.add(opt);
                            }
                        });

                        const availableCurrencies = bals
                            .filter(b => b.available && b.available.currency)
                            .map(b => b.available.currency.toLowerCase());
                        
                        if (availableCurrencies.includes(currentSelection)) {
                            sel.value = currentSelection;
                            bot.selectedCurrency = currentSelection;
                        } else if (availableCurrencies.includes('doge')) {
                            sel.value = 'doge';
                            bot.selectedCurrency = 'doge';
                        } else if (availableCurrencies.length > 0) {
                            sel.value = availableCurrencies[0];
                            bot.selectedCurrency = availableCurrencies[0];
                        }
                    }
                    
                    updateLogs(0, 0, 0, `âœ… Synced: ${bot.stakeUser}`, true);
                    updateLogs(0, 0, 0, `ğŸ’° Real Balance: ${bot.realBalance.toFixed(8)} ${bot.selectedCurrency.toUpperCase()}`, true);
                    
                } else {
                    console.error("Invalid API response:", json);
                    bot.stakeUser = "API Error";
                }
                
            } catch (e) {
                console.error("Sync error:", e);
                bot.stakeUser = "Connection Error";
                updateLogs(0, 0, 0, `âš ï¸ Sync error: ${e.message}`, true);
            }
        },

        async getBalance(coin) {
            if (bot.isDemo) return bot.stats.currentBal;
            
            try {
                if (!bot.token) await this.syncOnce();
                
                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "x-access-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{balances{available{amount currency}}}}`
                    })
                });
                const json = await res.json();
                const active = json.data.user.balances.find(b =>
                    b.available.currency.toLowerCase() === coin.toLowerCase()
                );
                const balance = active ? parseFloat(active.available.amount) : 0;
                bot.realBalance = balance;
                return balance;
            } catch (e) {
                console.log("Balance error:", e);
                return 0;
            }
        },

        async placeDiceBet(amount, chance) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() * 100 < chance;
                    setTimeout(() => {
                        r({
                            diceRoll: {
                                amount: amount,
                                payout: win ? (amount * (99 / chance)) : 0
                            }
                        });
                    }, getCurrentSpeed());
                });
            }

            const payload = {
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency,
                target: parseFloat((100 - chance).toFixed(2)),
                condition: "above",
                identifier: Math.random().toString(36).slice(2) + Date.now()
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/dice/roll`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token,
                        "x-lockdown-token": "s5MNWtjTM5TvCMkAzxov"
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                console.error("Dice bet error:", error);
                throw error;
            }
        },

        async placeLimboBet(amount, multiplierTarget) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() < (1 / multiplierTarget);
                    setTimeout(() => {
                        r({
                            limboBet: {
                                amount: amount,
                                payout: win ? (amount * multiplierTarget) : 0,
                                state: {
                                    result: win ? multiplierTarget : (multiplierTarget * Math.random()),
                                    multiplierTarget: multiplierTarget
                                }
                            }
                        });
                    }, getCurrentSpeed());
                });
            }

            const payload = {
                multiplierTarget: multiplierTarget,
                identifier: Math.random().toString(36).slice(2) + Date.now(),
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/limbo/bet`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token,
                        "x-lockdown-token": "s5MNWtjTM5TvCMkAzxov",
                        "x-requested-with": "XMLHttpRequest"
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Limbo bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                console.error("Limbo bet error:", error);
                throw error;
            }
        }
    };

    // =============== MAIN GAME LOOP ===============
    async function runLoop() {
        if (!bot.isRunning || bot.isPaused) return;

        try {
            if (!bot.isDemo && bot.stats.bets % 10 === 0) {
                const realBal = await API.getBalance(bot.selectedCurrency);
                bot.realBalance = realBal;
            }

            TelegramAPI.sendPeriodicReport();

            let betInfo = null;
            
            if (bot.wagerMode.active) {
                betInfo = hybridWagerBetLogic();
            } else if (bot.recoveryMode.active) {
                betInfo = recoveryBetLogic();
            }
            
            if (betInfo === null) {
                setTimeout(runLoop, 100);
                return;
            }

            let nextBet = betInfo.bet;
            let chance = betInfo.chance;
            let multiplier = betInfo.multiplier;
            let gameMode = betInfo.mode;
            let payout = betInfo.payout;

            if (nextBet <= 0) nextBet = bot.globalMinBet;
            if (nextBet < bot.globalMinBet) nextBet = bot.globalMinBet;
            
            if (!bot.isDemo) {
                if (nextBet > bot.realBalance && bot.realBalance > 0) {
                    nextBet = bot.realBalance;
                    updateLogs(0, 0, 0, `âš ï¸ Bet capped at real balance: ${nextBet.toFixed(8)}`, true);
                }
                
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                    updateLogs(0, 0, 0, `âš ï¸ Bet capped at bot balance: ${nextBet.toFixed(8)}`, true);
                }
            } else {
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                    updateLogs(0, 0, 0, `âš ï¸ Bet capped at demo balance: ${nextBet.toFixed(8)}`, true);
                }
            }

            let res;
            if (gameMode === 'dice') {
                res = await API.placeDiceBet(nextBet, chance);
            } else if (gameMode === 'limbo') {
                res = await API.placeLimboBet(nextBet, multiplier);
            }

            let win = false;
            let pft = 0;
            let betAmount = nextBet;

            if (res) {
                if (gameMode === 'dice') {
                    const d = res?.data?.diceRoll || res?.diceRoll;
                    if (d) {
                        win = d.payout > 0;
                        pft = d.payout - d.amount;
                        betAmount = d.amount;
                    }
                } else if (gameMode === 'limbo') {
                    const lb = res?.data?.limboBet || res?.limboBet;
                    if (lb) {
                        const resultMultiplier = lb.state?.result || 0;
                        const targetMultiplier = lb.state?.multiplierTarget || multiplier;
                        win = resultMultiplier >= targetMultiplier;
                        pft = win ? (lb.amount * (targetMultiplier - 1)) : -lb.amount;
                        betAmount = lb.amount;
                    }
                }
            }

            bot.stats.bets++;
            bot.stats.wagered += betAmount;
            bot.stats.profit += pft;
            bot.stats.currentBal += pft;
            bot.stats.lastBetAmount = betAmount;

            if (!bot.isDemo) {
                bot.realBalance += pft;
            }

            bot.stats.lastResults.unshift({
                win: win,
                betAmount: betAmount,
                profit: pft,
                chance: chance,
                multiplier: multiplier,
                payout: payout,
                mode: gameMode,
                time: new Date().toLocaleTimeString()
            });
            
            if (bot.stats.lastResults.length > 5) {
                bot.stats.lastResults.pop();
            }

            if (win) {
                bot.stats.wins++;
                if (bot.recoveryMode.active) {
                    updateRecoveryMethodAfterBet(true);
                }
            } else {
                bot.stats.loss++;
                if (bot.recoveryMode.active) {
                    updateRecoveryMethodAfterBet(false);
                }
            }

            updateStatistics(win, betAmount, pft);

            let logLine;
            let patternInfo = "";
            
            if (bot.wagerMode.active) {
                if (gameMode === 'dice') {
                    patternInfo = `[Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}]`;
                } else {
                    patternInfo = `[Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}]`;
                }
            }
            
            if (gameMode === 'dice') {
                logLine = `${patternInfo} ${gameMode.toUpperCase()}: ${betAmount.toFixed(8)} @ ${chance}% (${payout.toFixed(4)}x) â†’ ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            } else {
                logLine = `${patternInfo} ${gameMode.toUpperCase()}: ${betAmount.toFixed(8)} @ ${multiplier}x (${payout.toFixed(4)}x) â†’ ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            }
            
            if (bot.recoveryMode.active) {
                const remainingProfit = bot.recoveryMode.recoveryTarget - bot.stats.currentBal;
                const methodInfo = bot.recoveryMethods.selected.toUpperCase();
                const methodStatus = getRecoveryMethodStatus();
                logLine = `ğŸ”„ ${methodInfo} ${methodStatus}: ${logLine} (Step: ${bot.recoveryMode.currentStep}, Need: ${remainingProfit.toFixed(8)})`;
            }
            
            updateLogs(betAmount, pft, chance, logLine);

            updateDashboard();
            updateLiveLogs();

            if (bot.isRunning && !bot.isPaused) {
                const delay = getCurrentSpeed();
                setTimeout(runLoop, delay);
            }

        } catch (e) {
            console.error("Run loop error:", e);
            updateLogs(0, 0, 0, `âš ï¸ Error: ${e.message}`, true);
            
            if (bot.isRunning && !bot.isPaused) {
                setTimeout(runLoop, 100);
            }
        }
    }

    function getRecoveryMethodStatus() {
        if (!bot.recoveryMode.active) return '';
        
        const rm = bot.recoveryMode;
        const method = bot.recoveryMethods.selected;
        
        switch(method) {
            case 'martingale':
                return `[L:${rm.consecutiveLosses}]`;
            case 'paroli':
                return `[W:${rm.consecutiveWins}]`;
            case 'dAlembert':
                return `[Lvl:${rm.dAlembertLevel}]`;
            case 'labouchere':
                return `[Seq:${rm.labouchereSequence.length}]`;
            case 'fibonacci':
                return `[Idx:${rm.fibonacciIndex}]`;
            default:
                return '';
        }
    }

    // =============== UI FUNCTIONS ===============
    function updateDashboard() {
        const accountName = document.getElementById("account-name");
        if (accountName) accountName.textContent = bot.stakeUser;
        
        const licenseStatus = document.getElementById("license-status");
        if (licenseStatus) {
            licenseStatus.textContent = CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED";
            licenseStatus.style.color = CONFIG.license.isValid() ? "#10b981" : "#ef4444";
        }
        
        const balanceEl = document.getElementById("balance");
        if (balanceEl) {
            if (bot.isDemo) {
                balanceEl.textContent = bot.stats.currentBal.toFixed(8);
                balanceEl.title = `Demo Balance`;
            } else {
                balanceEl.textContent = bot.realBalance.toFixed(8);
                balanceEl.title = `Real Balance`;
            }
        }
        
        const profitEl = document.getElementById("profit");
        if (profitEl) profitEl.textContent = bot.stats.profit.toFixed(8);
        
        const profitPercent = bot.stats.startBal > 0 ? (bot.stats.profit / bot.stats.startBal * 100) : 0;
        const profitPercentEl = document.getElementById("profit-percent");
        if (profitPercentEl) profitPercentEl.textContent = profitPercent.toFixed(2) + '%';
        
        const betsEl = document.getElementById("bets");
        if (betsEl) betsEl.textContent = bot.stats.bets;
        
        const wageredEl = document.getElementById("wagered");
        if (wageredEl) wageredEl.textContent = bot.stats.wagered.toFixed(8);
        
        const maxDDEl = document.getElementById("max-dd");
        if (maxDDEl) maxDDEl.textContent = `${bot.stats.maxDrawdown.toFixed(8)} (${bot.stats.drawdownPercentage.toFixed(2)}%)`;
        
        const modeIndicator = document.getElementById("mode-indicator");
        if (modeIndicator) {
            if (bot.wagerMode.active) {
                let patternInfo = "";
                if (bot.wagerMode.currentMode === 'dice') {
                    patternInfo = `Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}`;
                } else {
                    patternInfo = `Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}`;
                }
                modeIndicator.textContent = `WAGER MODE (${patternInfo})`;
                modeIndicator.style.color = "#10b981";
                
                const profitFromStart = bot.stats.currentBal - bot.wagerMode.startBalance;
                modeIndicator.title = `Profit from Start: ${profitFromStart.toFixed(8)}\nStart Balance: ${bot.wagerMode.startBalance.toFixed(8)}\nDice Bet: ${bot.wagerMode.basebetDice.toFixed(8)}\nLimbo Bet: ${bot.wagerMode.basebetLimbo.toFixed(8)}`;
            } else if (bot.recoveryMode.active) {
                const remainingProfit = bot.recoveryMode.recoveryTarget - bot.stats.currentBal;
                const methodStatus = getRecoveryMethodStatus();
                const method = bot.recoveryMode.hybridMode ? `HYBRID (${bot.recoveryMode.currentHybridMethod})` : bot.recoveryMethods.selected;
                modeIndicator.textContent = `RECOVERY (${method.toUpperCase()}${methodStatus})`;
                modeIndicator.style.color = "#f59e0b";
                modeIndicator.title = `Target: ${bot.recoveryMode.recoveryTarget.toFixed(8)}\nNeed: ${remainingProfit.toFixed(8)}\nStep: ${bot.recoveryMode.currentStep}/${bot.recoveryMode.maxSteps}\nOriginal Loss: ${bot.recoveryMode.originalLoss.toFixed(8)}`;
            } else {
                modeIndicator.textContent = "STOPPED";
                modeIndicator.style.color = "#94a3b8";
            }
            
            if (bot.isPaused) {
                modeIndicator.textContent += " (PAUSED)";
                modeIndicator.style.color = "#f59e0b";
            }
        }
        
        const turboIndicator = document.getElementById("turbo-indicator");
        if (turboIndicator) {
            if (bot.recoveryMode.active) {
                turboIndicator.textContent = "RECOVERY";
                turboIndicator.style.color = "#f59e0b";
            } else {
                turboIndicator.textContent = bot.speedSettings.turboMode ? "TURBO ON" : "TURBO OFF";
                turboIndicator.style.color = bot.speedSettings.turboMode ? "#10b981" : "#94a3b8";
            }
        }
        
        const balanceInfo = document.getElementById("balance-info");
        if (balanceInfo) {
            if (bot.isDemo) {
                balanceInfo.textContent = `DEMO (${bot.speedSettings.demoSpeed}ms)`;
            } else if (bot.recoveryMode.active) {
                balanceInfo.textContent = `RECOVERY (${bot.speedSettings.recoverySpeed}ms)`;
            } else {
                balanceInfo.textContent = bot.speedSettings.turboMode ? `TURBO (${bot.speedSettings.wagerSpeed}ms)` : "NORMAL";
            }
        }
        
        const winStreakEl = document.getElementById("win-streak");
        if (winStreakEl) winStreakEl.textContent = bot.stats.winStreak;
        
        const lossStreakEl = document.getElementById("loss-streak");
        if (lossStreakEl) lossStreakEl.textContent = bot.stats.lossStreak;
    }

    function updateLiveLogs() {
        const logContainer = document.getElementById("live-log");
        if (!logContainer) return;
        
        let html = "";
        if (bot.stats.lastResults.length === 0) {
            html = '<div style="color: #94a3b8; text-align: center; padding: 10px;">No bets yet</div>';
        } else {
            bot.stats.lastResults.forEach(result => {
                const color = result.win ? "#10b981" : "#ef4444";
                const winLoss = result.win ? "WIN" : "LOSS";
                const modeIcon = bot.recoveryMode.active ? "ğŸ”„ " : "";
                
                if (result.mode === 'dice') {
                    html += `
                        <div class="log-entry" style="color: ${color}; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <span style="font-size: 10px;">${result.time}</span>
                            <span style="margin-left: 8px;">${modeIcon}${result.mode}: ${result.betAmount.toFixed(8)} @ ${result.chance}% (${result.payout.toFixed(4)}x)</span>
                            <span style="margin-left: 8px; font-weight: bold;">${winLoss}</span>
                            <span style="margin-left: 8px;">${result.profit > 0 ? '+' : ''}${result.profit.toFixed(8)} ${bot.selectedCurrency.toUpperCase()}</span>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="log-entry" style="color: ${color}; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <span style="font-size: 10px;">${result.time}</span>
                            <span style="margin-left: 8px;">${modeIcon}${result.mode}: ${result.betAmount.toFixed(8)} @ ${result.multiplier}x (${result.payout.toFixed(4)}x)</span>
                            <span style="margin-left: 8px; font-weight: bold;">${winLoss}</span>
                            <span style="margin-left: 8px;">${result.profit > 0 ? '+' : ''}${result.profit.toFixed(8)} ${bot.selectedCurrency.toUpperCase()}</span>
                        </div>
                    `;
                }
            });
        }
        
        logContainer.innerHTML = html;
    }

    function updateLogs(amt, pft, ch, customMsg = null, isSystem = false) {
        const logBox = document.getElementById("p-logs");
        if (!logBox) return;

        const entry = document.createElement("div");
        entry.className = "log-entry";

        if (isSystem) {
            entry.style.color = "#f59e0b";
            entry.style.fontWeight = "bold";
        } else {
            entry.style.color = pft > 0 ? "#10b981" : "#ef4444";
        }

        if (customMsg) {
            entry.innerHTML = customMsg;
        } else {
            entry.innerHTML = `Bet: ${amt.toFixed(8)} ${bot.selectedCurrency.toUpperCase()} @ ${ch}% â†’ ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
        }

        logBox.prepend(entry);
        
        if (logBox.children.length > 100) {
            logBox.removeChild(logBox.lastChild);
        }
    }

    function updateUI() {
        const diceBetInput = document.getElementById("dice-bet");
        if (diceBetInput) diceBetInput.value = bot.wagerMode.basebetDice;
        
        const diceChanceInput = document.getElementById("dice-chance");
        if (diceChanceInput) diceChanceInput.value = bot.wagerMode.diceChance;
        
        const limboBetInput = document.getElementById("limbo-bet");
        if (limboBetInput) limboBetInput.value = bot.wagerMode.basebetLimbo;
        
        const limboMultiplierInput = document.getElementById("limbo-multiplier");
        if (limboMultiplierInput) limboMultiplierInput.value = bot.wagerMode.limboMultiplier;
        
        const wagerStopLoss = document.getElementById("wager-stop-loss");
        if (wagerStopLoss) wagerStopLoss.value = bot.wagerMode.stopLossPercent;
        
        const diceBetsInput = document.getElementById("dice-bets");
        if (diceBetsInput) diceBetsInput.value = bot.wagerMode.diceBetsPerCycle;
        
        const limboBetsInput = document.getElementById("limbo-bets");
        if (limboBetsInput) limboBetsInput.value = bot.wagerMode.limboBetsPerCycle;
        
        const recoveryBetInput = document.getElementById("recovery-bet");
        if (recoveryBetInput) recoveryBetInput.value = bot.recoveryMode.basebet;
        
        const recoveryChance = document.getElementById("recovery-chance");
        if (recoveryChance) recoveryChance.value = bot.recoveryMode.chance;
        
        const minuteTriggerCheck = document.getElementById("minute-trigger-check");
        if (minuteTriggerCheck) minuteTriggerCheck.checked = bot.triggers.minuteTrigger.enabled;
        
        const minuteTriggerInput = document.getElementById("minute-trigger");
        if (minuteTriggerInput) minuteTriggerInput.value = bot.triggers.minuteTrigger.minutes;
        
        const lossTriggerCheck = document.getElementById("loss-trigger-check");
        if (lossTriggerCheck) lossTriggerCheck.checked = bot.triggers.lossTrigger.enabled;
        
        const lossTriggerAmount = document.getElementById("loss-trigger-amount");
        if (lossTriggerAmount) lossTriggerAmount.value = bot.triggers.lossTrigger.amount;
        
        const lossTriggerConsecutive = document.getElementById("loss-trigger-consecutive");
        if (lossTriggerConsecutive) lossTriggerConsecutive.value = bot.triggers.lossTrigger.consecutive;
        
        const wagerSpeedInput = document.getElementById("wager-speed");
        if (wagerSpeedInput) wagerSpeedInput.value = bot.speedSettings.wagerSpeed;
        
        const recoverySpeedInput = document.getElementById("recovery-speed");
        if (recoverySpeedInput) recoverySpeedInput.value = bot.speedSettings.recoverySpeed;
        
        const demoSpeedInput = document.getElementById("demo-speed");
        if (demoSpeedInput) demoSpeedInput.value = bot.speedSettings.demoSpeed;
        
        const turboCheck = document.getElementById("turbo-check");
        if (turboCheck) turboCheck.checked = bot.speedSettings.turboMode;
        
        const recoveryMethods = ['martingale', 'paroli', 'dAlembert', 'labouchere', 'fibonacci', 'hybrid'];
        recoveryMethods.forEach(method => {
            const checkbox = document.getElementById(`${method}-check`);
            const item = document.getElementById(`${method}-item`);
            
            if (checkbox) {
                checkbox.checked = bot.recoveryMethods.selected === method;
            }
            if (item) {
                item.classList.toggle('active', bot.recoveryMethods.selected === method);
            }
        });
        
        const demoCheck = document.getElementById("demo-check");
        if (demoCheck) demoCheck.checked = bot.isDemo;
        
        const demoWarning = document.getElementById("demo-warning");
        if (demoWarning) {
            demoWarning.style.display = "none";
        }
        
        const martingaleMultiplier = document.getElementById("martingale-multiplier");
        if (martingaleMultiplier) martingaleMultiplier.value = bot.martingaleSettings.baseMultiplier;
        
        const martingaleMax = document.getElementById("martingale-max");
        if (martingaleMax) martingaleMax.value = bot.martingaleSettings.maxMultiplier;
        
        const martingaleReset = document.getElementById("martingale-reset");
        if (martingaleReset) martingaleReset.checked = bot.martingaleSettings.resetOnWin;
        
        const martingaleSequence = document.getElementById("martingale-sequence");
        if (martingaleSequence) martingaleSequence.checked = bot.martingaleSettings.useSequence;
        
        const martingaleSequenceValues = document.getElementById("martingale-sequence-values");
        if (martingaleSequenceValues) martingaleSequenceValues.value = bot.martingaleSettings.multiplierSequence.join(', ');
        
        const martingaleMaxStreak = document.getElementById("martingale-max-streak");
        if (martingaleMaxStreak) martingaleMaxStreak.value = bot.martingaleSettings.maxLossStreak;
        
        updateDashboard();
        updateLiveLogs();
    }

    // =============== UI CREATION ===============
    function createUI() {
        if (document.getElementById("hybrid-wrap")) return;

        const s = document.createElement("style");
        s.innerHTML = `
            #hybrid-wrap {
                position: fixed;
                top: 10px;
                right: 10px;
                width: 100%;
                max-width: 420px;
                max-height: 90vh;
                background: rgba(15, 23, 42, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                color: #f8fafc;
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                font-size: 12px;
                z-index: 999999;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            
            .header {
                background: rgba(30, 41, 59, 0.9);
                padding: 12px 16px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-shrink: 0;
            }
            
            .header-left {
                flex: 1;
            }
            
            .app-title {
                font-size: 14px;
                font-weight: 700;
                color: #fff;
                margin-bottom: 2px;
            }
            
            .header-info {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                font-size: 10px;
                color: #94a3b8;
            }
            
            .header-info span {
                padding: 2px 6px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
            }
            
            .header-controls {
                display: flex;
                gap: 6px;
            }
            
            .control-btn {
                width: 28px;
                height: 28px;
                border-radius: 4px;
                background: rgba(255, 255, 255, 0.1);
                border: none;
                color: #fff;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
                touch-action: manipulation;
            }
            
            .control-btn:active {
                background: rgba(255, 255, 255, 0.2);
                transform: scale(0.95);
            }
            
            .content {
                padding: 16px;
                overflow-y: auto;
                flex: 1;
            }
            
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                margin-bottom: 16px;
            }
            
            .stat-card {
                background: rgba(30, 41, 59, 0.6);
                border-radius: 8px;
                padding: 10px;
                text-align: center;
                position: relative;
            }
            
            .stat-card.wide {
                grid-column: span 2;
            }
            
            .stat-label {
                font-size: 9px;
                color: #94a3b8;
                text-transform: uppercase;
                margin-bottom: 4px;
            }
            
            .stat-value {
                font-size: 14px;
                font-weight: 700;
                color: #fff;
                font-family: 'Courier New', monospace;
            }
            
            .stat-value.small {
                font-size: 12px;
            }
            
            .streak-container {
                display: flex;
                justify-content: space-between;
                margin-top: 8px;
            }
            
            .streak-item {
                text-align: center;
                flex: 1;
            }
            
            .streak-label {
                font-size: 8px;
                color: #94a3b8;
            }
            
            .streak-value {
                font-size: 12px;
                font-weight: bold;
            }
            
            .streak-value.win {
                color: #10b981;
            }
            
            .streak-value.loss {
                color: #ef4444;
            }
            
            .mode-indicator {
                background: rgba(30, 41, 59, 0.6);
                border-radius: 8px;
                padding: 8px;
                text-align: center;
                margin-bottom: 16px;
                font-weight: 600;
                cursor: help;
                font-size: 11px;
                word-break: break-word;
            }
            
            .settings-section {
                background: rgba(30, 41, 59, 0.6);
                border-radius: 8px;
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .section-title {
                font-size: 11px;
                font-weight: 600;
                color: #fff;
                margin-bottom: 8px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .section-subtitle {
                font-size: 10px;
                color: #94a3b8;
                margin: 8px 0 4px 0;
                padding-left: 4px;
            }
            
            .input-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 6px;
                flex-wrap: wrap;
            }
            
            .input-label {
                font-size: 10px;
                color: #94a3b8;
                width: 140px;
                margin-bottom: 4px;
            }
            
            .input-field {
                width: 80px;
                background: rgba(15, 23, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                padding: 4px 8px;
                color: #fff;
                font-size: 11px;
                font-family: 'Courier New', monospace;
                box-sizing: border-box;
            }
            
            .input-field:focus {
                outline: none;
                border-color: #3b82f6;
            }
            
            .checkbox-group {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 8px;
            }
            
            .checkbox-item {
                display: flex;
                align-items: center;
                gap: 4px;
                font-size: 10px;
                color: #94a3b8;
                cursor: pointer;
                padding: 4px 8px;
                border-radius: 4px;
                background: rgba(255, 255, 255, 0.05);
                flex: 1;
                min-width: 70px;
            }
            
            .checkbox-item input[type="checkbox"] {
                cursor: pointer;
            }
            
            .checkbox-item.active {
                color: #3b82f6;
                font-weight: bold;
                background: rgba(59, 130, 246, 0.2);
            }
            
            .control-buttons {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
                margin-bottom: 12px;
            }
            
            .main-btn {
                padding: 12px;
                border: none;
                border-radius: 8px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                touch-action: manipulation;
                transition: transform 0.1s ease;
            }
            
            .main-btn:active {
                transform: scale(0.95);
            }
            
            .btn-start {
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
            }
            
            .btn-stop {
                background: linear-gradient(135deg, #ef4444, #dc2626);
                color: white;
            }
            
            .btn-pause {
                background: linear-gradient(135deg, #f59e0b, #d97706);
                color: white;
            }
            
            .live-log {
                background: rgba(15, 23, 42, 0.8);
                border-radius: 8px;
                padding: 12px;
                height: 120px;
                overflow-y: auto;
                font-family: 'Courier New', monospace;
                font-size: 10px;
            }
            
            .log-entry {
                padding: 4px 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                word-break: break-word;
            }
            
            ::-webkit-scrollbar {
                width: 6px;
            }
            
            ::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 3px;
            }
            
            ::-webkit-scrollbar-thumb {
                background: #3b82f6;
                border-radius: 3px;
            }
            
            .demo-warning {
                background: rgba(245, 158, 11, 0.2);
                border: 1px solid rgba(245, 158, 11, 0.3);
                border-radius: 6px;
                padding: 8px;
                margin-bottom: 12px;
                text-align: center;
                font-size: 10px;
                color: #f59e0b;
            }
            
            .balance-info {
                font-size: 9px;
                color: #94a3b8;
                text-align: center;
                margin-top: 4px;
            }
            
            @media (max-width: 480px) {
                #hybrid-wrap {
                    top: 5px;
                    right: 5px;
                    left: 5px;
                    width: calc(100% - 10px);
                    max-width: none;
                    max-height: 95vh;
                }
                
                .stats-grid {
                    grid-template-columns: repeat(2, 1fr);
                }
                
                .stat-card {
                    padding: 8px;
                }
                
                .stat-value {
                    font-size: 12px;
                }
                
                .section-title {
                    font-size: 10px;
                }
                
                .input-label {
                    width: 120px;
                }
                
                .checkbox-item {
                    min-width: 65px;
                }
                
                .main-btn {
                    padding: 10px;
                    font-size: 10px;
                }
            }
            
            @media (max-width: 360px) {
                .input-row {
                    flex-direction: column;
                    align-items: flex-start;
                }
                
                .input-field {
                    width: 100%;
                    margin-top: 4px;
                }
                
                .checkbox-group {
                    gap: 4px;
                }
                
                .checkbox-item {
                    min-width: 60px;
                }
            }
            
            select.input-field {
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2394a3b8' d='M6 9L2 5h8z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 8px center;
                padding-right: 24px;
            }
            
            input[type="number"].input-field::-webkit-inner-spin-button,
            input[type="number"].input-field::-webkit-outer-spin-button {
                opacity: 1;
                height: 20px;
            }
        `;
        document.head.appendChild(s);

        const d = document.createElement("div");
        d.id = "hybrid-wrap";
        d.innerHTML = `
            <div class="header">
                <div class="header-left">
                    <div class="app-title">HYBRID WAGER v2.0</div>
                    <div class="header-info">
                        <span id="account-name">${bot.stakeUser}</span>
                        <span id="license-status">${CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED"}</span>
                        <span id="turbo-indicator">TURBO OFF</span>
                    </div>
                </div>
                <div class="header-controls">
                    <button class="control-btn sync" title="Sync">â†»</button>
                    <button class="control-btn minimize" title="Minimize">_</button>
                    <button class="control-btn close" title="Close">Ã—</button>
                </div>
            </div>
            
            <div class="content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Balance</div>
                        <div class="stat-value" id="balance">0.00000000</div>
                        <div class="balance-info" id="balance-info">${bot.isDemo ? 'DEMO' : 'REAL'} MODE</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Profit</div>
                        <div class="stat-value" id="profit">0.00000000</div>
                        <div style="font-size: 9px; color: #94a3b8;" id="profit-percent">0.00%</div>
                    </div>
                    <div class="stat-card wide">
                        <div class="stat-label">Wagered</div>
                        <div class="stat-value small" id="wagered">0.00000000</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Bets</div>
                        <div class="stat-value" id="bets">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Max DD</div>
                        <div class="stat-value small" id="max-dd">0.00000000 (0.00%)</div>
                    </div>
                    <div class="stat-card wide">
                        <div class="streak-container">
                            <div class="streak-item">
                                <div class="streak-label">Win Streak</div>
                                <div class="streak-value win" id="win-streak">0</div>
                            </div>
                            <div class="streak-item">
                                <div class="streak-label">Loss Streak</div>
                                <div class="streak-value loss" id="loss-streak">0</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mode-indicator" id="mode-indicator">
                    STOPPED
                </div>
                
                <div id="demo-warning" class="demo-warning" style="display: none;">
                    âš ï¸ DEMO MODE ACTIVE - No real money bets
                </div>
                
                <div class="settings-section">
                    <div class="section-title">
                        <span>âš™ï¸ GENERAL SETTINGS</span>
                        <span style="font-size: 10px; color: #94a3b8;">Currency:</span>
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Currency</span>
                        <select id="p-currency" class="input-field">
                            <option value="doge">DOGE</option>
                        </select>
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Global Min Bet</span>
                        <input type="number" id="global-minbet" class="input-field" value="${bot.globalMinBet}" step="0.00000001" min="0.00000001">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Demo Balance</span>
                        <input type="number" id="demo-balance" class="input-field" value="${bot.demoBalance}" step="0.01" min="0.01">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Demo Mode</span>
                        <div style="display: flex; align-items: center;">
                            <label class="checkbox-item" style="margin: 0;">
                                <input type="checkbox" id="demo-check">
                                <span style="font-size: 10px;">Enable Demo Mode</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">
                        <span>âš™ï¸ MARTINGALE SETTINGS</span>
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Base Multiplier</span>
                        <input type="number" id="martingale-multiplier" class="input-field" value="${bot.martingaleSettings.baseMultiplier}" step="0.1" min="1.1" max="10">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Max Multiplier</span>
                        <input type="number" id="martingale-max" class="input-field" value="${bot.martingaleSettings.maxMultiplier}" step="1" min="2" max="1000">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Reset on Win</span>
                        <div style="display: flex; align-items: center;">
                            <label class="checkbox-item" style="margin: 0;">
                                <input type="checkbox" id="martingale-reset" ${bot.martingaleSettings.resetOnWin ? 'checked' : ''}>
                                <span style="font-size: 10px;">Reset bet on win</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Use Custom Sequence</span>
                        <div style="display: flex; align-items: center;">
                            <label class="checkbox-item" style="margin: 0;">
                                <input type="checkbox" id="martingale-sequence" ${bot.martingaleSettings.useSequence ? 'checked' : ''}>
                                <span style="font-size: 10px;">Custom sequence</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Sequence (comma separated)</span>
                        <input type="text" id="martingale-sequence-values" class="input-field" value="${bot.martingaleSettings.multiplierSequence.join(', ')}" style="width: 180px;">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Max Loss Streak</span>
                        <input type="number" id="martingale-max-streak" class="input-field" value="${bot.martingaleSettings.maxLossStreak}" step="1" min="1" max="50">
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">
                        <span>ğŸ¯ WAGER MODE</span>
                        <span style="font-size: 9px; color: #94a3b8;">Pattern: Dice â†’ Limbo</span>
                    </div>
                    
                    <div class="section-subtitle">ğŸ² Dice Settings</div>
                    <div class="input-row">
                        <span class="input-label">Base Bet</span>
                        <input type="number" id="dice-bet" class="input-field" value="${bot.wagerMode.basebetDice}" step="0.00000001" min="0.00000001">
                    </div>
                    <div class="input-row">
                        <span class="input-label">Chance %</span>
                        <input type="number" id="dice-chance" class="input-field" value="${bot.wagerMode.diceChance}" step="0.01" min="1" max="99.99">
                    </div>
                    
                    <div class="section-subtitle">ğŸ² Limbo Settings</div>
                    <div class="input-row">
                        <span class="input-label">Base Bet</span>
                        <input type="number" id="limbo-bet" class="input-field" value="${bot.wagerMode.basebetLimbo}" step="0.00000001" min="0.00000001">
                    </div>
                    <div class="input-row">
                        <span class="input-label">Multiplier</span>
                        <input type="number" id="limbo-multiplier" class="input-field" value="${bot.wagerMode.limboMultiplier}" step="0.001" min="1.001" max="1000">
                    </div>
                    
                    <div class="section-subtitle">ğŸ“Š Pattern Settings</div>
                    <div class="input-row">
                        <span class="input-label">Dice Bets/Cycle</span>
                        <input type="number" id="dice-bets" class="input-field" value="${bot.wagerMode.diceBetsPerCycle}" step="1" min="1" max="100">
                    </div>
                    <div class="input-row">
                        <span class="input-label">Limbo Bets/Cycle</span>
                        <input type="number" id="limbo-bets" class="input-field" value="${bot.wagerMode.limboBetsPerCycle}" step="1" min="1" max="100">
                    </div>
                    
                    <div class="section-subtitle">âš ï¸ Stop Loss</div>
                    <div class="input-row">
                        <span class="input-label">Stop Loss %</span>
                        <input type="number" id="wager-stop-loss" class="input-field" value="${bot.wagerMode.stopLossPercent}" step="0.1" min="0.1" max="10">
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">ğŸ”„ RECOVERY MODE</div>
                    
                    <div class="input-row">
                        <span class="input-label">Base Bet</span>
                        <input type="number" id="recovery-bet" class="input-field" value="${bot.recoveryMode.basebet}" step="0.00000001" min="0.00000001">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Chance %</span>
                        <input type="number" id="recovery-chance" class="input-field" value="${bot.recoveryMode.chance}" step="1" min="1" max="99">
                    </div>
                    
                    <div class="section-title" style="margin-top: 12px;">ğŸ“Š RECOVERY METHODS</div>
                    <div class="checkbox-group" id="recovery-methods">
                        <label class="checkbox-item ${bot.recoveryMethods.selected === 'martingale' ? 'active' : ''}" id="martingale-item">
                            <input type="checkbox" id="martingale-check" ${bot.recoveryMethods.selected === 'martingale' ? 'checked' : ''}>
                            <span>Martingale</span>
                        </label>
                        <label class="checkbox-item ${bot.recoveryMethods.selected === 'paroli' ? 'active' : ''}" id="paroli-item">
                            <input type="checkbox" id="paroli-check" ${bot.recoveryMethods.selected === 'paroli' ? 'checked' : ''}>
                            <span>Paroli</span>
                        </label>
                        <label class="checkbox-item ${bot.recoveryMethods.selected === 'dAlembert' ? 'active' : ''}" id="dalembert-item">
                            <input type="checkbox" id="dalembert-check" ${bot.recoveryMethods.selected === 'dAlembert' ? 'checked' : ''}>
                            <span>D'Alembert</span>
                        </label>
                        <label class="checkbox-item ${bot.recoveryMethods.selected === 'labouchere' ? 'active' : ''}" id="labouchere-item">
                            <input type="checkbox" id="labouchere-check" ${bot.recoveryMethods.selected === 'labouchere' ? 'checked' : ''}>
                            <span>Labouchere</span>
                        </label>
                        <label class="checkbox-item ${bot.recoveryMethods.selected === 'fibonacci' ? 'active' : ''}" id="fibonacci-item">
                            <input type="checkbox" id="fibonacci-check" ${bot.recoveryMethods.selected === 'fibonacci' ? 'checked' : ''}>
                            <span>Fibonacci</span>
                        </label>
                        <label class="checkbox-item ${bot.recoveryMethods.selected === 'hybrid' ? 'active' : ''}" id="hybrid-item">
                            <input type="checkbox" id="hybrid-check" ${bot.recoveryMethods.selected === 'hybrid' ? 'checked' : ''}>
                            <span>Hybrid</span>
                        </label>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">ğŸš¨ TRIGGERS</div>
                    
                    <div class="section-subtitle">â° Time Trigger</div>
                    <div class="input-row">
                        <span class="input-label">Enable</span>
                        <label class="checkbox-item" style="margin: 0; width: auto;">
                            <input type="checkbox" id="minute-trigger-check">
                            <span style="font-size: 10px;">After</span>
                        </label>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Minutes</span>
                        <input type="number" id="minute-trigger" class="input-field" value="${bot.triggers.minuteTrigger.minutes}" step="1" min="1" max="60">
                    </div>
                    
                    <div class="section-subtitle">ğŸ“‰ Loss Trigger</div>
                    <div class="input-row">
                        <span class="input-label">Enable</span>
                        <label class="checkbox-item" style="margin: 0; width: auto;">
                            <input type="checkbox" id="loss-trigger-check">
                            <span style="font-size: 10px;">After</span>
                        </label>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Loss Amount</span>
                        <input type="number" id="loss-trigger-amount" class="input-field" value="${bot.triggers.lossTrigger.amount}" step="0.0001" min="0.0001" max="1">
                    </div>
                    <div class="input-row">
                        <span class="input-label">Consecutive Losses</span>
                        <input type="number" id="loss-trigger-consecutive" class="input-field" value="${bot.triggers.lossTrigger.consecutive}" step="1" min="1" max="10">
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">
                        <span>âš¡ SPEED SETTINGS</span>
                        <span style="font-size: 10px; color: #94a3b8;">Delay in ms</span>
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Wager Speed</span>
                        <input type="number" id="wager-speed" class="input-field" value="${bot.speedSettings.wagerSpeed}" step="1" min="1" max="1000">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Recovery Speed</span>
                        <input type="number" id="recovery-speed" class="input-field" value="${bot.speedSettings.recoverySpeed}" step="10" min="10" max="5000">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Demo Speed</span>
                        <input type="number" id="demo-speed" class="input-field" value="${bot.speedSettings.demoSpeed}" step="1" min="1" max="1000">
                    </div>
                    
                    <div class="input-row">
                        <span class="input-label">Turbo Mode</span>
                        <div style="display: flex; align-items: center;">
                            <label class="checkbox-item" style="margin: 0;">
                                <input type="checkbox" id="turbo-check" ${bot.speedSettings.turboMode ? 'checked' : ''}>
                                <span style="font-size: 10px;">Enable Turbo</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="control-buttons">
                    <button id="p-start" class="main-btn btn-start">â–¶ START</button>
                    <button id="p-stop" class="main-btn btn-stop">â¹ STOP</button>
                    <button id="p-pause" class="main-btn btn-pause">â¸ PAUSE</button>
                </div>
                
                <div class="section-title">ğŸ“Š LIVE LOG (LAST 5 BETS)</div>
                <div class="live-log" id="live-log">
                    <div style="color: #94a3b8; text-align: center; padding: 10px;">Waiting for bets...</div>
                </div>
                
                <div style="margin-top: 8px; text-align: center; font-size: 9px; color: #94a3b8;">
                    Telegram reports active
                </div>
            </div>
            
            <div id="p-logs" style="display: none;"></div>
        `;
        document.body.appendChild(d);

        setupEventListeners();
        updateUI();
        
        setTimeout(() => {
            API.syncOnce();
        }, 1000);
    }

    function setupEventListeners() {
        const syncBtn = document.querySelector('.control-btn.sync');
        if (syncBtn) {
            syncBtn.addEventListener('click', async () => {
                updateLogs(0, 0, 0, "Syncing account...", true);
                await API.syncOnce();
                updateDashboard();
            });
        }

        const minimizeBtn = document.querySelector('.control-btn.minimize');
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', () => {
                const content = document.querySelector('.content');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    minimizeBtn.textContent = '_';
                } else {
                    content.style.display = 'none';
                    minimizeBtn.textContent = 'â–¡';
                }
            });
        }

        const closeBtn = document.querySelector('.control-btn.close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                if (bot.isRunning) {
                    if (confirm("Bot is running. Close anyway?")) {
                        document.getElementById("hybrid-wrap").remove();
                    }
                } else {
                    document.getElementById("hybrid-wrap").remove();
                }
            });
        }

        const pCurrency = document.getElementById("p-currency");
        if (pCurrency) {
            pCurrency.addEventListener('change', async (e) => {
                bot.selectedCurrency = e.target.value;
                localStorage.setItem('hybrid_currency', e.target.value);
                
                if (!bot.isDemo) {
                    const newBalance = await API.getBalance(e.target.value);
                    bot.realBalance = newBalance;
                }
                
                updateLogs(0, 0, 0, `Currency changed to: ${e.target.value.toUpperCase()}`, true);
                updateDashboard();
            });
            
            const savedCurrency = localStorage.getItem('hybrid_currency');
            if (savedCurrency) {
                bot.selectedCurrency = savedCurrency;
                pCurrency.value = savedCurrency;
            }
        }

        const globalMinBet = document.getElementById("global-minbet");
        if (globalMinBet) {
            globalMinBet.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 0.00000001) {
                    bot.globalMinBet = value;
                    updateLogs(0, 0, 0, `Global min bet set to: ${value}`, true);
                }
            });
        }

        const demoBalanceInput = document.getElementById("demo-balance");
        if (demoBalanceInput) {
            demoBalanceInput.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value > 0) {
                    bot.demoBalance = value;
                    if (bot.isDemo && !bot.isRunning) {
                        bot.stats.currentBal = value;
                        updateDashboard();
                    }
                    updateLogs(0, 0, 0, `Demo balance set to: ${value}`, true);
                }
            });
        }

        const diceBetInput = document.getElementById("dice-bet");
        if (diceBetInput) {
            diceBetInput.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 0.00000001) {
                    bot.wagerMode.basebetDice = value;
                    bot.wagerMode.dicePayout = 99 / bot.wagerMode.diceChance;
                    updateLogs(0, 0, 0, `Dice base bet set to: ${value.toFixed(8)}`, true);
                }
            });
        }

        const diceChanceInput = document.getElementById("dice-chance");
        if (diceChanceInput) {
            diceChanceInput.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 99.99) {
                    bot.wagerMode.diceChance = value;
                    bot.wagerMode.dicePayout = 99 / value;
                    updateLogs(0, 0, 0, `Dice chance set to: ${value}% (Payout: ${(99/value).toFixed(4)}x)`, true);
                }
            });
        }

        const limboBetInput = document.getElementById("limbo-bet");
        if (limboBetInput) {
            limboBetInput.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 0.00000001) {
                    bot.wagerMode.basebetLimbo = value;
                    updateLogs(0, 0, 0, `Limbo base bet set to: ${value.toFixed(8)}`, true);
                }
            });
        }

        const limboMultiplierInput = document.getElementById("limbo-multiplier");
        if (limboMultiplierInput) {
            limboMultiplierInput.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 1.001 && value <= 1000) {
                    bot.wagerMode.limboMultiplier = value;
                    bot.wagerMode.limboPayout = value;
                    updateLogs(0, 0, 0, `Limbo multiplier set to: ${value}x (Payout: ${value.toFixed(4)}x)`, true);
                }
            });
        }

        const wagerStopLoss = document.getElementById("wager-stop-loss");
        if (wagerStopLoss) {
            wagerStopLoss.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 0.1 && value <= 10) {
                    bot.wagerMode.stopLossPercent = value;
                    updateLogs(0, 0, 0, `Stop loss % set to: ${value}%`, true);
                }
            });
        }

        const diceBetsInput = document.getElementById("dice-bets");
        if (diceBetsInput) {
            diceBetsInput.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 100) {
                    bot.wagerMode.diceBetsPerCycle = value;
                    updateLogs(0, 0, 0, `Dice bets per cycle: ${value}`, true);
                }
            });
        }

        const limboBetsInput = document.getElementById("limbo-bets");
        if (limboBetsInput) {
            limboBetsInput.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 100) {
                    bot.wagerMode.limboBetsPerCycle = value;
                    updateLogs(0, 0, 0, `Limbo bets per cycle: ${value}`, true);
                }
            });
        }

        const recoveryBetInput = document.getElementById("recovery-bet");
        if (recoveryBetInput) {
            recoveryBetInput.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 0.00000001) {
                    bot.recoveryMode.basebet = value;
                    updateLogs(0, 0, 0, `Recovery base bet set to: ${value.toFixed(8)}`, true);
                }
            });
        }

        const recoveryChance = document.getElementById("recovery-chance");
        if (recoveryChance) {
            recoveryChance.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 99) {
                    bot.recoveryMode.chance = value;
                    updateLogs(0, 0, 0, `Recovery chance set to: ${value}%`, true);
                }
            });
        }

        const minuteTriggerCheck = document.getElementById("minute-trigger-check");
        if (minuteTriggerCheck) {
            minuteTriggerCheck.addEventListener('change', (e) => {
                bot.triggers.minuteTrigger.enabled = e.target.checked;
                updateLogs(0, 0, 0, `Minute trigger: ${e.target.checked ? 'ENABLED' : 'DISABLED'}`, true);
            });
        }

        const minuteTriggerInput = document.getElementById("minute-trigger");
        if (minuteTriggerInput) {
            minuteTriggerInput.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 60) {
                    bot.triggers.minuteTrigger.minutes = value;
                    updateLogs(0, 0, 0, `Minute trigger set to: ${value} minutes`, true);
                }
            });
        }

        const lossTriggerCheck = document.getElementById("loss-trigger-check");
        if (lossTriggerCheck) {
            lossTriggerCheck.addEventListener('change', (e) => {
                bot.triggers.lossTrigger.enabled = e.target.checked;
                updateLogs(0, 0, 0, `Loss trigger: ${e.target.checked ? 'ENABLED' : 'DISABLED'}`, true);
            });
        }

        const lossTriggerAmount = document.getElementById("loss-trigger-amount");
        if (lossTriggerAmount) {
            lossTriggerAmount.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 0.0001 && value <= 1) {
                    bot.triggers.lossTrigger.amount = value;
                    updateLogs(0, 0, 0, `Loss trigger amount set to: ${value}`, true);
                }
            });
        }

        const lossTriggerConsecutive = document.getElementById("loss-trigger-consecutive");
        if (lossTriggerConsecutive) {
            lossTriggerConsecutive.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 10) {
                    bot.triggers.lossTrigger.consecutive = value;
                    updateLogs(0, 0, 0, `Loss trigger consecutive losses: ${value}`, true);
                }
            });
        }

        const wagerSpeedInput = document.getElementById("wager-speed");
        if (wagerSpeedInput) {
            wagerSpeedInput.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 1000) {
                    bot.speedSettings.wagerSpeed = value;
                    updateLogs(0, 0, 0, `Wager speed set to: ${value}ms`, true);
                }
            });
        }

        const recoverySpeedInput = document.getElementById("recovery-speed");
        if (recoverySpeedInput) {
            recoverySpeedInput.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 10 && value <= 5000) {
                    bot.speedSettings.recoverySpeed = value;
                    updateLogs(0, 0, 0, `Recovery speed set to: ${value}ms`, true);
                }
            });
        }

        const demoSpeedInput = document.getElementById("demo-speed");
        if (demoSpeedInput) {
            demoSpeedInput.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 1000) {
                    bot.speedSettings.demoSpeed = value;
                    updateLogs(0, 0, 0, `Demo speed set to: ${value}ms`, true);
                }
            });
        }

        const turboCheck = document.getElementById("turbo-check");
        if (turboCheck) {
            turboCheck.addEventListener('change', (e) => {
                bot.speedSettings.turboMode = e.target.checked;
                updateLogs(0, 0, 0, `Turbo mode: ${e.target.checked ? 'ON' : 'OFF'}`, true);
                updateUI();
            });
        }

        const recoveryMethodCheckboxes = [
            'martingale-check',
            'paroli-check', 
            'dalembert-check',
            'labouchere-check',
            'fibonacci-check',
            'hybrid-check'
        ];
        
        recoveryMethodCheckboxes.forEach(checkboxId => {
            const checkbox = document.getElementById(checkboxId);
            const method = checkboxId.replace('-check', '');
            
            if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        recoveryMethodCheckboxes.forEach(otherCheckboxId => {
                            if (otherCheckboxId !== checkboxId) {
                                const otherCheckbox = document.getElementById(otherCheckboxId);
                                const otherMethod = otherCheckboxId.replace('-check', '');
                                const otherItem = document.getElementById(`${otherMethod}-item`);
                                
                                if (otherCheckbox) otherCheckbox.checked = false;
                                if (otherItem) otherItem.classList.remove('active');
                            }
                        });
                        
                        bot.recoveryMethods.selected = method;
                        const item = document.getElementById(`${method}-item`);
                        if (item) item.classList.add('active');
                        
                        updateLogs(0, 0, 0, `Recovery method: ${method.toUpperCase()}`, true);
                        
                        if (bot.recoveryMode.active) {
                            initializeRecoveryMethod();
                        }
                    } else {
                        const anyChecked = recoveryMethodCheckboxes.some(id => 
                            document.getElementById(id)?.checked
                        );
                        
                        if (!anyChecked) {
                            bot.recoveryMethods.selected = 'martingale';
                            document.getElementById('martingale-check').checked = true;
                            document.getElementById('martingale-item').classList.add('active');
                            updateLogs(0, 0, 0, `Recovery method: martingale (default)`, true);
                            
                            if (bot.recoveryMode.active) {
                                initializeRecoveryMethod();
                            }
                        }
                    }
                });
            }
        });

        const martingaleMultiplier = document.getElementById("martingale-multiplier");
        if (martingaleMultiplier) {
            martingaleMultiplier.addEventListener('change', (e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 1.1 && value <= 10) {
                    bot.martingaleSettings.baseMultiplier = value;
                    updateLogs(0, 0, 0, `Martingale multiplier: ${value}x`, true);
                }
            });
        }

        const martingaleMax = document.getElementById("martingale-max");
        if (martingaleMax) {
            martingaleMax.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 2 && value <= 1000) {
                    bot.martingaleSettings.maxMultiplier = value;
                    updateLogs(0, 0, 0, `Martingale max multiplier: ${value}x`, true);
                }
            });
        }

        const martingaleReset = document.getElementById("martingale-reset");
        if (martingaleReset) {
            martingaleReset.addEventListener('change', (e) => {
                bot.martingaleSettings.resetOnWin = e.target.checked;
                updateLogs(0, 0, 0, `Martingale reset on win: ${e.target.checked ? 'YES' : 'NO'}`, true);
            });
        }

        const martingaleSequence = document.getElementById("martingale-sequence");
        if (martingaleSequence) {
            martingaleSequence.addEventListener('change', (e) => {
                bot.martingaleSettings.useSequence = e.target.checked;
                updateLogs(0, 0, 0, `Martingale custom sequence: ${e.target.checked ? 'ON' : 'OFF'}`, true);
            });
        }

        const martingaleSequenceValues = document.getElementById("martingale-sequence-values");
        if (martingaleSequenceValues) {
            martingaleSequenceValues.addEventListener('change', (e) => {
                const values = e.target.value.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v) && v > 0);
                if (values.length > 0) {
                    bot.martingaleSettings.multiplierSequence = values;
                    updateLogs(0, 0, 0, `Martingale sequence set: ${values.join(', ')}`, true);
                }
            });
        }

        const martingaleMaxStreak = document.getElementById("martingale-max-streak");
        if (martingaleMaxStreak) {
            martingaleMaxStreak.addEventListener('change', (e) => {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 1 && value <= 50) {
                    bot.martingaleSettings.maxLossStreak = value;
                    updateLogs(0, 0, 0, `Martingale max loss streak: ${value}`, true);
                }
            });
        }

        const demoCheck = document.getElementById("demo-check");
        if (demoCheck) {
            demoCheck.checked = bot.isDemo;
            
            demoCheck.addEventListener('change', (e) => {
                bot.isDemo = e.target.checked;
                const demoWarning = document.getElementById("demo-warning");
                const balanceInfo = document.getElementById("balance-info");
                
                if (demoWarning) {
                    demoWarning.style.display = "none"; // Selalu sembunyikan
                }
                
                if (balanceInfo) {
                    balanceInfo.textContent = e.target.checked ? "DEMO MODE" : "REAL MODE";
                }
                
                updateLogs(0, 0, 0, `Demo mode: ${e.target.checked ? "ON" : "OFF"}`, true);
                
                if (e.target.checked && !bot.isRunning) {
                    bot.stats.currentBal = bot.demoBalance;
                    updateDashboard();
                }
            });
        }

        const pStart = document.getElementById("p-start");
        if (pStart) {
            pStart.onclick = async () => {
                if (bot.isRunning) return;

                if (!CONFIG.license.isValid() && !bot.isDemo) {
                    alert(`License expired! Renew please.`);
                    return;
                }

                if (!bot.isDemo) {
                    try {
                        await API.syncOnce();
                        if (bot.stakeUser === "Not logged in" || bot.stakeUser === "API Error") {
                            alert("Please login first!");
                            return;
                        }
                        
                        bot.realBalance = await API.getBalance(bot.selectedCurrency);
                        if (bot.realBalance <= 0) {
                            alert(`Insufficient ${bot.selectedCurrency.toUpperCase()} balance!`);
                            return;
                        }
                        
                    } catch (e) {
                        alert(`Sync error: ${e.message}`);
                        return;
                    }
                }

                bot.isRunning = true;
                bot.isPaused = false;

                bot.stats = {
                    profit: 0,
                    wagered: 0,
                    startBal: 0,
                    currentBal: 0,
                    peakBalance: 0,
                    maxDrawdown: 0,
                    drawdownPercentage: 0,
                    bets: 0,
                    wins: 0,
                    loss: 0,
                    startTime: Date.now(),
                    lastBetAmount: 0,
                    lastResults: [],
                    wagerTime: 0,
                    recoveryTime: 0,
                    wagerBets: 0,
                    recoveryBets: 0,
                    recentWins: 0,
                    recentLosses: 0,
                    winStreak: 0,
                    lossStreak: 0,
                    maxWinStreak: 0,
                    maxLossStreak: 0,
                    lastHourBets: 0,
                    lastHourWins: 0,
                    lastHourProfit: 0,
                    startMinute: null
                };

                if (bot.isDemo) {
                    bot.stats.startBal = bot.demoBalance;
                    bot.stats.currentBal = bot.demoBalance;
                    bot.stats.peakBalance = bot.demoBalance;
                } else {
                    bot.stats.startBal = bot.realBalance;
                    bot.stats.currentBal = bot.realBalance;
                    bot.stats.peakBalance = bot.realBalance;
                }

                initHybridWager();

                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStart) {
                    TelegramAPI.sendStartReport();
                }

                updateUI();
                updateLogs(0, 0, 0, "ğŸš€ Bot started!", true);
                updateLogs(0, 0, 0, `ğŸ’° Starting Balance: ${bot.stats.startBal.toFixed(8)} ${bot.selectedCurrency.toUpperCase()}`, true);
                updateLogs(0, 0, 0, `ğŸ² Dice: ${bot.wagerMode.basebetDice.toFixed(8)} @ ${bot.wagerMode.diceChance}% (${bot.wagerMode.dicePayout.toFixed(4)}x)`, true);
                updateLogs(0, 0, 0, `ğŸ² Limbo: ${bot.wagerMode.basebetLimbo.toFixed(8)} @ ${bot.wagerMode.limboMultiplier}x (${bot.wagerMode.limboPayout.toFixed(4)}x)`, true);
                updateLogs(0, 0, 0, `ğŸ“Š Pattern: ${bot.wagerMode.diceBetsPerCycle} Dice â†’ ${bot.wagerMode.limboBetsPerCycle} Limbo`, true);
                updateLogs(0, 0, 0, `âš¡ Speed: ${bot.speedSettings.turboMode ? 'TURBO' : 'NORMAL'} (${getCurrentSpeed()}ms)`, true);

                setTimeout(() => {
                    runLoop();
                }, 100);
            };
        }

        const pStop = document.getElementById("p-stop");
        if (pStop) {
            pStop.onclick = () => {
                bot.isRunning = false;
                bot.isPaused = false;
                
                updateLogs(0, 0, 0, "Bot stopped", true);
                updateUI();
                
                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStop) {
                    TelegramAPI.sendStopReport("Manual Stop");
                }
            };
        }

        const pPause = document.getElementById("p-pause");
        if (pPause) {
            pPause.onclick = () => {
                if (!bot.isRunning) return;
                bot.isPaused = !bot.isPaused;
                
                if (bot.isPaused) {
                    pPause.textContent = "â–¶ RESUME";
                    updateLogs(0, 0, 0, "Bot paused", true);
                } else {
                    pPause.textContent = "â¸ PAUSE";
                    updateLogs(0, 0, 0, "Bot resumed", true);
                    setTimeout(() => {
                        runLoop();
                    }, 100);
                }
                updateUI();
            };
        }
    }

    createUI();
})();
