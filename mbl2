(function () {
    const CONFIG = {
        get apiUrl() { return window.location.origin + '/_api'; },
        version: "ORION WAGER BOT v2.3",
        license: {
            type: "PREMIUM",
            expiryDate: new Date("2026-02-26"),
            isValid: function() {
                return new Date() <= this.expiryDate;
            }
        },
        telegram: {
            enabled: true,
            botToken: '8391763291:AAGdi0yiVDwm0xZvq4UaJzMyy6_kaN0Zerc',
            chatId: '-1003744641395',
            sendOnStart: true,
            sendOnStop: true,
            sendOnRecovery: true,
            sendReportInterval: 5 // minutes
        }
    };

    const bot = {
        isRunning: false,
        isPaused: false,
        isDemo: false,
        demoBalance: 1000.0,
        token: null,
        stakeUser: "Loading...",
        selectedCurrency: "doge",
        globalMinBet: 0.00000001,
        realBalance: 0,
        availableCurrencies: [],
        
        stats: {
            profit: 0,
            wagered: 0,
            startBal: 0,
            currentBal: 0,
            peakBalance: 0,
            maxDrawdown: 0,
            drawdownPercentage: 0,
            bets: 0,
            wins: 0,
            loss: 0,
            startTime: null,
            lastBetAmount: 0,
            lastResults: [],
            winStreak: 0,
            lossStreak: 0,
            maxWinStreak: 0,
            maxLossStreak: 0,
            consecutiveLosses: 0,
            consecutiveWins: 0,
            winRate: 0,
            wageredPercent: 0,
            avgBetSize: 0,
            lastReportTime: null,
            totalProfitSinceStart: 0,
            sessionHigh: 0,
            sessionLow: 0
        },
        
        wagerMode: {
            active: true,
            diceBetPercent: 1.0,
            diceChance: 99.5,
            dicePayout: 0,
            limboBetPercent: 0.5,
            limboMultiplier: 1.001,
            limboPayout: 0,
            diceBetsPerCycle: 10,
            limboBetsPerCycle: 50,
            currentMode: 'dice',
            diceBetCount: 0,
            limboBetCount: 0,
            stopLossPercent: 2.0,
            startBalance: 0,
            lossTriggered: false,
            lossAmount: 0  // TAMBAHKAN INI
        },
        
        recoveryMode: {
            active: false,
            chance: 49.5, // DIUBAH KE 49.5%
            winsToBEP: 3,
            recoveryStartBalance: 0,
            recoveryLossAmount: 0,
            consecutiveLossesForAggressive: 3,
            betMultiplier: 2.0,
            maxBetPercent: 50.0,
            totalLossInStreak: 0,
            recoveryStreak: [],
            currentRecoveryWins: 0,
            recoveryProgress: [],
            remainingWinsNeeded: 3,
            avgProfitNeededPerWin: 0,
            lastWinProfit: 0,
            recoveryStage: 1, // 1: Conservative, 2: Moderate, 3: Aggressive
            stageMultipliers: [1.0, 1.5, 2.0],
            maxConsecutiveLossesInStage: 3
        }
    };

    // =============== TELEGRAM FUNCTIONS ===============
    const TelegramAPI = {
        async sendMessage(text, parse_mode = "HTML") {
            if (!CONFIG.telegram?.enabled) return;
            try {
                const url = `https://api.telegram.org/bot${CONFIG.telegram.botToken}/sendMessage`;
                const params = {
                    chat_id: CONFIG.telegram.chatId,
                    text: text,
                    parse_mode: parse_mode,
                    disable_web_page_preview: true
                };
                await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(params)
                });
            } catch (error) {
                console.error("Telegram error:", error);
            }
        },

        async sendStartReport() {
            if (!CONFIG.telegram.sendOnStart) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `ğŸš€ <b>ORION WAGER BOT STARTED</b>\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ’° Currency: <code>${currencyName}</code>\n` +
                `ğŸ’° Balance: <code>${bot.stats.startBal.toFixed(8)} ${currencyName}</code>\n` +
                `âš¡ Min Bet: <code>${bot.globalMinBet.toFixed(8)}</code>\n` +
                `ğŸ¯ Wins to BEP: <code>${bot.recoveryMode.winsToBEP}</code>\n` +
                `â° ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendStopReport(reason = "Manual Stop") {
            if (!CONFIG.telegram.sendOnStop) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            
            const profitPercent = bot.stats.startBal > 0 
                ? ((bot.stats.profit / bot.stats.startBal) * 100) 
                : 0;
            
            const winRate = bot.stats.bets > 0 
                ? ((bot.stats.wins / bot.stats.bets) * 100) 
                : 0;
            
            const wageredPercent = bot.stats.startBal > 0
                ? ((bot.stats.wagered / bot.stats.startBal) * 100)
                : 0;
            
            const drawdown = bot.stats.peakBalance - bot.stats.currentBal;
            const drawdownPercent = bot.stats.peakBalance > 0 ? (drawdown / bot.stats.peakBalance * 100) : 0;
            
            const message = `ğŸ›‘ <b>ORION BOT STOPPED</b>\n` +
                `ğŸ“ Reason: <b>${reason}</b>\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ’° Currency: <code>${currencyName}</code>\n` +
                `â±ï¸ Runtime: <code>${hours}h ${minutes}m</code>\n` +
                `ğŸ¯ Bets: <code>${bot.stats.bets}</code>\n` +
                `ğŸ“ˆ Win Rate: <code>${winRate.toFixed(2)}%</code>\n` +
                `ğŸ’° Start: <code>${bot.stats.startBal.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ’° End: <code>${bot.stats.currentBal.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ“ˆ Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ“ˆ %: <code>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</code>\n` +
                `ğŸ’¸ Wagered: <code>${bot.stats.wagered.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ“Š Wagered %: <code>${wageredPercent.toFixed(2)}%</code>\n` +
                `ğŸ“‰ Drawdown: <code>${drawdown.toFixed(8)} (${drawdownPercent.toFixed(2)}%)</code>\n` +
                `âš¡ Min Bet: <code>${bot.globalMinBet.toFixed(8)}</code>\n` +
                `â° ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendRecoveryTrigger(lossAmount, lossPercent) {
            if (!CONFIG.telegram.sendOnRecovery) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `âš ï¸ <b>ORION RECOVERY MODE TRIGGERED</b>\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ’° Currency: <code>${currencyName}</code>\n` +
                `ğŸ“‰ Loss Amount: <code>${lossAmount.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ“‰ Loss %: <code>${lossPercent.toFixed(2)}%</code>\n` +
                `ğŸ’° Current Balance: <code>${bot.stats.currentBal.toFixed(8)}</code>\n` +
                `ğŸ”„ Switching to Recovery Mode\n` +
                `ğŸ¯ Strategy: ${bot.recoveryMode.winsToBEP} wins to BEP\n` +
                `ğŸ¯ Chance: ${bot.recoveryMode.chance}% (Payout: ${(99/bot.recoveryMode.chance).toFixed(3)}x)\n` +
                `âš¡ Stage 1/3: Conservative (0.33 factor)\n` +
                `â° ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendRecoveryComplete() {
            if (!CONFIG.telegram.sendOnRecovery) return;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const message = `âœ… <b>ORION RECOVERY COMPLETE</b>\n` +
                `ğŸ‘¤ User: <code>${bot.stakeUser}</code>\n` +
                `ğŸ’° Currency: <code>${currencyName}</code>\n` +
                `ğŸ’° Recovered to: <code>${bot.stats.currentBal.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ¯ Achieved ${bot.recoveryMode.currentRecoveryWins} consecutive wins\n` +
                `ğŸ“Š Recovery Stage: ${getStageName(bot.recoveryMode.recoveryStage)}\n` +
                `ğŸ”„ Returning to Wager Mode\n` +
                `â° ${new Date().toLocaleString()}`;
            await this.sendMessage(message);
        },

        async sendPeriodicReport() {
            if (!CONFIG.telegram.enabled) return;
            
            const now = Date.now();
            if (bot.stats.lastReportTime && (now - bot.stats.lastReportTime) < (CONFIG.telegram.sendReportInterval * 60 * 1000)) {
                return;
            }
            
            if (!bot.isRunning) return;
            
            bot.stats.lastReportTime = now;
            
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const currencyName = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            
            const runtime = bot.stats.startTime ? Math.floor((Date.now() - bot.stats.startTime) / 1000) : 0;
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            
            const winRate = bot.stats.bets > 0 
                ? ((bot.stats.wins / bot.stats.bets) * 100) 
                : 0;
            
            const wageredPercent = bot.stats.startBal > 0
                ? ((bot.stats.wagered / bot.stats.startBal) * 100)
                : 0;
            
            const profitPercent = bot.stats.startBal > 0 
                ? ((bot.stats.profit / bot.stats.startBal) * 100) 
                : 0;
            
            const currentDrawdown = bot.stats.peakBalance - bot.stats.currentBal;
            const drawdownPercent = bot.stats.peakBalance > 0 ? (currentDrawdown / bot.stats.peakBalance * 100) : 0;
            
            const currentMode = bot.wagerMode.active ? 'WAGER' : 'RECOVERY';
            const modeDetails = bot.recoveryMode.active ? 
                ` (Wins: ${bot.recoveryMode.currentRecoveryWins}/${bot.recoveryMode.winsToBEP}, Stage: ${getStageName(bot.recoveryMode.recoveryStage)})` : '';
            
            const message = `<b>ğŸ¯ ORION WAGER BOOSTER</b>\n` +
                `*jasa ticketing , 10 ticket $75*\n` +
                `-----orionlogic.id-----\n` +
                `â° Time: <code>${new Date().toLocaleString()}</code>\n` +
                `ğŸ‘¤ Username: <code>${bot.stakeUser}</code>\n` +
                `ğŸ’° Currency: <code>${currencyName}</code>\n` +
                `ğŸ’° Balance Start: <code>${bot.stats.startBal.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ’° Balance End: <code>${bot.stats.currentBal.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ“ˆ Profit: <code>${bot.stats.profit > 0 ? '+' : ''}${bot.stats.profit.toFixed(8)} ${currencyName}</code>\n` +
                `ğŸ’¸ Wagered: <code>${bot.stats.wagered.toFixed(8)} ${currencyName}</code>\n` +
                `\nğŸ“Š <b>STATISTICS:</b>\n` +
                `ğŸ¯ Bets: <code>${bot.stats.bets}</code>\n` +
                `ğŸ“ˆ Win Rate: <code>${winRate.toFixed(2)}%</code>\n` +
                `ğŸ“Š Profit %: <code>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</code>\n` +
                `ğŸ“Š Wagered %: <code>${wageredPercent.toFixed(2)}%</code>\n` +
                `ğŸ“‰ Drawdown: <code>${currentDrawdown.toFixed(8)} (${drawdownPercent.toFixed(2)}%)</code>\n` +
                `â±ï¸ Runtime: <code>${hours}h ${minutes}m</code>\n` +
                `ğŸ”„ Mode: <code>${currentMode}${modeDetails}</code>\n` +
                `\nğŸ‘¨â€ğŸ’» Owner: t.me/orionlogic`;
            
            await this.sendMessage(message);
        }
    };

    // Helper function for stage names
    function getStageName(stage) {
        switch(stage) {
            case 1: return "Conservative (0.33)";
            case 2: return "Moderate (0.5)";
            case 3: return "Aggressive (0.66)";
            default: return "Unknown";
        }
    }

    // =============== CURRENCY FUNCTIONS ===============
    async function syncCurrenciesFromServer() {
        try {
            if (!bot.token) {
                updateLogs("No token found, trying to sync...", true);
                return getDefaultCurrencies();
            }
            
            const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${bot.token}`,
                    "x-access-token": bot.token,
                    "x-csrf-token": bot.token
                },
                body: JSON.stringify({
                    query: `query {
                        user {
                            balances {
                                available {
                                    amount
                                    currency
                                }
                            }
                        }
                    }`
                })
            });
            
            if (!res.ok) {
                updateLogs(`âš ï¸ API responded with status: ${res.status}`, true);
                return getDefaultCurrencies();
            }
            
            const json = await res.json();
            
            if (json?.errors) {
                updateLogs(`âš ï¸ GraphQL error: ${json.errors[0]?.message}`, true);
                return getDefaultCurrencies();
            }
            
            if (!json?.data?.user?.balances) {
                updateLogs("âš ï¸ No balances data found in response", true);
                return getDefaultCurrencies();
            }
            
            const currenciesSet = new Set();
            const currencies = [];
            
            json.data.user.balances.forEach(balance => {
                if (balance.available && balance.available.currency) {
                    const currencyCode = balance.available.currency.toLowerCase();
                    if (!currenciesSet.has(currencyCode)) {
                        currenciesSet.add(currencyCode);
                        
                        currencies.push({
                            code: currencyCode,
                            name: balance.available.currency.toUpperCase(),
                            icon: getCurrencyIcon(currencyCode),
                            balance: parseFloat(balance.available.amount) || 0
                        });
                    }
                }
            });
            
            if (currencies.length === 0) {
                updateLogs("âš ï¸ No currencies found, using defaults", true);
                return getDefaultCurrencies();
            }
            
            bot.availableCurrencies = currencies;
            
            if (!currencies.find(c => c.code === bot.selectedCurrency)) {
                const currencyWithBalance = currencies.find(c => c.balance > 0) || currencies[0];
                bot.selectedCurrency = currencyWithBalance.code;
            }
            
            updateLogs(`âœ… Synced ${currencies.length} currencies from server`, true);
            return currencies;
            
        } catch (e) {
            updateLogs(`âš ï¸ Failed to sync currencies: ${e.message}`, true);
            return getDefaultCurrencies();
        }
    }

    function getDefaultCurrencies() {
        return [
            { code: "doge", name: "DOGE", icon: "ğŸ•", balance: 0 },
            { code: "btc", name: "BTC", icon: "â‚¿", balance: 0 },
            { code: "eth", name: "ETH", icon: "Î", balance: 0 },
            { code: "ltc", name: "LTC", icon: "Å", balance: 0 },
            { code: "xrp", name: "XRP", icon: "âœ•", balance: 0 },
            { code: "ada", name: "ADA", icon: "A", balance: 0 },
            { code: "trx", name: "TRX", icon: "T", balance: 0 },
            { code: "usdt", name: "USDT", icon: "ğŸ’µ", balance: 0 },
            { code: "usdc", name: "USDC", icon: "ğŸ’²", balance: 0 },
            { code: "sol", name: "SOL", icon: "â—", balance: 0 },
            { code: "matic", name: "MATIC", icon: "â¬¡", balance: 0 },
            { code: "bnb", name: "BNB", icon: "â›“ï¸", balance: 0 },
            { code: "shib", name: "SHIB", icon: "ğŸ•", balance: 0 }
        ];
    }

    function getCurrencyIcon(currencyCode) {
        const icons = {
            'doge': 'ğŸ•', 'btc': 'â‚¿', 'eth': 'Î', 'ltc': 'Å', 'xrp': 'âœ•', 'ada': 'A',
            'trx': 'T', 'usdt': 'ğŸ’µ', 'usdc': 'ğŸ’²', 'sol': 'â—', 'matic': 'â¬¡',
            'bnb': 'â›“ï¸', 'shib': 'ğŸ•', 'xlm': 'â˜…', 'algo': 'Î‘', 'dot': 'â—',
            'avax': 'â„ï¸', 'link': 'ğŸ”—', 'uni': 'ğŸ¦„', 'aave': 'ğŸ‘»', 'comp': 'ğŸ¦„',
            'yfi': 'ğŸ¦', 'snx': 'âš¡', 'mkr': 'ğŸ­', 'bat': 'ğŸ¦‡', 'zrx': '0x'
        };
        
        return icons[currencyCode] || 'ğŸ’°';
    }

    // =============== WAGER MODE LOGIC ===============
    function initWagerMode() {
        const diceBetPercentInput = document.getElementById("dice-bet-percent");
        const diceChanceInput = document.getElementById("dice-chance");
        const limboBetPercentInput = document.getElementById("limbo-bet-percent");
        const limboMultiplierInput = document.getElementById("limbo-multiplier");
        const diceBetsInput = document.getElementById("dice-bets");
        const limboBetsInput = document.getElementById("limbo-bets");
        const stopLossInput = document.getElementById("wager-stop-loss");
        
        if (diceBetPercentInput && diceBetPercentInput.value) {
            bot.wagerMode.diceBetPercent = parseFloat(diceBetPercentInput.value);
        }
        if (diceChanceInput && diceChanceInput.value) {
            bot.wagerMode.diceChance = parseFloat(diceChanceInput.value);
        }
        if (limboBetPercentInput && limboBetPercentInput.value) {
            bot.wagerMode.limboBetPercent = parseFloat(limboBetPercentInput.value);
        }
        if (limboMultiplierInput && limboMultiplierInput.value) {
            bot.wagerMode.limboMultiplier = parseFloat(limboMultiplierInput.value);
        }
        if (diceBetsInput && diceBetsInput.value) {
            bot.wagerMode.diceBetsPerCycle = parseInt(diceBetsInput.value);
        }
        if (limboBetsInput && limboBetsInput.value) {
            bot.wagerMode.limboBetsPerCycle = parseInt(limboBetsInput.value);
        }
        if (stopLossInput && stopLossInput.value) {
            bot.wagerMode.stopLossPercent = parseFloat(stopLossInput.value);
        }
        
        bot.wagerMode.active = true;
        bot.recoveryMode.active = false;
        bot.wagerMode.startBalance = bot.stats.currentBal;
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        bot.wagerMode.lossTriggered = false;
        bot.wagerMode.lossAmount = 0;
        
        bot.wagerMode.dicePayout = 99 / bot.wagerMode.diceChance;
        bot.wagerMode.limboPayout = bot.wagerMode.limboMultiplier;
        
        updateLogs(`ğŸ¯ ORION WAGER MODE STARTED`, true);
        updateLogs(`ğŸ’° Start Balance: ${bot.wagerMode.startBalance.toFixed(8)}`, true);
        updateLogs(`ğŸ² Dice: ${bot.wagerMode.diceBetPercent}% | Limbo: ${bot.wagerMode.limboBetPercent}%`, true);
        updateLogs(`âš¡ Min Bet: ${bot.globalMinBet.toFixed(8)}`, true);
    }

    function wagerBetLogic() {
        const wm = bot.wagerMode;
        const profitFromStart = bot.stats.currentBal - wm.startBalance;
        const stopLossAmount = wm.startBalance * (wm.stopLossPercent / 100);
        
        if (profitFromStart < -stopLossAmount && !wm.lossTriggered) {
            const lossAmount = Math.abs(profitFromStart);
            const lossPercent = (lossAmount / wm.startBalance) * 100;
            
            wm.lossTriggered = true;
            wm.lossAmount = lossAmount;
            
            updateLogs(`âš ï¸ Stop loss triggered: ${lossAmount.toFixed(8)} (${lossPercent.toFixed(2)}%)`, true);
            updateLogs(`ğŸ”„ Switching to Recovery Mode`, true);
            
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnRecovery) {
                TelegramAPI.sendRecoveryTrigger(lossAmount, lossPercent);
            }
            
            setTimeout(() => {
                switchToRecoveryMode();
            }, 1000);
            return null;
        }
        
        if (wm.currentMode === 'dice') {
            wm.diceBetCount++;
            if (wm.diceBetCount >= wm.diceBetsPerCycle) {
                wm.currentMode = 'limbo';
                wm.diceBetCount = 0;
                updateLogs(`ğŸ”„ Switching to Limbo Mode`, true);
            }
        } else {
            wm.limboBetCount++;
            if (wm.limboBetCount >= wm.limboBetsPerCycle) {
                wm.currentMode = 'dice';
                wm.limboBetCount = 0;
                updateLogs(`ğŸ”„ Switching to Dice Mode`, true);
            }
        }
        
        let baseBetPercent = wm.currentMode === 'dice' ? wm.diceBetPercent : wm.limboBetPercent;
        let baseBet = bot.stats.currentBal * (baseBetPercent / 100);
        
        const maxBet = bot.stats.currentBal * 0.8;
        if (baseBet > maxBet) baseBet = maxBet;
        if (baseBet < bot.globalMinBet) baseBet = bot.globalMinBet;
        
        if (wm.currentMode === 'dice') {
            return {
                bet: baseBet,
                chance: wm.diceChance,
                mode: 'dice'
            };
        } else {
            return {
                bet: baseBet,
                multiplier: wm.limboMultiplier,
                mode: 'limbo'
            };
        }
    }

    // =============== RECOVERY MODE LOGIC YANG DIPERBAIKI ===============
    function initRecoveryMode() {
        const recoveryChanceInput = document.getElementById("recovery-chance");
        const betMultiplierInput = document.getElementById("bet-multiplier");
        const maxBetPercentInput = document.getElementById("max-bet-percent");
        const aggLossesInput = document.getElementById("agg-losses");
        const winsToBEPInput = document.getElementById("wins-to-bep");
        
        if (recoveryChanceInput && recoveryChanceInput.value) {
            bot.recoveryMode.chance = parseFloat(recoveryChanceInput.value);
        }
        if (betMultiplierInput && betMultiplierInput.value) {
            bot.recoveryMode.betMultiplier = parseFloat(betMultiplierInput.value);
        }
        if (maxBetPercentInput && maxBetPercentInput.value) {
            bot.recoveryMode.maxBetPercent = parseFloat(maxBetPercentInput.value);
        }
        if (aggLossesInput && aggLossesInput.value) {
            bot.recoveryMode.consecutiveLossesForAggressive = parseInt(aggLossesInput.value);
        }
        if (winsToBEPInput && winsToBEPInput.value) {
            bot.recoveryMode.winsToBEP = parseInt(winsToBEPInput.value);
        }
        
        bot.wagerMode.active = false;
        bot.recoveryMode.active = true;
        bot.recoveryMode.recoveryStartBalance = bot.stats.currentBal + bot.wagerMode.lossAmount;
        bot.recoveryMode.recoveryLossAmount = bot.wagerMode.lossAmount;
        bot.recoveryMode.totalLossInStreak = bot.recoveryMode.recoveryLossAmount;
        bot.recoveryMode.recoveryStreak = [];
        bot.recoveryMode.currentRecoveryWins = 0;
        bot.recoveryMode.remainingWinsNeeded = bot.recoveryMode.winsToBEP;
        bot.recoveryMode.lastWinProfit = 0;
        bot.recoveryMode.recoveryStage = 1;
        
        // Debug info
        updateLogs(`ğŸ”„ ORION RECOVERY MODE STARTED`, true);
        updateLogs(`ğŸ’° Start Balance before loss: ${bot.recoveryMode.recoveryStartBalance.toFixed(8)}`, true);
        updateLogs(`ğŸ“‰ Total Loss to recover: ${bot.recoveryMode.recoveryLossAmount.toFixed(8)}`, true);
        updateLogs(`ğŸ¯ Strategy: ${bot.recoveryMode.winsToBEP} wins to reach BEP`, true);
        updateLogs(`ğŸ¯ Recovery Chance: ${bot.recoveryMode.chance}% (Payout: ${(99/bot.recoveryMode.chance).toFixed(3)}x)`, true);
        updateLogs(`âš¡ Stage 1/3: Conservative (0.33 factor)`, true);
    }

    function updateRecoveryStage() {
        const rm = bot.recoveryMode;
        
        // Update stage berdasarkan consecutive losses
        if (bot.stats.consecutiveLosses >= rm.consecutiveLossesForAggressive + 2) {
            if (rm.recoveryStage < 3) {
                rm.recoveryStage = 3;
                updateLogs(`âš¡âš¡ STAGE UPGRADE: Stage 3 (Aggressive) - ${bot.stats.consecutiveLosses} consecutive losses`, true);
            }
        } else if (bot.stats.consecutiveLosses >= rm.consecutiveLossesForAggressive) {
            if (rm.recoveryStage < 2) {
                rm.recoveryStage = 2;
                updateLogs(`âš¡ STAGE UPGRADE: Stage 2 (Moderate) - ${bot.stats.consecutiveLosses} consecutive losses`, true);
            }
        } else {
            rm.recoveryStage = 1;
        }
    }

    function recoveryBetLogic() {
        const rm = bot.recoveryMode;
        
        // Update recovery stage
        updateRecoveryStage();
        
        // Cek apakah sudah mencapai BEP
        if (bot.stats.currentBal >= rm.recoveryStartBalance) {
            const recoveryPercent = ((bot.stats.currentBal - (rm.recoveryStartBalance - rm.recoveryLossAmount)) / rm.recoveryLossAmount) * 100;
            
            updateLogs(`âœ… ORION RECOVERY COMPLETE!`, true);
            updateLogs(`ğŸ’° Recovered ${recoveryPercent.toFixed(1)}% of loss`, true);
            updateLogs(`ğŸ¯ Achieved BEP with ${rm.currentRecoveryWins} wins`, true);
            updateLogs(`ğŸ”„ Returning to Wager Mode`, true);
            
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnRecovery) {
                TelegramAPI.sendRecoveryComplete();
            }
            
            setTimeout(() => {
                switchToWagerMode();
            }, 1000);
            return null;
        }
        
        if (bot.stats.currentBal < bot.globalMinBet) {
            updateLogs(`âš ï¸ Balance too low for recovery`, true);
            bot.isRunning = false;
            TelegramAPI.sendStopReport("Balance too low for recovery");
            return null;
        }
        
        // Hitung loss amount yang perlu direcover
        const currentLoss = rm.recoveryStartBalance - bot.stats.currentBal;
        
        // Pastikan kita punya loss amount yang valid
        if (currentLoss <= 0) {
            updateLogs(`âœ… No loss to recover`, true);
            switchToWagerMode();
            return null;
        }
        
        // Get chance from input
        const chance = rm.chance;
        const payoutMultiplier = 99 / chance;
        
        // Apply stage factor (0.33 untuk stage 1, 0.5 untuk stage 2, 0.66 untuk stage 3)
        let stageFactor = 0.33; // Default stage 1
        
        switch(rm.recoveryStage) {
            case 1: // Conservative
                stageFactor = 0.33; // 100% / 3
                break;
            case 2: // Moderate
                stageFactor = 0.5; // 100% / 2
                break;
            case 3: // Aggressive
                stageFactor = 0.66; // 100% / 1.5
                break;
        }
        
        // HITUNG BET DENGAN RUMUS YANG BENAR:
        // bet = Math.abs(lossAmount + previousBet) / ((99 / chance) - 1) * stageFactor
        const previousBet = bot.stats.lastBetAmount || bot.globalMinBet;
        const lossPlusPrevious = Math.abs(currentLoss + previousBet);
        
        // Hitung base bet menggunakan rumus
        let betAmount = lossPlusPrevious / (payoutMultiplier - 1) * stageFactor;
        
        // Apply stage multiplier jika ada
        if (rm.recoveryStage > 1) {
            betAmount *= rm.stageMultipliers[rm.recoveryStage - 1];
        }
        
        // Apply safety limits
        const maxBetByPercent = bot.stats.currentBal * (rm.maxBetPercent / 100);
        const safeBetAmount = bot.stats.currentBal * 0.8;
        
        // Ambil nilai minimum dari semua safety checks
        betAmount = Math.min(betAmount, maxBetByPercent, safeBetAmount);
        
        // Pastikan bet tidak kurang dari minimum
        if (betAmount < bot.globalMinBet) {
            betAmount = bot.globalMinBet;
            updateLogs(`âš ï¸ Bet increased to minimum: ${bot.globalMinBet.toFixed(8)}`, true);
        }
        
        // Jaga agar tidak over-bet
        if (betAmount > bot.stats.currentBal * 0.95) {
            betAmount = bot.stats.currentBal * 0.95;
            updateLogs(`âš ï¸ Bet reduced to 95% of balance for safety`, true);
        }
        
        // Hitung metrics
        const potentialProfit = betAmount * (payoutMultiplier - 1);
        const betPercentOfBalance = (betAmount / bot.stats.currentBal) * 100;
        const requiredProfit = currentLoss + previousBet;
        
        // Debug info
        updateLogs(`âš¡ Stage ${rm.recoveryStage}/3: ${getStageName(rm.recoveryStage)}`, true);
        updateLogs(`ğŸ“Š Loss to recover: ${currentLoss.toFixed(8)}`, true);
        updateLogs(`ğŸ¯ Previous bet: ${previousBet.toFixed(8)}`, true);
        updateLogs(`ğŸ“ˆ Required recovery: ${requiredProfit.toFixed(8)}`, true);
        updateLogs(`ğŸ”¢ Payout multiplier: ${payoutMultiplier.toFixed(4)}x`, true);
        updateLogs(`ğŸ“Š Stage factor: ${stageFactor.toFixed(2)}`, true);
        updateLogs(`ğŸ“ˆ Calculated bet: ${betAmount.toFixed(8)} (${betPercentOfBalance.toFixed(2)}% of balance)`, true);
        updateLogs(`ğŸ’° Potential profit if win: ${potentialProfit.toFixed(8)}`, true);
        updateLogs(`ğŸ¯ Recovery progress: ${rm.currentRecoveryWins}/${rm.winsToBEP} wins`, true);
        
        return {
            bet: betAmount,
            chance: chance,
            mode: 'dice'
        };
    }

    // =============== MODE SWITCHING ===============
    function switchToWagerMode() {
        bot.recoveryMode.active = false;
        bot.wagerMode.active = true;
        bot.wagerMode.startBalance = bot.stats.currentBal;
        bot.wagerMode.lossTriggered = false;
        bot.wagerMode.lossAmount = 0;
        bot.wagerMode.currentMode = 'dice';
        bot.wagerMode.diceBetCount = 0;
        bot.wagerMode.limboBetCount = 0;
        
        // Reset recovery data
        bot.recoveryMode.totalLossInStreak = 0;
        bot.recoveryMode.recoveryStreak = [];
        bot.recoveryMode.currentRecoveryWins = 0;
        bot.recoveryMode.remainingWinsNeeded = bot.recoveryMode.winsToBEP;
        bot.recoveryMode.avgProfitNeededPerWin = 0;
        bot.recoveryMode.lastWinProfit = 0;
        bot.recoveryMode.recoveryStage = 1;
        
        // Reset consecutive losses
        bot.stats.consecutiveLosses = 0;
        bot.stats.consecutiveWins = 0;
        
        updateLogs(`ğŸ¯ ORION RETURNING TO WAGER MODE`, true);
        updateUI();
    }

    function switchToRecoveryMode() {
        initRecoveryMode();
        updateUI();
    }

    // =============== API FUNCTIONS ===============
    const API = {
        async syncOnce() {
            try {
                bot.token = localStorage.getItem('apitoken') || 
                           localStorage.getItem('token') ||
                           sessionStorage.getItem('token') ||
                           (document.cookie.match(/session=([^;]+)/) ? document.cookie.match(/session=([^;]+)/)[1] : null);
                
                if (!bot.token) {
                    bot.stakeUser = "Not logged in";
                    bot.availableCurrencies = getDefaultCurrencies();
                    updateLogs("âš ï¸ Please login to Stake first", true);
                    return;
                }

                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{name balances{available{amount currency}}}}`
                    })
                });
                
                if (!res.ok) {
                    bot.stakeUser = "API Error";
                    bot.availableCurrencies = getDefaultCurrencies();
                    updateLogs(`âš ï¸ API error: ${res.status}`, true);
                    return;
                }
                
                const json = await res.json();
                
                if (json?.data?.user) {
                    bot.stakeUser = json.data.user.name;
                    
                    await syncCurrenciesFromServer();
                    
                    const bals = json.data.user.balances || [];
                    const selectedBal = bals.find(b => 
                        b.available && b.available.currency && 
                        b.available.currency.toLowerCase() === bot.selectedCurrency.toLowerCase()
                    );
                    
                    if (selectedBal) {
                        bot.realBalance = parseFloat(selectedBal.available.amount);
                    }
                    
                    updateLogs(`âœ… ORION Synced: ${bot.stakeUser} (${bot.availableCurrencies.length} coins)`, true);
                    
                } else {
                    bot.stakeUser = "API Error";
                    bot.availableCurrencies = getDefaultCurrencies();
                }
                
            } catch (e) {
                bot.stakeUser = "Connection Error";
                bot.availableCurrencies = getDefaultCurrencies();
                updateLogs(`âš ï¸ Sync error: ${e.message}`, true);
            }
        },

        async getBalance(coin) {
            if (bot.isDemo) return bot.stats.currentBal;
            
            try {
                if (!bot.token) await this.syncOnce();
                
                const res = await fetch(`${CONFIG.apiUrl}/graphql`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "x-access-token": bot.token
                    },
                    body: JSON.stringify({
                        query: `query{user{balances{available{amount currency}}}}`
                    })
                });
                const json = await res.json();
                const active = json.data.user.balances.find(b =>
                    b.available.currency.toLowerCase() === coin.toLowerCase()
                );
                const balance = active ? parseFloat(active.available.amount) : 0;
                bot.realBalance = balance;
                return balance;
            } catch (e) {
                return 0;
            }
        },

        async placeDiceBet(amount, chance) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() * 100 < chance;
                    setTimeout(() => {
                        r({
                            diceRoll: {
                                amount: amount,
                                payout: win ? (amount * (99 / chance)) : 0
                            }
                        });
                    }, 50);
                });
            }

            const payload = {
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency,
                target: parseFloat((100 - chance).toFixed(2)),
                condition: "above",
                identifier: Math.random().toString(36).slice(2) + Date.now()
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/dice/roll`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                throw error;
            }
        },

        async placeLimboBet(amount, multiplierTarget) {
            if (bot.isDemo) {
                return new Promise((r) => {
                    const win = Math.random() < (1 / multiplierTarget);
                    setTimeout(() => {
                        r({
                            limboBet: {
                                amount: amount,
                                payout: win ? (amount * multiplierTarget) : 0,
                                state: {
                                    result: win ? multiplierTarget : (multiplierTarget * Math.random()),
                                    multiplierTarget: multiplierTarget
                                }
                            }
                        });
                    }, 50);
                });
            }

            const payload = {
                multiplierTarget: multiplierTarget,
                identifier: Math.random().toString(36).slice(2) + Date.now(),
                amount: parseFloat(amount.toFixed(8)),
                currency: bot.selectedCurrency
            };

            try {
                const r = await fetch(`${CONFIG.apiUrl}/casino/limbo/bet`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${bot.token}`,
                        "x-access-token": bot.token,
                        "x-csrf-token": bot.token
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!r.ok) throw new Error(`Limbo bet failed: ${r.status}`);
                return r.json();
            } catch (error) {
                throw error;
            }
        }
    };

    // =============== MAIN GAME LOOP ===============
    async function runLoop() {
        if (!bot.isRunning || bot.isPaused) return;

        try {
            // Kirim report periodic setiap 5 menit
            if (CONFIG.telegram.enabled && CONFIG.telegram.sendReportInterval > 0) {
                TelegramAPI.sendPeriodicReport();
            }

            if (!bot.isDemo && bot.stats.bets % 10 === 0) {
                const realBal = await API.getBalance(bot.selectedCurrency);
                bot.realBalance = realBal;
            }

            let betInfo = null;
            
            if (bot.wagerMode.active) {
                betInfo = wagerBetLogic();
            } else if (bot.recoveryMode.active) {
                betInfo = recoveryBetLogic();
            }
            
            if (betInfo === null) {
                setTimeout(runLoop, 100);
                return;
            }

            let nextBet = betInfo.bet;
            let chance = betInfo.chance;
            let multiplier = betInfo.multiplier;
            let gameMode = betInfo.mode;

            if (nextBet <= 0) nextBet = bot.globalMinBet;
            if (nextBet < bot.globalMinBet) nextBet = bot.globalMinBet;
            
            if (!bot.isDemo) {
                if (nextBet > bot.realBalance && bot.realBalance > 0) {
                    nextBet = bot.realBalance;
                }
                
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                }
            } else {
                if (nextBet > bot.stats.currentBal && bot.stats.currentBal > 0) {
                    nextBet = bot.stats.currentBal;
                }
            }

            let res;
            if (gameMode === 'dice') {
                res = await API.placeDiceBet(nextBet, chance);
            } else if (gameMode === 'limbo') {
                res = await API.placeLimboBet(nextBet, multiplier);
            }

            let win = false;
            let pft = 0;
            let betAmount = nextBet;

            if (res) {
                if (gameMode === 'dice') {
                    const d = res?.data?.diceRoll || res?.diceRoll;
                    if (d) {
                        win = d.payout > 0;
                        pft = d.payout - d.amount;
                        betAmount = d.amount;
                    }
                } else if (gameMode === 'limbo') {
                    const lb = res?.data?.limboBet || res?.limboBet;
                    if (lb) {
                        const resultMultiplier = lb.state?.result || 0;
                        const targetMultiplier = lb.state?.multiplierTarget || multiplier;
                        win = resultMultiplier >= targetMultiplier;
                        pft = win ? (lb.amount * (targetMultiplier - 1)) : -lb.amount;
                        betAmount = lb.amount;
                    }
                }
            }

            bot.stats.bets++;
            bot.stats.wagered += betAmount;
            bot.stats.profit += pft;
            bot.stats.currentBal += pft;
            bot.stats.lastBetAmount = betAmount;
            
            // Update session high/low
            if (bot.stats.currentBal > bot.stats.sessionHigh) {
                bot.stats.sessionHigh = bot.stats.currentBal;
            }
            if (bot.stats.currentBal < bot.stats.sessionLow || bot.stats.sessionLow === 0) {
                bot.stats.sessionLow = bot.stats.currentBal;
            }
            
            bot.stats.winRate = bot.stats.bets > 0 ? (bot.stats.wins / bot.stats.bets * 100) : 0;
            bot.stats.wageredPercent = bot.stats.startBal > 0 ? (bot.stats.wagered / bot.stats.startBal * 100) : 0;
            bot.stats.avgBetSize = bot.stats.bets > 0 ? (bot.stats.wagered / bot.stats.bets) : 0;

            if (win) {
                bot.stats.wins++;
                bot.stats.winStreak++;
                bot.stats.lossStreak = 0;
                if (bot.stats.winStreak > bot.stats.maxWinStreak) {
                    bot.stats.maxWinStreak = bot.stats.winStreak;
                }
                bot.stats.consecutiveWins++;
                bot.stats.consecutiveLosses = 0;
                
                // Update recovery wins jika dalam recovery mode
                if (bot.recoveryMode.active) {
                    bot.recoveryMode.currentRecoveryWins++;
                    bot.recoveryMode.lastWinProfit = pft;
                    
                    // Reset streak losses saat win
                    bot.recoveryMode.recoveryStreak = [];
                    
                    updateLogs(`âœ… Recovery Win #${bot.recoveryMode.currentRecoveryWins}/${bot.recoveryMode.winsToBEP} achieved!`, true);
                    updateLogs(`ğŸ’° Profit from this win: ${pft.toFixed(8)}`, true);
                    
                    // Cek apakah sudah mencapai BEP
                    if (bot.stats.currentBal >= bot.recoveryMode.recoveryStartBalance) {
                        setTimeout(() => {
                            switchToWagerMode();
                        }, 1000);
                    }
                }
            } else {
                bot.stats.loss++;
                bot.stats.winStreak = 0;
                bot.stats.lossStreak++;
                if (bot.stats.lossStreak > bot.stats.maxLossStreak) {
                    bot.stats.maxLossStreak = bot.stats.lossStreak;
                }
                bot.stats.consecutiveLosses++;
                bot.stats.consecutiveWins = 0;
                
                // Update recovery jika loss dalam recovery mode
                if (bot.recoveryMode.active) {
                    // Jika loss setelah ada win streak, reset wins
                    if (bot.recoveryMode.currentRecoveryWins > 0) {
                        updateLogs(`âš ï¸ Recovery streak broken! Reset from ${bot.recoveryMode.currentRecoveryWins} wins`, true);
                        bot.recoveryMode.currentRecoveryWins = 0;
                    }
                    
                    // Track loss dalam streak
                    if (pft < 0) {
                        bot.recoveryMode.recoveryStreak.push(Math.abs(pft));
                        const streakLoss = bot.recoveryMode.recoveryStreak.reduce((sum, loss) => sum + loss, 0);
                        updateLogs(`ğŸ“‰ Recovery streak loss: ${streakLoss.toFixed(8)} (${bot.recoveryMode.recoveryStreak.length} consecutive losses)`, true);
                    }
                }
            }

            if (!bot.isDemo) {
                bot.realBalance += pft;
            }

            bot.stats.lastResults.unshift({
                win: win,
                betAmount: betAmount,
                profit: pft,
                chance: chance,
                multiplier: multiplier,
                mode: gameMode,
                time: new Date().toLocaleTimeString()
            });
            
            if (bot.stats.lastResults.length > 5) {
                bot.stats.lastResults.pop();
            }

            if (bot.stats.currentBal > bot.stats.peakBalance) {
                bot.stats.peakBalance = bot.stats.currentBal;
            }
            
            const drawdown = bot.stats.peakBalance - bot.stats.currentBal;
            if (drawdown > bot.stats.maxDrawdown) {
                bot.stats.maxDrawdown = drawdown;
                bot.stats.drawdownPercentage = (drawdown / bot.stats.peakBalance) * 100;
            }

            let modeInfo = "";
            if (bot.wagerMode.active) {
                if (gameMode === 'dice') {
                    modeInfo = `[Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}]`;
                } else {
                    modeInfo = `[Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}]`;
                }
            } else {
                modeInfo = `[Recovery Stage ${bot.recoveryMode.recoveryStage} | Wins: ${bot.recoveryMode.currentRecoveryWins}/${bot.recoveryMode.winsToBEP}]`;
            }
            
            let logLine;
            const betPercent = (betAmount / bot.stats.currentBal) * 100;
            
            if (gameMode === 'dice') {
                logLine = `${modeInfo} Dice: ${betAmount.toFixed(8)} (${betPercent.toFixed(2)}%) @ ${chance}% â†’ ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            } else {
                logLine = `${modeInfo} Limbo: ${betAmount.toFixed(8)} (${betPercent.toFixed(2)}%) @ ${multiplier}x â†’ ${win ? 'WIN' : 'LOSS'} ${pft > 0 ? '+' : ''}${pft.toFixed(8)}`;
            }
            
            if (bot.recoveryMode.active) {
                logLine += ` | Stage: ${getStageName(bot.recoveryMode.recoveryStage)}`;
                const stageFactor = bot.recoveryMode.recoveryStage === 1 ? 0.33 : 
                                  bot.recoveryMode.recoveryStage === 2 ? 0.5 : 0.66;
                logLine += ` [Factor: ${stageFactor}]`;
            }
            
            if (bot.stats.consecutiveLosses > 0) {
                logLine += ` [L:${bot.stats.consecutiveLosses}]`;
            }
            if (bot.stats.consecutiveWins > 0) {
                logLine += ` [W:${bot.stats.consecutiveWins}]`;
            }
            
            updateLogs(logLine);

            updateDashboard();
            updateLiveLogs();

            if (bot.isRunning && !bot.isPaused) {
                const delay = bot.isDemo ? 50 : 100;
                setTimeout(runLoop, delay);
            }

        } catch (e) {
            updateLogs(`âš ï¸ Error: ${e.message}`, true);
            
            if (bot.isRunning && !bot.isPaused) {
                setTimeout(runLoop, 100);
            }
        }
    }

    // =============== UI FUNCTIONS ===============
    function updateDashboard() {
        const accountName = document.getElementById("account-name");
        if (accountName) accountName.textContent = bot.stakeUser;
        
        const licenseStatus = document.getElementById("license-status");
        if (licenseStatus) {
            licenseStatus.textContent = CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED";
            licenseStatus.style.color = CONFIG.license.isValid() ? "#10b981" : "#ef4444";
        }
        
        const currencyDisplay = document.getElementById("currency-display");
        if (currencyDisplay) {
            const currency = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            currencyDisplay.textContent = currency ? `${currency.icon} ${currency.name}` : bot.selectedCurrency.toUpperCase();
        }
        
        const balanceEl = document.getElementById("balance");
        if (balanceEl) {
            if (bot.isDemo) {
                balanceEl.textContent = bot.stats.currentBal.toFixed(8);
                balanceEl.title = `Demo Balance`;
            } else {
                balanceEl.textContent = bot.realBalance.toFixed(8);
                balanceEl.title = `Real Balance`;
            }
        }
        
        const profitEl = document.getElementById("profit");
        if (profitEl) profitEl.textContent = bot.stats.profit.toFixed(8);
        
        const profitPercent = bot.stats.startBal > 0 ? (bot.stats.profit / bot.stats.startBal * 100) : 0;
        const profitPercentEl = document.getElementById("profit-percent");
        if (profitPercentEl) profitPercentEl.textContent = profitPercent.toFixed(2) + '%';
        
        const betsEl = document.getElementById("bets");
        if (betsEl) betsEl.textContent = bot.stats.bets;
        
        const wageredEl = document.getElementById("wagered");
        if (wageredEl) wageredEl.textContent = bot.stats.wagered.toFixed(8);
        
        const wageredPercentEl = document.getElementById("wagered-percent");
        if (wageredPercentEl) wageredPercentEl.textContent = bot.stats.wageredPercent.toFixed(2) + '%';
        
        const winRateEl = document.getElementById("win-rate");
        if (winRateEl) winRateEl.textContent = bot.stats.winRate.toFixed(2) + '%';
        
        const minBetEl = document.getElementById("min-bet");
        if (minBetEl) minBetEl.textContent = bot.globalMinBet.toFixed(8);
        
        const avgBetEl = document.getElementById("avg-bet");
        if (avgBetEl) avgBetEl.textContent = bot.stats.avgBetSize.toFixed(8);
        
        const modeIndicator = document.getElementById("mode-indicator");
        if (modeIndicator) {
            if (bot.wagerMode.active) {
                let patternInfo = "";
                if (bot.wagerMode.currentMode === 'dice') {
                    patternInfo = `Dice ${bot.wagerMode.diceBetCount}/${bot.wagerMode.diceBetsPerCycle}`;
                } else {
                    patternInfo = `Limbo ${bot.wagerMode.limboBetCount}/${bot.wagerMode.limboBetsPerCycle}`;
                }
                modeIndicator.textContent = `WAGER (${patternInfo})`;
                modeIndicator.style.color = "#10b981";
            } else if (bot.recoveryMode.active) {
                const stageFactor = bot.recoveryMode.recoveryStage === 1 ? 0.33 : 
                                  bot.recoveryMode.recoveryStage === 2 ? 0.5 : 0.66;
                modeIndicator.textContent = `RECOVERY Stage ${bot.recoveryMode.recoveryStage} (Factor: ${stageFactor}) | Wins: ${bot.recoveryMode.currentRecoveryWins}/${bot.recoveryMode.winsToBEP}`;
                modeIndicator.style.color = "#f59e0b";
            } else {
                modeIndicator.textContent = "STOPPED";
                modeIndicator.style.color = "#94a3b8";
            }
            
            if (bot.isPaused) {
                modeIndicator.textContent += " (PAUSED)";
                modeIndicator.style.color = "#f59e0b";
            }
        }
        
        updateCurrencyDropdown();
    }

    function updateCurrencyDropdown() {
        const currencySelect = document.getElementById("currency-select");
        if (currencySelect && bot.availableCurrencies.length > 0) {
            const currentValue = currencySelect.value;
            
            currencySelect.innerHTML = '';
            
            bot.availableCurrencies.forEach(currency => {
                const option = document.createElement("option");
                option.value = currency.code;
                option.textContent = `${currency.icon} ${currency.name}`;
                option.selected = currency.code === bot.selectedCurrency;
                currencySelect.appendChild(option);
            });
            
            if (currentValue) {
                currencySelect.value = currentValue;
            }
        }
    }

    function updateLiveLogs() {
        const logContainer = document.getElementById("live-log");
        if (!logContainer) return;
        
        let html = "";
        
        if (bot.recoveryMode.active) {
            const remainingWins = bot.recoveryMode.winsToBEP - bot.recoveryMode.currentRecoveryWins;
            const recoveryProgress = (bot.recoveryMode.currentRecoveryWins / bot.recoveryMode.winsToBEP) * 100;
            const stageName = getStageName(bot.recoveryMode.recoveryStage);
            const stageColor = bot.recoveryMode.recoveryStage === 1 ? "#f59e0b" : 
                             bot.recoveryMode.recoveryStage === 2 ? "#f97316" : "#dc2626";
            const stageFactor = bot.recoveryMode.recoveryStage === 1 ? 0.33 : 
                              bot.recoveryMode.recoveryStage === 2 ? 0.5 : 0.66;
            
            html += `
                <div style="color:${stageColor};text-align:center;padding:8px;background:rgba(245,158,11,0.15);margin-bottom:8px;border-radius:6px;font-size:12px;font-weight:bold;border:1px solid rgba(245,158,11,0.3);">
                    âš¡ ENHANCED RECOVERY - Stage ${bot.recoveryMode.recoveryStage}/3: ${stageName}
                    <div style="font-size:11px;color:#fbbf24;margin-top:4px;">
                        Factor: ${stageFactor} | Wins: ${bot.recoveryMode.currentRecoveryWins}/${bot.recoveryMode.winsToBEP} | 
                        Progress: ${recoveryProgress.toFixed(1)}% | Remaining: ${remainingWins} win(s) to BEP
                    </div>
                </div>`;
        } else if (bot.wagerMode.active) {
            html += `
                <div style="color:#10b981;text-align:center;padding:8px;background:rgba(16,185,129,0.15);margin-bottom:8px;border-radius:6px;font-size:12px;font-weight:bold;border:1px solid rgba(16,185,129,0.3);">
                    ğŸ¯ ORION ${bot.wagerMode.currentMode.toUpperCase()} MODE
                    <div style="font-size:11px;color:#34d399;margin-top:4px;">
                        Stop Loss: ${bot.wagerMode.stopLossPercent}% | 
                        Dice: ${bot.wagerMode.diceBetPercent}% @ ${bot.wagerMode.diceChance}% | 
                        Limbo: ${bot.wagerMode.limboBetPercent}% @ ${bot.wagerMode.limboMultiplier}x
                    </div>
                </div>`;
        }
        
        if (bot.stats.lastResults.length === 0) {
            html += '<div style="color: #94a3b8; text-align: center; padding: 15px; font-size: 12px;">No bets yet</div>';
        } else {
            bot.stats.lastResults.forEach(result => {
                let color = result.win ? "#10b981" : "#ef4444";
                let bgColor = result.win ? "rgba(16,185,129,0.1)" : "rgba(239,68,68,0.1)";
                
                if (bot.recoveryMode.active) {
                    color = result.win ? "#22c55e" : "#f97316";
                    bgColor = result.win ? "rgba(34,197,94,0.1)" : "rgba(249,115,22,0.1)";
                }
                
                const winLoss = result.win ? "WIN" : "LOSS";
                const modeIcon = result.mode === 'dice' ? 'ğŸ²' : 'ğŸ“ˆ';
                
                const betPercent = bot.stats.currentBal > 0 ? (result.betAmount / bot.stats.currentBal * 100) : 0;
                
                html += `
                    <div class="log-entry" style="color: ${color}; background: ${bgColor}; padding: 10px; margin-bottom: 8px; border-radius: 6px; font-size: 13px; border-left: 4px solid ${color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 11px; color: #94a3b8;">${result.time}</div>
                            <div style="font-weight: bold; color: ${color}; font-size: 12px;">${winLoss}</div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 6px;">
                            <div>
                                <span>${modeIcon} ${result.betAmount.toFixed(8)}</span>
                                <span style="font-size: 11px; color: #94a3b8; margin-left: 6px;">(${betPercent.toFixed(2)}%)</span>
                            </div>
                            <div style="color: ${result.profit > 0 ? '#10b981' : '#ef4444'}; font-weight: bold; font-size: 12px;">
                                ${result.profit > 0 ? '+' : ''}${result.profit.toFixed(8)}
                            </div>
                        </div>
                        ${bot.recoveryMode.active ? 
                            `<div style="font-size: 11px; color: #f59e0b; text-align: center; margin-top: 6px; padding: 4px; background: rgba(245,158,11,0.1); border-radius: 4px;">
                                Stage ${bot.recoveryMode.recoveryStage}: ${bot.recoveryMode.currentRecoveryWins}/${bot.recoveryMode.winsToBEP} wins
                            </div>` : ''}
                    </div>
                `;
            });
        }
        
        logContainer.innerHTML = html;
    }

    function updateLogs(customMsg, isSystem = false) {
        const logBox = document.getElementById("p-logs");
        if (!logBox) return;

        const entry = document.createElement("div");
        entry.className = "log-entry";

        if (isSystem) {
            entry.style.color = "#f59e0b";
            entry.style.fontWeight = "bold";
        }

        entry.innerHTML = customMsg;
        logBox.prepend(entry);
        
        if (logBox.children.length > 50) {
            logBox.removeChild(logBox.lastChild);
        }
    }

    function updateUI() {
        updateCurrencyDropdown();
        
        const minBetInput = document.getElementById("min-bet-input");
        if (minBetInput) {
            minBetInput.value = bot.globalMinBet;
            const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
            const unitEl = minBetInput.nextElementSibling;
            if (unitEl && unitEl.classList.contains('unit')) {
                unitEl.textContent = currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase();
            }
        }
        
        const diceBetPercentInput = document.getElementById("dice-bet-percent");
        if (diceBetPercentInput) diceBetPercentInput.value = bot.wagerMode.diceBetPercent;
        
        const diceChanceInput = document.getElementById("dice-chance");
        if (diceChanceInput) diceChanceInput.value = bot.wagerMode.diceChance;
        
        const limboBetPercentInput = document.getElementById("limbo-bet-percent");
        if (limboBetPercentInput) limboBetPercentInput.value = bot.wagerMode.limboBetPercent;
        
        const limboMultiplierInput = document.getElementById("limbo-multiplier");
        if (limboMultiplierInput) limboMultiplierInput.value = bot.wagerMode.limboMultiplier;
        
        const wagerStopLoss = document.getElementById("wager-stop-loss");
        if (wagerStopLoss) wagerStopLoss.value = bot.wagerMode.stopLossPercent;
        
        const recoveryChance = document.getElementById("recovery-chance");
        if (recoveryChance) recoveryChance.value = bot.recoveryMode.chance;
        
        const betMultiplier = document.getElementById("bet-multiplier");
        if (betMultiplier) betMultiplier.value = bot.recoveryMode.betMultiplier;
        
        const maxBetPercent = document.getElementById("max-bet-percent");
        if (maxBetPercent) maxBetPercent.value = bot.recoveryMode.maxBetPercent;
        
        const aggLosses = document.getElementById("agg-losses");
        if (aggLosses) aggLosses.value = bot.recoveryMode.consecutiveLossesForAggressive;
        
        const winsToBEP = document.getElementById("wins-to-bep");
        if (winsToBEP) winsToBEP.value = bot.recoveryMode.winsToBEP;
        
        const diceBets = document.getElementById("dice-bets");
        if (diceBets) diceBets.value = bot.wagerMode.diceBetsPerCycle;
        
        const limboBets = document.getElementById("limbo-bets");
        if (limboBets) limboBets.value = bot.wagerMode.limboBetsPerCycle;
        
        updateDashboard();
        updateLiveLogs();
    }

    // =============== UI CREATION ===============
    function createUI() {
        if (document.getElementById("orion-wrap")) return;

        const s = document.createElement("style");
        s.innerHTML = `
            #orion-wrap {
                position: fixed;
                top: 10px;
                right: 10px;
                width: 420px;
                max-width: calc(100vw - 20px);
                max-height: 90vh;
                background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
                backdrop-filter: blur(10px);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 12px;
                color: #f8fafc;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                font-size: 14px;
                z-index: 999999;
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3), 0 0 20px rgba(59, 130, 246, 0.1);
                overflow: hidden;
                display: flex;
                flex-direction: column;
                transition: all 0.3s ease;
            }
            
            .orion-header {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(59, 130, 246, 0.2));
                padding: 14px 16px;
                border-bottom: 1px solid rgba(59, 130, 246, 0.3);
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .header-left {
                flex: 1;
                min-width: 200px;
            }
            
            .app-title {
                font-size: 16px;
                font-weight: 800;
                background: linear-gradient(135deg, #3b82f6, #8b5cf6);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 4px;
                letter-spacing: 0.5px;
                line-height: 1.2;
            }
            
            .app-subtitle {
                font-size: 11px;
                color: #94a3b8;
                font-weight: 600;
            }
            
            .header-info {
                display: flex;
                gap: 6px;
                font-size: 11px;
                color: #94a3b8;
                flex-wrap: wrap;
                margin-top: 4px;
            }
            
            .header-info span {
                padding: 4px 8px;
                background: rgba(30, 41, 59, 0.6);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                white-space: nowrap;
            }
            
            .header-controls {
                display: flex;
                gap: 6px;
                align-items: center;
            }
            
            .control-btn {
                width: 32px;
                height: 32px;
                border-radius: 8px;
                background: rgba(30, 41, 59, 0.7);
                border: 1px solid rgba(59, 130, 246, 0.3);
                color: #3b82f6;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
                transition: all 0.2s;
                font-weight: bold;
            }
            
            .control-btn:hover {
                background: rgba(59, 130, 246, 0.2);
                transform: translateY(-1px);
            }
            
            .content {
                padding: 16px;
                overflow-y: auto;
                flex: 1;
                -webkit-overflow-scrolling: touch;
                background: rgba(15, 23, 42, 0.3);
            }
            
            .demo-toggle {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 16px;
                padding: 12px;
                background: rgba(30, 41, 59, 0.7);
                border-radius: 10px;
                border: 1px solid rgba(59, 130, 246, 0.2);
            }
            
            .switch {
                position: relative;
                display: inline-block;
                width: 46px;
                height: 24px;
            }
            
            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }
            
            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #4b5563;
                transition: .4s;
                border-radius: 24px;
            }
            
            .slider:before {
                position: absolute;
                content: "";
                height: 18px;
                width: 18px;
                left: 3px;
                bottom: 3px;
                background-color: white;
                transition: .4s;
                border-radius: 50%;
            }
            
            input:checked + .slider {
                background: linear-gradient(135deg, #10b981, #059669);
            }
            
            input:checked + .slider:before {
                transform: translateX(22px);
            }
            
            .demo-label {
                font-size: 13px;
                color: #94a3b8;
                font-weight: 600;
            }
            
            .demo-label.active {
                color: #10b981;
                font-weight: 700;
            }
            
            .currency-selector {
                margin-bottom: 16px;
                background: rgba(30, 41, 59, 0.7);
                border-radius: 10px;
                padding: 14px;
                border: 1px solid rgba(59, 130, 246, 0.2);
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            
            .currency-row {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 12px;
            }
            
            .currency-label {
                font-size: 12px;
                color: #94a3b8;
                width: 80px;
                font-weight: 600;
                white-space: nowrap;
            }
            
            .currency-dropdown {
                flex: 1;
                background: rgba(15, 23, 42, 0.9);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 8px;
                padding: 10px 12px;
                color: #fff;
                font-size: 13px;
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' fill='%233b82f6' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 12px center;
                padding-right: 40px;
                cursor: pointer;
                transition: border 0.2s;
                min-height: 40px;
            }
            
            .currency-dropdown:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            }
            
            .currency-dropdown option {
                background: rgba(15, 23, 42, 0.95);
                color: white;
                padding: 10px;
            }
            
            .min-bet-input {
                display: flex;
                align-items: center;
                gap: 10px;
                flex: 1;
            }
            
            .input-field {
                flex: 1;
                background: rgba(15, 23, 42, 0.9);
                border: 1px solid rgba(59, 130, 246, 0.3);
                border-radius: 8px;
                padding: 10px 12px;
                color: #fff;
                font-size: 13px;
                font-family: 'Courier New', monospace;
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                text-align: right;
                transition: all 0.2s;
                min-height: 40px;
            }
            
            .input-field:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            }
            
            .unit {
                font-size: 12px;
                color: #94a3b8;
                min-width: 50px;
                text-align: center;
                font-weight: 600;
            }
            
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin-bottom: 16px;
            }
            
            .stat-card {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(30, 41, 59, 0.6));
                border-radius: 10px;
                padding: 12px;
                text-align: center;
                min-height: 70px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                border: 1px solid rgba(59, 130, 246, 0.1);
                transition: transform 0.2s;
            }
            
            .stat-card:hover {
                transform: translateY(-2px);
                border-color: rgba(59, 130, 246, 0.3);
            }
            
            .stat-label {
                font-size: 11px;
                color: #94a3b8;
                text-transform: uppercase;
                margin-bottom: 6px;
                font-weight: 600;
                letter-spacing: 0.5px;
            }
            
            .stat-value {
                font-size: 14px;
                font-weight: 800;
                color: #fff;
                font-family: 'Courier New', monospace;
                word-break: break-all;
                line-height: 1.3;
            }
            
            .stat-value.small {
                font-size: 12px;
            }
            
            .mode-indicator {
                background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(30, 41, 59, 0.6));
                border-radius: 10px;
                padding: 12px;
                text-align: center;
                margin-bottom: 16px;
                font-weight: 700;
                font-size: 13px;
                border: 1px solid rgba(59, 130, 246, 0.2);
                text-transform: uppercase;
                letter-spacing: 0.5px;
                line-height: 1.4;
            }
            
            .settings-section {
                background: rgba(30, 41, 59, 0.7);
                border-radius: 10px;
                padding: 14px;
                margin-bottom: 12px;
                border: 1px solid rgba(59, 130, 246, 0.1);
            }
            
            .section-title {
                font-size: 13px;
                font-weight: 700;
                color: #3b82f6;
                margin-bottom: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-bottom: 8px;
                border-bottom: 1px solid rgba(59, 130, 246, 0.2);
            }
            
            .input-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
                padding: 8px 0;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .input-label {
                font-size: 12px;
                color: #cbd5e1;
                width: 140px;
                font-weight: 500;
                flex-shrink: 0;
            }
            
            .input-wrapper {
                display: flex;
                align-items: center;
                gap: 8px;
                flex: 1;
                min-width: 150px;
            }
            
            .control-buttons {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin: 18px 0;
            }
            
            .main-btn {
                padding: 14px;
                border: none;
                border-radius: 10px;
                font-size: 13px;
                font-weight: 700;
                cursor: pointer;
                text-transform: uppercase;
                transition: all 0.2s;
                letter-spacing: 0.5px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                min-height: 50px;
            }
            
            .main-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            }
            
            .main-btn:active {
                transform: translateY(0);
            }
            
            .btn-start {
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
            }
            
            .btn-stop {
                background: linear-gradient(135deg, #ef4444, #dc2626);
                color: white;
            }
            
            .btn-pause {
                background: linear-gradient(135deg, #f59e0b, #d97706);
                color: white;
            }
            
            .live-log {
                background: rgba(15, 23, 42, 0.9);
                border-radius: 10px;
                padding: 14px;
                height: 180px;
                overflow-y: auto;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                border: 1px solid rgba(59, 130, 246, 0.2);
            }
            
            /* Mobile optimizations */
            @media (max-width: 480px) {
                #orion-wrap {
                    width: 95vw;
                    right: 2.5vw;
                    left: 2.5vw;
                    top: 10px;
                    max-height: 85vh;
                    font-size: 13px;
                }
                
                .orion-header {
                    padding: 12px;
                    flex-direction: column;
                    align-items: stretch;
                    gap: 8px;
                }
                
                .header-left {
                    min-width: auto;
                }
                
                .header-controls {
                    align-self: flex-end;
                }
                
                .content {
                    padding: 12px;
                }
                
                .stats-grid {
                    grid-template-columns: repeat(2, 1fr);
                    gap: 8px;
                }
                
                .stat-card {
                    padding: 10px;
                    min-height: 65px;
                }
                
                .stat-value {
                    font-size: 13px;
                }
                
                .input-row {
                    flex-direction: column;
                    align-items: stretch;
                    gap: 6px;
                }
                
                .input-label {
                    width: 100%;
                }
                
                .input-wrapper {
                    width: 100%;
                }
                
                .main-btn {
                    padding: 12px;
                    font-size: 12px;
                    min-height: 45px;
                }
                
                .currency-label {
                    width: 70px;
                    font-size: 11px;
                }
                
                .settings-section {
                    padding: 12px;
                }
            }
            
            /* Touch-friendly scrollbar */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            
            ::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb {
                background: rgba(59, 130, 246, 0.5);
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb:hover {
                background: rgba(59, 130, 246, 0.7);
            }
            
            /* Hide number input spinners */
            input[type=number]::-webkit-inner-spin-button,
            input[type=number]::-webkit-outer-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }
            
            input[type=number] {
                -moz-appearance: textfield;
            }
            
            /* Better touch targets */
            select, input, button {
                touch-action: manipulation;
            }
            
            /* Prevent text selection on buttons */
            .main-btn, .control-btn {
                user-select: none;
                -webkit-user-select: none;
            }
            
            /* Responsive adjustments */
            @media (max-height: 700px) {
                .live-log {
                    height: 150px;
                }
                
                .settings-section {
                    padding: 10px;
                    margin-bottom: 10px;
                }
            }
            
            @media (max-height: 600px) {
                .live-log {
                    height: 120px;
                }
                
                .stats-grid {
                    gap: 6px;
                }
                
                .stat-card {
                    padding: 8px;
                    min-height: 60px;
                }
            }
        `;
        document.head.appendChild(s);

        const d = document.createElement("div");
        d.id = "orion-wrap";
        d.innerHTML = `
            <div class="orion-header">
                <div class="header-left">
                    <div class="app-title">ğŸš€ ORION WAGER BOT</div>
                    <div class="app-subtitle">Enhanced Recovery System v2.3</div>
                    <div class="header-info">
                        <span id="account-name">${bot.stakeUser}</span>
                        <span id="license-status">${CONFIG.license.isValid() ? "ACTIVE" : "EXPIRED"}</span>
                        <span id="currency-display">Loading...</span>
                    </div>
                </div>
                <div class="header-controls">
                    <button class="control-btn sync" title="Sync">â†»</button>
                    <button class="control-btn minimize" title="Minimize">_</button>
                    <button class="control-btn close" title="Close">Ã—</button>
                </div>
            </div>
            
            <div class="content">
                <!-- Demo Mode Toggle -->
                <div class="demo-toggle">
                    <label class="switch">
                        <input type="checkbox" id="demo-toggle">
                        <span class="slider"></span>
                    </label>
                    <span id="demo-label" class="demo-label ${bot.isDemo ? 'active' : ''}">
                        ${bot.isDemo ? 'ğŸ”„ DEMO MODE' : 'ğŸ’° REAL MODE'}
                    </span>
                </div>
                
                <!-- Currency Selector -->
                <div class="currency-selector">
                    <div class="currency-row">
                        <span class="currency-label">ğŸŒ Currency</span>
                        <select id="currency-select" class="currency-dropdown">
                            <option value="loading">Loading currencies...</option>
                        </select>
                    </div>
                    <div class="currency-row">
                        <span class="currency-label">âš¡ Min Bet</span>
                        <div class="min-bet-input">
                            <input type="number" id="min-bet-input" class="input-field" value="${bot.globalMinBet}" step="0.00000001" min="0.00000001">
                            <span class="unit" id="min-bet-unit">DOGE</span>
                        </div>
                    </div>
                </div>
                
                <!-- Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Balance</div>
                        <div class="stat-value" id="balance">0.00000000</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Profit</div>
                        <div class="stat-value" id="profit">0.00000000</div>
                        <div class="stat-label" id="profit-percent">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Wagered</div>
                        <div class="stat-value small" id="wagered">0.00000000</div>
                        <div class="stat-label" id="wagered-percent">0.00%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Win Rate</div>
                        <div class="stat-value small" id="win-rate">0.00%</div>
                    </div>
                </div>
                
                <!-- Mode Indicator -->
                <div class="mode-indicator" id="mode-indicator">
                    <span class="orion-star">âœ¦</span> ORION SYSTEM: <span id="mode-text">STOPPED</span> <span class="orion-star">âœ¦</span>
                </div>
                
                <!-- Wager Settings -->
                <div class="settings-section">
                    <div class="section-title">ğŸ² Dice Settings</div>
                    <div class="input-row">
                        <span class="input-label">Base Bet %</span>
                        <div class="input-wrapper">
                            <input type="number" id="dice-bet-percent" class="input-field" value="${bot.wagerMode.diceBetPercent}" step="0.1" min="0.1" max="20">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Chance %</span>
                        <div class="input-wrapper">
                            <input type="number" id="dice-chance" class="input-field" value="${bot.wagerMode.diceChance}" step="0.01" min="1" max="99.99">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Bets per Cycle</span>
                        <div class="input-wrapper">
                            <input type="number" id="dice-bets" class="input-field" value="${bot.wagerMode.diceBetsPerCycle}" step="1" min="1" max="100">
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">ğŸ“ˆ Limbo Settings</div>
                    <div class="input-row">
                        <span class="input-label">Base Bet %</span>
                        <div class="input-wrapper">
                            <input type="number" id="limbo-bet-percent" class="input-field" value="${bot.wagerMode.limboBetPercent}" step="0.1" min="0.1" max="20">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Multiplier</span>
                        <div class="input-wrapper">
                            <input type="number" id="limbo-multiplier" class="input-field" value="${bot.wagerMode.limboMultiplier}" step="0.001" min="1.001" max="1000">
                            <span class="unit">x</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Bets per Cycle</span>
                        <div class="input-wrapper">
                            <input type="number" id="limbo-bets" class="input-field" value="${bot.wagerMode.limboBetsPerCycle}" step="1" min="1" max="100">
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">âš ï¸ Stop Loss</div>
                    <div class="input-row">
                        <span class="input-label">Stop Loss %</span>
                        <div class="input-wrapper">
                            <input type="number" id="wager-stop-loss" class="input-field" value="${bot.wagerMode.stopLossPercent}" step="0.1" min="0.1" max="10">
                            <span class="unit">%</span>
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <div class="section-title">âš¡ Recovery System (3-Stage)</div>
                    <div class="input-row">
                        <span class="input-label">Recovery Chance</span>
                        <div class="input-wrapper">
                            <input type="number" id="recovery-chance" class="input-field" value="${bot.recoveryMode.chance}" step="0.1" min="1" max="99.5">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Wins to BEP</span>
                        <div class="input-wrapper">
                            <input type="number" id="wins-to-bep" class="input-field" value="${bot.recoveryMode.winsToBEP}" step="1" min="1" max="10">
                            <span class="unit">wins</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Bet Multiplier</span>
                        <div class="input-wrapper">
                            <input type="number" id="bet-multiplier" class="input-field" value="${bot.recoveryMode.betMultiplier}" step="0.1" min="1" max="10">
                            <span class="unit">x</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Max Bet %</span>
                        <div class="input-wrapper">
                            <input type="number" id="max-bet-percent" class="input-field" value="${bot.recoveryMode.maxBetPercent}" step="1" min="10" max="90">
                            <span class="unit">%</span>
                        </div>
                    </div>
                    <div class="input-row">
                        <span class="input-label">Aggressive After</span>
                        <div class="input-wrapper">
                            <input type="number" id="agg-losses" class="input-field" value="${bot.recoveryMode.consecutiveLossesForAggressive}" step="1" min="1" max="20">
                            <span class="unit">losses</span>
                        </div>
                    </div>
                </div>
                
                <!-- Control Buttons -->
                <div class="control-buttons">
                    <button id="p-start" class="main-btn btn-start">â–¶ START</button>
                    <button id="p-pause" class="main-btn btn-pause">â¸ PAUSE</button>
                    <button id="p-stop" class="main-btn btn-stop">â¹ STOP</button>
                </div>
                
                <!-- Live Log -->
                <div class="section-title" style="margin-top: 15px; margin-bottom: 8px;">ğŸ“Š ORION LIVE LOG</div>
                <div class="live-log" id="live-log">
                    <div style="color: #94a3b8; text-align: center; padding: 20px; font-size: 12px;">
                        <div style="margin-bottom: 10px; color: #3b82f6; font-weight: bold;">ğŸš€ ORION WAGER BOT READY</div>
                        <div style="font-size: 11px;">Enhanced 3-Stage Recovery System Active</div>
                    </div>
                </div>
            </div>
            
            <div id="p-logs" style="display: none;"></div>
        `;
        document.body.appendChild(d);

        setupEventListeners();
        updateUI();
        
        setTimeout(() => {
            API.syncOnce();
        }, 1500);
    }

    function setupEventListeners() {
        // Demo toggle
        const demoToggle = document.getElementById('demo-toggle');
        const demoLabel = document.getElementById('demo-label');
        
        if (demoToggle) {
            demoToggle.checked = bot.isDemo;
            demoToggle.addEventListener('change', function() {
                bot.isDemo = this.checked;
                demoLabel.textContent = bot.isDemo ? 'ğŸ”„ DEMO MODE' : 'ğŸ’° REAL MODE';
                demoLabel.classList.toggle('active', bot.isDemo);
                updateLogs(`Switched to ${bot.isDemo ? 'DEMO' : 'REAL'} mode`, true);
            });
        }

        // Currency selector
        const currencySelect = document.getElementById('currency-select');
        if (currencySelect) {
            currencySelect.addEventListener('change', function() {
                bot.selectedCurrency = this.value;
                const currencyInfo = bot.availableCurrencies.find(c => c.code === bot.selectedCurrency);
                updateLogs(`Currency changed to: ${currencyInfo ? currencyInfo.name : bot.selectedCurrency.toUpperCase()}`, true);
                updateUI();
            });
        }

        // Min Bet Input
        const minBetInput = document.getElementById('min-bet-input');
        if (minBetInput) {
            minBetInput.addEventListener('change', function() {
                const value = parseFloat(this.value);
                if (!isNaN(value) && value > 0) {
                    bot.globalMinBet = value;
                    updateLogs(`Min bet set to: ${value.toFixed(8)}`, true);
                    updateUI();
                } else {
                    this.value = bot.globalMinBet;
                }
            });
        }

        // Sync button
        const syncBtn = document.querySelector('.control-btn.sync');
        if (syncBtn) {
            syncBtn.addEventListener('click', async () => {
                updateLogs("ğŸ” ORION: Syncing account and currencies...", true);
                await API.syncOnce();
                updateDashboard();
                updateLogs("âœ… ORION: Sync complete!", true);
            });
        }

        // Minimize button
        const minimizeBtn = document.querySelector('.control-btn.minimize');
        if (minimizeBtn) {
            minimizeBtn.addEventListener('click', () => {
                const content = document.querySelector('.content');
                const wrap = document.getElementById('orion-wrap');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    minimizeBtn.textContent = '_';
                    wrap.style.width = '420px';
                } else {
                    content.style.display = 'none';
                    minimizeBtn.textContent = 'â–¡';
                    wrap.style.width = 'auto';
                }
            });
        }

        // Close button
        const closeBtn = document.querySelector('.control-btn.close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                if (bot.isRunning) {
                    if (confirm("ORION Bot is running. Close anyway?")) {
                        document.getElementById("orion-wrap").remove();
                    }
                } else {
                    document.getElementById("orion-wrap").remove();
                }
            });
        }

        // Input listeners
        const inputs = [
            { id: 'dice-bet-percent', property: 'wagerMode.diceBetPercent', min: 0.1, max: 20 },
            { id: 'dice-chance', property: 'wagerMode.diceChance', min: 1, max: 99.99 },
            { id: 'limbo-bet-percent', property: 'wagerMode.limboBetPercent', min: 0.1, max: 20 },
            { id: 'limbo-multiplier', property: 'wagerMode.limboMultiplier', min: 1.001 },
            { id: 'wager-stop-loss', property: 'wagerMode.stopLossPercent', min: 0.1, max: 10 },
            { id: 'recovery-chance', property: 'recoveryMode.chance', min: 1, max: 99.5 },
            { id: 'wins-to-bep', property: 'recoveryMode.winsToBEP', min: 1, max: 10 },
            { id: 'bet-multiplier', property: 'recoveryMode.betMultiplier', min: 1, max: 10 },
            { id: 'max-bet-percent', property: 'recoveryMode.maxBetPercent', min: 10, max: 90 },
            { id: 'agg-losses', property: 'recoveryMode.consecutiveLossesForAggressive', min: 1, max: 20 },
            { id: 'dice-bets', property: 'wagerMode.diceBetsPerCycle', min: 1 },
            { id: 'limbo-bets', property: 'wagerMode.limboBetsPerCycle', min: 1 }
        ];

        inputs.forEach(input => {
            const el = document.getElementById(input.id);
            if (el) {
                el.addEventListener('change', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value)) {
                        if ((!input.min || value >= input.min) && (!input.max || value <= input.max)) {
                            const props = input.property.split('.');
                            if (props.length === 2) {
                                bot[props[0]][props[1]] = value;
                            } else {
                                bot[input.property] = value;
                            }
                            updateLogs(`âš™ï¸ ${input.id.replace(/-/g, ' ')}: ${value}`, true);
                            updateUI();
                        } else {
                            e.target.value = bot[input.property.split('.')[0]][input.property.split('.')[1]];
                        }
                    }
                });
            }
        });

        // Start Button
        const pStart = document.getElementById("p-start");
        if (pStart) {
            pStart.onclick = async () => {
                if (bot.isRunning) return;

                if (!CONFIG.license.isValid() && !bot.isDemo) {
                    alert(`ğŸš« ORION License expired! Renew please.`);
                    return;
                }

                if (bot.isDemo) {
                    const demoBalanceInput = prompt("Enter Demo Starting Balance:", bot.demoBalance);
                    if (demoBalanceInput !== null) {
                        const demoBal = parseFloat(demoBalanceInput);
                        if (!isNaN(demoBal) && demoBal >= bot.globalMinBet) {
                            bot.demoBalance = demoBal;
                            updateLogs(`ğŸ’¾ Demo balance set to: ${demoBal.toFixed(8)}`, true);
                        } else {
                            alert(`Please enter a valid amount (min: ${bot.globalMinBet})`);
                            return;
                        }
                    }
                } else {
                    try {
                        await API.syncOnce();
                        if (bot.stakeUser === "Not logged in" || bot.stakeUser === "API Error") {
                            alert("ğŸ”‘ Please login to Stake first!");
                            return;
                        }
                        
                        bot.realBalance = await API.getBalance(bot.selectedCurrency);
                        if (bot.realBalance <= 0) {
                            alert(`ğŸ’° Insufficient ${bot.selectedCurrency.toUpperCase()} balance!`);
                            return;
                        }
                        
                    } catch (e) {
                        alert(`âš ï¸ Sync error: ${e.message}`);
                        return;
                    }
                }

                bot.isRunning = true;
                bot.isPaused = false;

                bot.stats = {
                    profit: 0,
                    wagered: 0,
                    startBal: 0,
                    currentBal: 0,
                    peakBalance: 0,
                    maxDrawdown: 0,
                    drawdownPercentage: 0,
                    bets: 0,
                    wins: 0,
                    loss: 0,
                    startTime: Date.now(),
                    lastBetAmount: 0,
                    lastResults: [],
                    winStreak: 0,
                    lossStreak: 0,
                    maxWinStreak: 0,
                    maxLossStreak: 0,
                    consecutiveLosses: 0,
                    consecutiveWins: 0,
                    winRate: 0,
                    wageredPercent: 0,
                    avgBetSize: 0,
                    lastReportTime: null,
                    totalProfitSinceStart: 0,
                    sessionHigh: 0,
                    sessionLow: 0
                };

                if (bot.isDemo) {
                    bot.stats.startBal = bot.demoBalance;
                    bot.stats.currentBal = bot.demoBalance;
                    bot.stats.peakBalance = bot.demoBalance;
                    bot.stats.sessionHigh = bot.demoBalance;
                    bot.stats.sessionLow = bot.demoBalance;
                } else {
                    bot.stats.startBal = bot.realBalance;
                    bot.stats.currentBal = bot.realBalance;
                    bot.stats.peakBalance = bot.realBalance;
                    bot.stats.sessionHigh = bot.realBalance;
                    bot.stats.sessionLow = bot.realBalance;
                }

                bot.recoveryMode.active = false;
                bot.wagerMode.active = true;

                initWagerMode();

                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStart) {
                    TelegramAPI.sendStartReport();
                }

                updateUI();
                updateLogs(`ğŸš€ ORION BOT STARTED! (${bot.isDemo ? 'Demo' : 'Real'} mode)`, true);
                updateLogs(`ğŸ¯ Enhanced 3-Stage Recovery System Activated`, true);

                setTimeout(() => {
                    runLoop();
                }, 100);
            };
        }

        // Stop Button
        const pStop = document.getElementById("p-stop");
        if (pStop) {
            pStop.onclick = () => {
                bot.isRunning = false;
                bot.isPaused = false;
                
                updateLogs("ğŸ›‘ ORION Bot stopped", true);
                updateUI();
                
                if (CONFIG.telegram.enabled && CONFIG.telegram.sendOnStop) {
                    TelegramAPI.sendStopReport("Manual Stop");
                }
            };
        }

        // Pause Button
        const pPause = document.getElementById("p-pause");
        if (pPause) {
            pPause.onclick = () => {
                if (!bot.isRunning) return;
                bot.isPaused = !bot.isPaused;
                
                if (bot.isPaused) {
                    pPause.textContent = "â–¶ RESUME";
                    updateLogs("â¸ ORION Bot paused", true);
                } else {
                    pPause.textContent = "â¸ PAUSE";
                    updateLogs("â–¶ ORION Bot resumed", true);
                    setTimeout(() => {
                        runLoop();
                    }, 100);
                }
                updateUI();
            };
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                document.getElementById('p-start').click();
            }
            if (e.ctrlKey && e.key === 'x') {
                e.preventDefault();
                document.getElementById('p-stop').click();
            }
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                document.getElementById('p-pause').click();
            }
        });
    }

    createUI();
})();
